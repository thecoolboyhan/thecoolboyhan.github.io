<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="非常nice的netty书籍"><title>读《netty in action》有感</title><link rel=canonical href=https://thecoolboyhan.github.io/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/><link rel=stylesheet href=/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="读《netty in action》有感"><meta property='og:description' content="非常nice的netty书籍"><meta property='og:url' content='https://thecoolboyhan.github.io/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/'><meta property='og:site_name' content='韩永发的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='netty'><meta property='article:tag' content='java'><meta property='article:tag' content='读后感'><meta property='article:tag' content='rpc'><meta property='article:published_time' content='2024-10-15T00:00:00+00:00'><meta property='article:modified_time' content='2024-10-15T00:00:00+00:00'><meta property='og:image' content='https://thecoolboyhan.github.io/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/nettyinac.png'><meta name=twitter:title content="读《netty in action》有感"><meta name=twitter:description content="非常nice的netty书籍"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://thecoolboyhan.github.io/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/nettyinac.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_3d339d0f8c590cc9.png width=300 height=400 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>韩永发的博客</a></h1><h2 class=site-description>目前人在上海，20年毕业，普通muggle，java开发。邮箱：hanyongfa2013@163.com 。</h2></div></header><ol class=menu-social><li><a href=https://github.com/thecoolboyhan target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://leetcode.cn/u/thecoolboy/ target=_blank title=力扣 rel=me><svg role="img" viewBox="0 0 24 24"><title>LeetCode</title><path d="M13.483.0a1.374 1.374.0 00-.961.438L7.116 6.226l-3.854 4.126a5.266 5.266.0 00-1.209 2.104 5.35 5.35.0 00-.125.513 5.527 5.527.0 00.062 2.362 5.83 5.83.0 00.349 1.017 5.938 5.938.0 001.271 1.818l4.277 4.193.039.038c2.248 2.165 5.852 2.133 8.063-.074l2.396-2.392c.54-.54.54-1.414.003-1.955a1.378 1.378.0 00-1.951-.003l-2.396 2.392a3.021 3.021.0 01-4.205.038l-.02-.019-4.276-4.193c-.652-.64-.972-1.469-.948-2.263a2.68 2.68.0 01.066-.523 2.545 2.545.0 01.619-1.164L9.13 8.114c1.058-1.134 3.204-1.27 4.43-.278l3.501 2.831c.593.48 1.461.387 1.94-.207a1.384 1.384.0 00-.207-1.943l-3.5-2.831c-.8-.647-1.766-1.045-2.774-1.202l2.015-2.158A1.384 1.384.0 0013.483.0zm-2.866 12.815a1.38 1.38.0 00-1.38 1.382 1.38 1.38.0 001.38 1.382H20.79a1.38 1.38.0 001.38-1.382 1.38 1.38.0 00-1.38-1.382z"/></svg></a></li><li><a href=mailto:hanyongfa2013@163.com target=_blank title=邮箱 rel=me><svg id="mdi-email-arrow-right-outline" viewBox="0 0 24 24"><path d="M13 19C13 18.66 13.04 18.33 13.09 18H4V8l8 5 8-5v5.09C20.72 13.21 21.39 13.46 22 13.81V6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18c0 1.1.9 2 2 2h9.09C13.04 19.67 13 19.34 13 19M20 6l-8 5L4 6H20m0 16V20H16V18h4V16l3 3-3 3z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#第一部分netty的概念及体系结构>第一部分、Netty的概念及体系结构</a><ol><li><a href=#第一章netty异步和事件驱动>第一章、Netty&ndash;异步和事件驱动</a><ol><li><a href=#java早期bio处理请求方式>java早期BIO处理请求方式</a></li><li><a href=#java-nio>java NIO</a></li><li><a href=#netty简介>Netty简介</a></li></ol></li><li><a href=#第二章你的第一个netty应用程序>第二章、你的第一个Netty应用程序</a><ol><li><a href=#不同的事件处理读取数据的示例>不同的事件处理，读取数据的示例</a></li><li><a href=#服务端代码>服务端代码</a></li><li><a href=#客户端代码>客户端代码</a></li></ol></li><li><a href=#第三章netty的组件和设计>第三章、Netty的组件和设计</a><ol><li><a href=#channeleventloop和channelfuture>Channel、EventLoop和ChannelFuture</a></li><li><a href=#channelhandler和channelpipeline>ChannelHandler和ChannelPipeline</a></li><li><a href=#引导>引导</a></li></ol></li><li><a href=#第四章传输>第四章、传输</a><ol><li><a href=#案例研究传输迁移>案例研究：传输迁移</a></li><li><a href=#传输api>传输API</a></li><li><a href=#内置的传输>内置的传输</a></li><li><a href=#传输的用例>传输的用例</a></li></ol></li><li><a href=#第五章bytebuf>第五章、Bytebuf</a><ol><li><a href=#bytebuf的api>ByteBuf的API</a></li><li><a href=#bytebuf类netty的数据容器>ByteBuf类&ndash;Netty的数据容器</a></li><li><a href=#字节级操作-bytebuf相关的操作>字节级操作 ByteBuf相关的操作</a></li><li><a href=#bytebufholder接口>ByteBufHolder接口</a></li><li><a href=#bytebuf分配和管理>ByteBuf分配和管理</a></li><li><a href=#引用计数>引用计数</a></li></ol></li><li><a href=#第六章channelhandler和channelpipeline>第六章、ChannelHandler和ChannelPipeline</a><ol><li><a href=#channelhandler家族>Channelhandler家族</a></li><li><a href=#channelpipeline接口>ChannelPipeline接口</a></li><li><a href=#channelhandlercontext接口>ChannelHandlerContext接口</a></li><li><a href=#异常处理>异常处理</a></li></ol></li><li><a href=#第七章eventloop和线程模型>第七章、EventLoop和线程模型</a><ol><li><a href=#eventloop接口>EventLoop接口</a></li><li><a href=#任务调度>任务调度</a></li><li><a href=#实现细节>实现细节</a></li><li><a href=#总结-2>总结</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/><img src=/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/nettyinac_hu_597293208dc46ef.png srcset="/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/nettyinac_hu_597293208dc46ef.png 800w, /p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/nettyinac_hu_797318c398257c4d.png 1600w" width=800 height=533 loading=lazy alt="Featured image of post 读《netty in action》有感"></a></div><div class=article-details><header class=article-category><a href=/categories/%E7%B2%BE%E9%80%89/>精选
</a><a href=/categories/netty/>Netty</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/>读《netty in action》有感</a></h2><h3 class=article-subtitle>非常nice的netty书籍</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 15, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 28 分钟</time></div></footer></div></header><section class=article-content><h2 id=第一部分netty的概念及体系结构>第一部分、Netty的概念及体系结构</h2><h3 id=第一章netty异步和事件驱动>第一章、Netty&ndash;异步和事件驱动</h3><h4 id=java早期bio处理请求方式>java早期BIO处理请求方式</h4><p>早期java阻塞函数处理请求的方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>execute</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建一个新的ServerSocket,用来监听指定端口上的连接请求。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ServerSocket</span><span class=w> </span><span class=n>serverSocket</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ServerSocket</span><span class=p>(</span><span class=n>port</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        对accept()的调用将会被阻塞，直到一个连接建立。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Socket</span><span class=w> </span><span class=n>clientSocket</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>serverSocket</span><span class=p>.</span><span class=na>accept</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>BufferedReader</span><span class=w> </span><span class=n>in</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BufferedReader</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>new</span><span class=w> </span><span class=n>InputStreamReader</span><span class=p>(</span><span class=n>clientSocket</span><span class=p>.</span><span class=na>getInputStream</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>PrintWriter</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PrintWriter</span><span class=p>(</span><span class=n>clientSocket</span><span class=p>.</span><span class=na>getOutputStream</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>request</span><span class=p>,</span><span class=n>response</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=p>((</span><span class=n>request</span><span class=o>=</span><span class=n>in</span><span class=p>.</span><span class=na>readLine</span><span class=p>())</span><span class=o>!=</span><span class=kc>null</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            如果客户端传递了done表示处理结束，退出循环。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=s>&#34;Done&#34;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>request</span><span class=p>))</span><span class=w> </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            处理被传递给服务器的处理方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            response=processRequest(request);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            服务器给客户端响应处理结果</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>request</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-7-1015_46_08-1720597567759_1747187950026.png loading=lazy alt=2024-7-1015_46_08-1720597567759.png></p><p>上方代码只能同时处理一个连接，要管理多个并发客户端，需要为每个新的客户端Socket创建一个新的Thread。</p><ul><li>缺点：</li></ul><ol><li><p>大部分线程几乎都处于休眠状态。</p></li><li><p>创建的每个线程都需要创建一个栈，每个栈至少都要盛情默认空间的内存。</p></li><li><p>如果线程多，上下文切换成本高。</p></li></ol><h4 id=java-nio>java NIO</h4><blockquote><p>new or Non-blocking</p><p>NIO最开始是新的输入/输出（new Input/output)的英文缩写，但该API已经出现足够长的时间，不再是“新的”了，因此，如今大多数的用户认为NIO代表非阻塞I/O，而阻塞IO是旧的输入/输出。</p></blockquote><ul><li>NIO的两个优化</li></ul><ol><li>使用setsockopt()方法配置套接字，如果没有读写调用的时候就会立刻返回。</li><li>可以使用操作系统的时间通知API注册一组非阻塞套接字，以确定它们中是否有任何的套接字已经有数据可供读写。（IO多路复用）。</li></ol><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-7-1016_00_49-1720598448120_1747187990455.png loading=lazy alt=2024-7-1016_00_49-1720598448120.png></p><p>java.nio.channels.Selector是java的非阻塞IO实现的关键。它使用了事件通知API（IO多路复用）以确认一组非阻塞套接字中有哪些已经就绪能够进行IO相关的操作。因此可以在任何的时间检查任意的读写操作的完成状态。所以可以实现一个线程处理多个并发的连接。</p><ul><li>优点：</li></ul><ol><li>使用较少的线程可以处理许多的连接，减少了内存管理和上下文切换带来的开销。</li><li>当没有IO操作需要处理的时候，线程也可以被用于其他任务。</li></ol><h4 id=netty简介>Netty简介</h4><p>Netty的特性总结</p><div class=table-wrapper><table><thead><tr><th>分类</th><th>Netty的特性</th></tr></thead><tbody><tr><td>设计</td><td>统一的API，支持多种传输类型，阻塞和非阻塞的 \n 简单而强大的线程模型 \n 真正的无连接数据报套接字支持 \n 链接逻辑组件以支持复用</td></tr><tr><td>易于使用</td><td>详细的javadoc和大量的示例集 \n</td></tr><tr><td>性能</td><td>拥有比java的核心API更高的吞吐量以及更低的延迟\n 得益于池化和复用，拥有更低的资源消耗\n 更小的内存复制</td></tr><tr><td>健壮性</td><td>不会因为慢速、快速或者超载的连接而导致OutOfMemoryError \n 消除在高速网络中NIO应用程序常见的不公平读写比率</td></tr><tr><td>安全性</td><td>完整的SSL/TLS 以及StartTLS支持 \n 可用于受限制环境下</td></tr><tr><td>社区驱动</td><td>发布快速而且频繁</td></tr></tbody></table></div><ul><li>异步和可伸缩性</li></ul><p>异步：我们不必等待一个操作的完成。异步方法会立刻返回，并且在它完成时，会直接或稍后的某个时间点通知用户。</p><p>可伸缩性：一种系统、网络或者进程在需要处理的工作不断增长时，可以通过某种可行的方式或扩大它的处理能力来适应这种增长的能力。</p><h5 id=channel>Channel</h5><p>它表示一个实体（一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或多个不同IO的操作程序组件）的开放连接，如读操作和写操作。</p><h5 id=回调>回调</h5><p>一个回调其实就是一个方法，一个指向已经被提供给另一个方法的方法引用。这使得被调用者在适当的时候可以回调调用者。是在操作完成后通知相关方常用的方式。</p><ul><li>回调示例：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 当一个连接建立，ChannelHandler回调channelActive方法，打印出连接的地址。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ConnectHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ChannelInboundHandlerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelActive</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;client &#34;</span><span class=o>+</span><span class=n>ctx</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>remoteAddress</span><span class=p>()</span><span class=o>+</span><span class=s>&#34;connected&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=future>Future</h5><p>Future是另一种在操作完成时通知应用程序的方式。这个对象可以看做是一个异步操作的结果占位符，它将在未来的某个时刻完成，并提供对其结果的访问。</p><ul><li>JDK预设的Future</li></ul><p>只允许手动检查对应的操作是否已经完成，或者一直阻塞知道它完成。</p><ul><li>Netty的ChannelFuture</li></ul><p>可以注册一个或者多个ChannelFutureListener</p><ol><li>监听的回调方法operationComplete()，会在对应的操作完成时被调用。</li><li>通过ChannelFuture可以判断该操作是成功还是失败。</li><li>通过ChannelFutureListener提供的通知机制，消除了手动检查对应的操作是否完成的必要。</li></ol><p>每个IO操作都不会阻塞，所以Netty是完全异步和事件驱动的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 演示利用ChannelFuture处理连接请求，和连接请求的结果。全程不影响其他代码。
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ChannelFuture1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>execute</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        连接会异步的建立，不影响其他逻辑代码。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>future</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>channel</span><span class=p>.</span><span class=na>connect</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InetSocketAddress</span><span class=p>(</span><span class=s>&#34;192.168.31.141&#34;</span><span class=p>,</span><span class=w> </span><span class=n>25</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//给此结果添加一个ChannelFutureListener处理方法，并根据返回结果来做出回应</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>future</span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelFutureListener</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>operationComplete</span><span class=p>(</span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>future</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>future</span><span class=p>.</span><span class=na>isSuccess</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Charset</span><span class=p>.</span><span class=na>defaultCharset</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>wf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>future</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>buffer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=k>else</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>Throwable</span><span class=w> </span><span class=n>cause</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>future</span><span class=p>.</span><span class=na>cause</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>cause</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=事件和channelhandler>事件和ChannelHandler</h5><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-7-1115_46_48-1720684007367_1747188019882.png loading=lazy alt=2024-7-1115_46_48-1720684007367.png></p><h5 id=总结>总结</h5><p>Netty的异步编程模型建立在Future和回调的概念之上的，而将事件派发到ChannelHandler的方法则发生在更深的层次上。</p><p>拦截操作以及高速地转换入站数据和出站数据，都只需要你提供回调或者利用操作所返回的Future。这使得链接操作变得既简单又高效，并且促进了可重用的通用代码的编写。</p><p>Netty通过触发事件将selector从应用程序中抽象出来，消除了所有本来将需要手动编写的派发代码。</p><h3 id=第二章你的第一个netty应用程序>第二章、你的第一个Netty应用程序</h3><h4 id=不同的事件处理读取数据的示例>不同的事件处理，读取数据的示例</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//此注解表示，当前channel-handler可以被多个Channel安全的共享</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ChannelHandler.Sharable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>EchoServerHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ChannelInboundHandlerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    每个传入的消息都会调用此方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelRead</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>in</span><span class=w> </span><span class=o>=</span><span class=p>(</span><span class=n>ByteBuf</span><span class=p>)</span><span class=w> </span><span class=n>msg</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        用来读取消息，把消息都记录到控制台</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;server received:&#34;</span><span class=o>+</span><span class=n>in</span><span class=p>.</span><span class=na>toString</span><span class=p>(</span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        把收到的消息写给发送者</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ctx</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>in</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    通知ChannelInboundHandler此消息为最后一条消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelReadComplete</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        将消息冲刷到远程节点，关闭Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ctx</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>Unpooled</span><span class=p>.</span><span class=na>EMPTY_BUFFER</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=n>ChannelFutureListener</span><span class=p>.</span><span class=na>CLOSE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    异常处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exceptionCaught</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=n>cause</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cause</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ctx</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>如果不捕获异常，会发生什么？</li></ul><p>每个Channel都拥有一个与之相关联的ChannelPipeline，其持有一个ChannelHandler的实例链。</p><p>在默认情况下，ChannelHandler会把它的方法的调用转发给链中的下一个ChannelHandler。因此，如果exceptionCaught（）方法没有被该链中的某处实现，那么所接收的异常将会被传递到ChannelPipeline的尾端并被记录。为此，你的应用程序至少与有一个实现了exceptionCaught（）方法的ChannelHandler。</p><h4 id=服务端代码>服务端代码</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//服务端主启动类，用来创建channel，绑定通道，实例处理等</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>EchoServer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    新建时指定当前服务的端口。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>EchoServer</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>port</span><span class=o>=</span><span class=n>port</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        if(args.length!=1) System.out.println(&#34;Usage:&#34;+EchoServer.class.getSimpleName()+&#34;&lt;port&gt;&#34;);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        int port=Integer.parseInt(args[0]);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=w> </span><span class=o>=</span><span class=n>8080</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            启动服务器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>new</span><span class=w> </span><span class=n>EchoServer</span><span class=p>(</span><span class=n>port</span><span class=p>).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>InterruptedException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>start</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w>  </span><span class=n>EchoServerHandler</span><span class=w> </span><span class=n>serverHandler</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>EchoServerHandler</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建事件处理线程池</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>EventLoopGroup</span><span class=w> </span><span class=n>group</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>NioEventLoopGroup</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            服务器启动器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ServerBootstrap</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ServerBootstrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            指定服务器使用哪个线程池</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>b</span><span class=p>.</span><span class=na>group</span><span class=p>(</span><span class=n>group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    指定所使用的channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>channel</span><span class=p>(</span><span class=n>NioServerSocketChannel</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    设置端口号</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>localAddress</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InetSocketAddress</span><span class=p>(</span><span class=n>port</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    指定一个EchoServerHandler到子channel的channelPipeline里</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>childHandler</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelInitializer</span><span class=o>&lt;</span><span class=n>SocketChannel</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>initChannel</span><span class=p>(</span><span class=n>SocketChannel</span><span class=w> </span><span class=n>ch</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                            上面创建的Handler被标记为@Shareable，可以重复使用相同的实例。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=n>serverHandler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            sync()阻塞线程，直到完成绑定</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=na>bind</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            没有收到closeFuture就一直等待</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>f</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>closeFuture</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            关闭线程池，释放资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>group</span><span class=p>.</span><span class=na>shutdownGracefully</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol><li>EchoServerHandler实现了业务逻辑</li><li>main方法引导服务器</li><li>创建一个ServerBootstrap的实例以引导和绑定服务器</li><li>创建并分配一个NioEventLoopGroup实例以进行事件的处理，如接受新连接以及读写数据</li><li>指定服务器绑定的本地的InetSocketAddress</li><li>使用一个EchoServerHandler的实例初始化每一个新的channel</li><li>调用ServerBootstrap.bind()方法来绑定服务器。</li></ol><h4 id=客户端代码>客户端代码</h4><ul><li>客户端事件处理代码</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@ChannelHandler.Sharable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>EchoClientHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>SimpleChannelInboundHandler</span><span class=o>&lt;</span><span class=n>ByteBuf</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    在到服务器的连接已经建立之后被调用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelActive</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        建立连接后，发送一条消息！</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ctx</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;Netty rocks!&#34;</span><span class=p>,</span><span class=w> </span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    当从服务接收到一条消息后被调用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelRead0</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Client received:&#34;</span><span class=o>+</span><span class=n>msg</span><span class=p>.</span><span class=na>toString</span><span class=p>(</span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    出现异常时调用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exceptionCaught</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=n>cause</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cause</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ctx</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>引导客户端代码</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>EchoClient</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>host</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>EchoClient</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>host</span><span class=p>,</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>host</span><span class=o>=</span><span class=n>host</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>port</span><span class=o>=</span><span class=n>port</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>start</span><span class=p>()</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>NioEventLoopGroup</span><span class=w> </span><span class=n>group</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>NioEventLoopGroup</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Bootstrap</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Bootstrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>b</span><span class=p>.</span><span class=na>group</span><span class=p>(</span><span class=n>group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>channel</span><span class=p>(</span><span class=n>NioSocketChannel</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>remoteAddress</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InetSocketAddress</span><span class=p>(</span><span class=n>host</span><span class=p>,</span><span class=n>port</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>handler</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelInitializer</span><span class=o>&lt;</span><span class=n>SocketChannel</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>initChannel</span><span class=p>(</span><span class=n>SocketChannel</span><span class=w> </span><span class=n>ch</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=k>new</span><span class=w> </span><span class=n>EchoClientHandler</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=na>connect</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>f</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>closeFuture</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>group</span><span class=p>.</span><span class=na>shutdownGracefully</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>String</span><span class=w> </span><span class=n>host</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=o>=</span><span class=n>10086</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>new</span><span class=w> </span><span class=n>EchoClient</span><span class=p>(</span><span class=n>host</span><span class=p>,</span><span class=n>port</span><span class=p>).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ol><li>初始化客户端，创建一个bootstrap实例</li><li>为事件处理分配一个nioEventLoopGroup实例，其中事件处理包括创建新的连接以及处理入站和出站数据</li><li>为服务器连接创建一个InetSocketAddress实例。</li><li>当连接被建立时，一个EchoClientHandler实例被安装到channelPipeline中。</li><li>在一切都设置完后，调用bootstrap。connect（）方法连接到远程节点、</li></ol><h3 id=第三章netty的组件和设计>第三章、Netty的组件和设计</h3><h4 id=channeleventloop和channelfuture>Channel、EventLoop和ChannelFuture</h4><p>Channel：socket</p><p>EventLoop：控制流、多线程处理、并发；</p><p>ChannelFuture：异步通知。</p><ul><li>Channel接口</li></ul><p>用来处理socket连接</p><ul><li>EventLoop接口</li></ul><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-7-1216_14_58-1720772097636_1747188058262.png loading=lazy alt=2024-7-1216_14_58-1720772097636.png></p><ol><li>一个EventLoopGroup包含一个或者多个EventLoop</li><li>一个EventLoop在它的生命周期内只和一个Thread绑定</li><li>所有由EventLoop处理的IO事件都将在它专有的Thread上被处理</li><li>一个Channel在它的生命周期内只注册于一个EventLoop</li><li>一个EventLoop可能会被分配给一个或多个Channel</li></ol><blockquote><p>一个给定的Channel的io操作都是由相同的Thread执行的，这样消除了对于同步的需要。</p></blockquote><ul><li>ChannelFuture接口</li></ul><p>一个操作可能不会立刻返回，ChannelFuture接口用来确认其结果。（无论成功还是失败）</p><h4 id=channelhandler和channelpipeline>ChannelHandler和ChannelPipeline</h4><ul><li>ChannelHandler接口</li></ul><p>Netty的主要组件就是ChannelHandler，他是所有处理入站、出站数据的应用程序逻辑的容器。</p><ul><li>ChannelPipeline接口</li></ul><p>ChannelPipeline提供了ChannelHandler链的容器，并定义了用于在该链上传播入站、出站事件流的API。当Channel被创建，它会自动被分配到它专属的ChannelPipeline。</p><blockquote><p>ChannelHandler安装到ChannelPipeline的过程：</p></blockquote><ol><li>一个ChannelInitializer的实现被注册到ServerBootstrap中。</li><li>当ChannelInitializer.initChannel()方法被调用，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler；</li><li>ChannelInitializer将它自己从ChannelPipeline中移除。</li></ol><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-7-1223_26_27-1720797986303_1747188083571.png loading=lazy alt=2024-7-1223_26_27-1720797986303.png></p><ul><li>编码器和解码器</li></ul><p>一般，入站数据会从字节转换为我们需要的编码，出站数据要从当前编码转换成字节。</p><h4 id=引导>引导</h4><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-7-1617_32_17-1721122336933_1747188106888.png loading=lazy alt=2024-7-1617_32_17-1721122336933.png></p><h3 id=第四章传输>第四章、传输</h3><h4 id=案例研究传输迁移>案例研究：传输迁移</h4><blockquote><p>演示一次从阻塞OIO连接处理到非阻塞NIO迁移，java原生和Netty的迁移成本对比。</p></blockquote><ul><li>不通过Netty使用OIO和NIO</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PlainOioServer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>serve</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        给服务器绑定指定端口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>ServerSocket</span><span class=w> </span><span class=n>socket</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>ServerSocket</span><span class=p>(</span><span class=n>port</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(;;){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                接收连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>final</span><span class=w> </span><span class=n>Socket</span><span class=w> </span><span class=n>clientSocket</span><span class=o>=</span><span class=n>socket</span><span class=p>.</span><span class=na>accept</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;Accepted conection from &#34;</span><span class=o>+</span><span class=n>clientSocket</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                创建一个线程处理连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>OutputStream</span><span class=w> </span><span class=n>out</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                            给连接自己的客户端返回消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>out</span><span class=o>=</span><span class=n>clientSocket</span><span class=p>.</span><span class=na>getOutputStream</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>out</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=s>&#34;Hi!\r\n&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=n>Charset</span><span class=p>.</span><span class=na>forName</span><span class=p>(</span><span class=s>&#34;UTF-8&#34;</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>out</span><span class=p>.</span><span class=na>flush</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                            关闭连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>clientSocket</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>finally</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>clientSocket</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                关闭异常</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    线程启动</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}).</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>Exception</span><span class=w> </span><span class=n>e</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上方代码可以处理中等数量的并发客户端。但随着应用程序流行起来，它并不能很好的伸缩到支撑成千上万的并发连入连接。</p><ul><li>基于java NIO的非阻塞版本</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>PlainNioServer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>serve</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>IOException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建一个服务器Channel，</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ServerSocketChannel</span><span class=w> </span><span class=n>serverChannel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ServerSocketChannel</span><span class=p>.</span><span class=na>open</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        设置当前Channel为非阻塞的</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>serverChannel</span><span class=p>.</span><span class=na>configureBlocking</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        获取当前Channel的socket对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ServerSocket</span><span class=w> </span><span class=n>socket</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>serverChannel</span><span class=p>.</span><span class=na>socket</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        新建一个ip+端口的网络地址</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>InetSocketAddress</span><span class=w> </span><span class=n>address</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>InetSocketAddress</span><span class=p>(</span><span class=n>port</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        把地址绑定到serverSocket对象上</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>socket</span><span class=p>.</span><span class=na>bind</span><span class=p>(</span><span class=n>address</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        打开selector：开始接收Channel中的事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Selector</span><span class=w> </span><span class=n>selector</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Selector</span><span class=p>.</span><span class=na>open</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        把serverSocket注册到selector上</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>serverChannel</span><span class=p>.</span><span class=na>register</span><span class=p>(</span><span class=n>selector</span><span class=p>,</span><span class=w> </span><span class=n>SelectionKey</span><span class=p>.</span><span class=na>OP_ACCEPT</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>ByteBuffer</span><span class=w> </span><span class=n>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ByteBuffer</span><span class=p>.</span><span class=na>wrap</span><span class=p>(</span><span class=s>&#34;Hi!\r\n&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(;</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                开始接收时间，目前处于阻塞状态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>selector</span><span class=p>.</span><span class=na>select</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>e</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            获取时间的选择key</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Set</span><span class=o>&lt;</span><span class=n>SelectionKey</span><span class=o>&gt;</span><span class=w> </span><span class=n>readyKeys</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>selector</span><span class=p>.</span><span class=na>selectedKeys</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            开始遍历</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Iterator</span><span class=o>&lt;</span><span class=n>SelectionKey</span><span class=o>&gt;</span><span class=w> </span><span class=n>iterator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>readyKeys</span><span class=p>.</span><span class=na>iterator</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>iterator</span><span class=p>.</span><span class=na>hasNext</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>SelectionKey</span><span class=w> </span><span class=n>key</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>iterator</span><span class=p>.</span><span class=na>next</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                开始处理当前上面的key，则删除此key（避免重复处理）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>iterator</span><span class=p>.</span><span class=na>remove</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    判断是否就绪（可以被连接）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>isAcceptable</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                        获取此key的Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>ServerSocketChannel</span><span class=w> </span><span class=n>server</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>ServerSocketChannel</span><span class=p>)</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>SocketChannel</span><span class=w> </span><span class=n>client</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>server</span><span class=p>.</span><span class=na>accept</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>client</span><span class=p>.</span><span class=na>configureBlocking</span><span class=p>(</span><span class=kc>false</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                        把当前客户端Channel的读写事件监听注册到selector上</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>client</span><span class=p>.</span><span class=na>register</span><span class=p>(</span><span class=n>selector</span><span class=p>,</span><span class=n>SelectionKey</span><span class=p>.</span><span class=na>OP_WRITE</span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=n>SelectionKey</span><span class=p>.</span><span class=na>OP_READ</span><span class=p>,</span><span class=n>msg</span><span class=p>.</span><span class=na>duplicate</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;accepted connection from&#34;</span><span class=o>+</span><span class=n>client</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    如果写事件就绪</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=p>(</span><span class=n>key</span><span class=p>.</span><span class=na>isWritable</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                        获取当前客户端的Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>SocketChannel</span><span class=w> </span><span class=n>client</span><span class=o>=</span><span class=p>(</span><span class=n>SocketChannel</span><span class=p>)</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                        当前通道的缓存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>ByteBuffer</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>ByteBuffer</span><span class=p>)</span><span class=w> </span><span class=n>key</span><span class=p>.</span><span class=na>attachment</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>while</span><span class=p>(</span><span class=n>buffer</span><span class=p>.</span><span class=na>hasRemaining</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                            把数据写到当前通道</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>if</span><span class=p>(</span><span class=n>client</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>buffer</span><span class=p>)</span><span class=o>==</span><span class=n>0</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                        关闭连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>client</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>key</span><span class=p>.</span><span class=na>cancel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>key</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=n>IOException</span><span class=w> </span><span class=n>ex</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;关闭失败！&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=n>ex</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>throw</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RuntimeException</span><span class=p>(</span><span class=n>e</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>使用Netty的阻塞网络编程</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Netty OIO演示
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>NettyOioServer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>server</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>unreleasableBuffer</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;Hi!\r\t&#34;</span><span class=p>,</span><span class=w> </span><span class=n>StandardCharsets</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        新建一个事件处理Oio的线程组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>EventLoopGroup</span><span class=w> </span><span class=n>group</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>OioEventLoopGroup</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            创建一个启动引导类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ServerBootstrap</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ServerBootstrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            把OIO组绑定到当前引导类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>b</span><span class=p>.</span><span class=na>group</span><span class=p>(</span><span class=n>group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    给事件组指定处理事件的Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>channel</span><span class=p>(</span><span class=n>OioServerSocketChannel</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    设计当前server的ip</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>localAddress</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InetSocketAddress</span><span class=p>(</span><span class=n>port</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    指定Channel的处理方式,所有连接都会调用此方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>childHandler</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelInitializer</span><span class=o>&lt;</span><span class=n>SocketChannel</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>initChannel</span><span class=p>(</span><span class=n>SocketChannel</span><span class=w> </span><span class=n>ch</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                    给当前处理链添加一个拦截处理器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=k>new</span><span class=w> </span><span class=n>ChannelInboundHandlerAdapter</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                        处理器实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelActive</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                            把消息写给客户端</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                            </span><span class=n>ctx</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=na>duplicate</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                                    </span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                                            写完消息后,触发连接关闭事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                                            </span><span class=n>ChannelFutureListener</span><span class=p>.</span><span class=na>CLOSE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            绑定服务器来接收连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=na>bind</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>f</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>closeFuture</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            释放所有资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>group</span><span class=p>.</span><span class=na>shutdownGracefully</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>基于Netty的异步网络处理</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * 基于Netty的Nio网络连接
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>NettyNioServer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>server</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>port</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>final</span><span class=w> </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>unreleasableBuffer</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;Hi!\r\t&#34;</span><span class=p>,</span><span class=w> </span><span class=n>StandardCharsets</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        新建一个事件处理Oio的线程组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>NioEventLoopGroup</span><span class=w> </span><span class=n>group</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>NioEventLoopGroup</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            创建一个启动引导类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ServerBootstrap</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ServerBootstrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            把OIO组绑定到当前引导类</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>b</span><span class=p>.</span><span class=na>group</span><span class=p>(</span><span class=n>group</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    给事件组指定处理事件的Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>channel</span><span class=p>(</span><span class=n>NioServerSocketChannel</span><span class=p>.</span><span class=na>class</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    设计当前server的ip</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>localAddress</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>InetSocketAddress</span><span class=p>(</span><span class=n>port</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                    指定Channel的处理方式,所有连接都会调用此方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>.</span><span class=na>childHandler</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelInitializer</span><span class=o>&lt;</span><span class=n>SocketChannel</span><span class=o>&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>initChannel</span><span class=p>(</span><span class=n>SocketChannel</span><span class=w> </span><span class=n>ch</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>ch</span><span class=p>.</span><span class=na>pipeline</span><span class=p>().</span><span class=na>addLast</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                    给当前处理链添加一个拦截处理器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=k>new</span><span class=w> </span><span class=n>ChannelInboundHandlerAdapter</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=c1>//                                        处理器实现</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelActive</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                            把消息写给客户端</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                            </span><span class=n>ctx</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=na>duplicate</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                                    </span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//                                                            写完消息后,触发连接关闭事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                                            </span><span class=n>ChannelFutureListener</span><span class=p>.</span><span class=na>CLOSE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                                    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            绑定服务器来接收连接</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>.</span><span class=na>bind</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>f</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>closeFuture</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=k>finally</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            释放所有资源</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>group</span><span class=p>.</span><span class=na>shutdownGracefully</span><span class=p>().</span><span class=na>sync</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>只修改了两行代码：</p><ol><li>把事件处理的组从OioEventLoopGroup换成了NioEventLoopGroup。</li><li>把当前组绑定的时间处理Channel从OioServerSocketChannel.class换成NioServerSocketChannel.class</li></ol><p>其他无需修改。</p><p>Netty每种传输的实现都暴露相同的API，所以无论选择哪种实现，其他代码几乎都不受影响。</p><h4 id=传输api>传输API</h4><p>传输api的核心是Channel接口，它被用于所有的IO操作。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17213748431541721374842200.png loading=lazy alt=17213748431541721374842200.png></p><p>每个Channel都会分配一个ChannelPipeline和ChannelConfig。</p><ul><li>ChannelConfig</li></ul><p>包含了该Channel的所有配置设置，并且支持热更新。</p><ul><li>ChannelPipeline</li></ul><p>持有所有用于入站和出站数据以及事件的ChannelHandler实例。</p><p>ChannelHandler实现了应用程序处理状态变化以及数据处理的逻辑。</p><ul><li>ChannelHandler的用途：</li></ul><ol><li>将数据的一种格式转换成另一种格式</li><li>提供异常的通知</li><li>提供Channel变为活动或者非活动的通知</li><li>当Channel注册到EventLoop或者从EventLoop注销时的通知</li><li>用户自定义事件的通知。</li></ol><ul><li>Channel的几个重要方法</li></ul><div class=table-wrapper><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>eventLoop</td><td>返回分配给Channel的EventLoop</td></tr><tr><td>Pipeline</td><td>返回分配给Channel的ChannelPipeline</td></tr><tr><td>isActive</td><td>如果Channel是活动的，返回true。（一个socket传输一旦连接到了远程节点便是活动的，一个Datagram传输一旦被打开就是活动的）</td></tr><tr><td>localAddress</td><td>返回本地socketAddress</td></tr><tr><td>remoteAddress</td><td>返回远程socketAddress</td></tr><tr><td>write</td><td>把数据写到远程节点。这个数据将被传递给ChannelPipeline，并且排队直到它被冲刷</td></tr><tr><td>flush</td><td>将之前已写的数据冲刷到底层传输，如一个socket</td></tr><tr><td>writeAndFlush</td><td>先调用write然后调用flush</td></tr></tbody></table></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//    写出数据到Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>demo1</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        申请空间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;your data&#34;</span><span class=p>,</span><span class=w> </span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        写完数据并冲刷（提交）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>cf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>channel</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>buf</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        添加ChannelFutureListener用来写完后接收通知</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cf</span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelFutureListener</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>operationComplete</span><span class=p>(</span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>future</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>future</span><span class=p>.</span><span class=na>isSuccess</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;write successful&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>else</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>System</span><span class=p>.</span><span class=na>err</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;write error&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>cause</span><span class=p>().</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    多个线程使用同一个Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>demo2</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;your data&#34;</span><span class=p>,</span><span class=w> </span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建一个把数据写到Channel的runnable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Runnable</span><span class=w> </span><span class=n>write</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>channel</span><span class=p>.</span><span class=na>writeAndFlush</span><span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=na>duplicate</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        获取一个线程池</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Executor</span><span class=w> </span><span class=n>executor</span><span class=o>=</span><span class=w> </span><span class=n>Executors</span><span class=p>.</span><span class=na>newCachedThreadPool</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        把任务提交给一个线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>execute</span><span class=p>(</span><span class=n>write</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        把任务提交给另一个线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>execute</span><span class=p>(</span><span class=n>write</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Netty的Channel是线程安全的，所以无论是提交给一个线程还是多个线程同时调用，都不会有问题。</p><h4 id=内置的传输>内置的传输</h4><ul><li>Netty所提供的传输</li></ul><div class=table-wrapper><table><thead><tr><th>名称</th><th>包</th><th>描述</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.nio</td><td>使用java.nio.channels包作为基础&ndash;基于选择器的方式</td></tr><tr><td>Epoll</td><td>io.netty.channel.epoll</td><td>由JNI驱动的epoll和非阻塞IO。这个传输支持只有在linux上 可用的多种特性，如SO_REUSEPORT，比NIO传输更快，而且是完全非阻塞的</td></tr><tr><td>OIO</td><td>io.netty.channel.oio（已弃用）</td><td>使用java.net包作为基础&ndash;使用阻塞流</td></tr><tr><td>local</td><td>io.netty.channel.local</td><td>可以在VM内部通过管道进行通信的本地传输</td></tr><tr><td>embedded</td><td>io.netty.channel.embedded</td><td>允许使用ChannelHandler而又不需要一个真正基于网络的传输。</td></tr><tr><td>kqueue</td><td></td><td></td></tr></tbody></table></div><ul><li>NIO&mdash;-非阻塞IO</li></ul><p>NIO一个所有IO操作完全异步的实现。</p><blockquote><p>基于选择器的API</p></blockquote><p>选择器充当了一个注册表，在那里可以请求在Channel的状态发生变化时得到通知。</p><ol><li>新的Channel已被接受并且就绪</li><li>Channel连接已经完成</li><li>Channel有已经就绪的可供读取的数据</li><li>Channel可用于写数据</li></ol><blockquote><p>选择操作的位模式</p></blockquote><div class=table-wrapper><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>OP_ACCEPT</td><td>请求在接受新连接并创建Channel时获得通知</td></tr><tr><td>OP_CONNECT</td><td>请求在建立一个连接时获得通知</td></tr><tr><td>OP_READ</td><td>请求当数据已就绪，可以从Channel中读取时获得通知</td></tr><tr><td>OP_WRITE</td><td>请求当可以想Channel中写更多数据时获得通知。</td></tr></tbody></table></div><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17213824004291721382399481.png loading=lazy alt=17213824004291721382399481.png></p><blockquote><p>零拷贝（Zero-copy）</p></blockquote><p>目前只有在使用NIO和Epoll传输时才可使用的特性。可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间。在FTP或者HTTP这样的协议中可以显著地提高性能。（并不是所有操作系统都支持）</p><blockquote><p>零拷贝对于实现了数据加密或者压缩的文件系统是不可用的（只能传输文件的原始内容）</p></blockquote><ul><li>Epoll&ndash;用于Linux的本地非阻塞传输</li></ul><blockquote><p>Linux专属的NIO API，在高负载下它的性能要优于JDK的NIO实现。</p></blockquote><p>原理和图4-2完全相同。</p><ul><li>OIO-旧的阻塞IO（已废弃）</li></ul><p>建立在java.net包的阻塞实现之上的，非异步。</p><ul><li>用于JVM内部通信的Local传输</li></ul><p>用于在同一个JVM中运行的客户端和服务器程序之间的异步通信。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17219082813701721908281040.png loading=lazy alt=17219082813701721908281040.png></p><ul><li>Embedded传输</li></ul><p>Netty提供的额外的传输，可以将一组ChannelHandler作为帮助类嵌入到其他的ChannelHandler内部。</p><h4 id=传输的用例>传输的用例</h4><div class=table-wrapper><table><thead><tr><th>传输</th><th>TCP</th><th>UDP</th><th>SCTP</th><th>UDT</th></tr></thead><tbody><tr><td>NIO</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>Epoll(仅linux)</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>OIO</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr></tbody></table></div><ul><li>每种应用程序推荐的传输方式</li></ul><div class=table-wrapper><table><thead><tr><th>应用程序的需求</th><th>推荐的传输</th></tr></thead><tbody><tr><td>非阻塞代码库或者一个常规代码的起步</td><td>NIO（或者在Linux上使用epoll）</td></tr><tr><td>阻塞代码库</td><td>OIO</td></tr><tr><td>同一个JVM内部</td><td>Local</td></tr><tr><td>测试ChannelHandler的实现</td><td>Embedded</td></tr></tbody></table></div><h3 id=第五章bytebuf>第五章、Bytebuf</h3><h4 id=bytebuf的api>ByteBuf的API</h4><ul><li>优点</li></ul><ol><li>可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区实现了透明的零拷贝</li><li>容量可以按需增长（类似于JDK的StringBuilder）</li><li>在读和写两种模式之间切换不需要调用bytebuffer的flip()方法</li><li>读和写使用了不同的索引</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持池化</li></ol><h4 id=bytebuf类netty的数据容器>ByteBuf类&ndash;Netty的数据容器</h4><ul><li>原理</li></ul><p>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。</p><p>当你从ByteBuf中读取时，它的readerIndex将会被递增已经被读取的字节数。</p><p>当写入bytebuf时，它的writerIndex也会被递增。</p><ul><li>下标越界异常</li></ul><blockquote><p>当你读取到“可以读取的”数据的末尾（读取指针等于当前写入指针的位置），如果仍试图读取超出该点的数据，会触发IndexOutOfBoundsException</p></blockquote><ul><li>堆缓冲区（支撑数组backing array）</li></ul><blockquote><p>将数据存储在JVM的堆内存中，可以在没有使用池化的情况下提供快速的分配和释放。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 堆缓冲区方式使用bytebuf。
</span></span></span><span class=line><span class=cl><span class=cm>     * @param buf   缓冲区
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>byteBufNum</span><span class=p>(</span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buf</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        检测bytebuf是否存在支撑数组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=na>hasArray</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            获取该支撑数组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>array</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buf</span><span class=p>.</span><span class=na>array</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            计算出当前的偏移量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>offset</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buf</span><span class=p>.</span><span class=na>arrayOffset</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>buf</span><span class=p>.</span><span class=na>readerIndex</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            获取可读的字节数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>len</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buf</span><span class=p>.</span><span class=na>readableBytes</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            handleArray(array,offset,len);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>直接缓冲区</li></ul><blockquote><p>通过直接内存来访问数据，由于缓冲区中的数据不是在JVM内部的所以不会自动垃圾回收。</p></blockquote><p>优点：</p><p>理想的网络数据传输选择。传统堆中的缓冲区的数据，JVM在进行网络传输时，会先把堆中的数据复制到堆外，然后再发送。</p><p>缺点：</p><ol><li>由于数据在堆外，所以分配和释放空间都比较昂贵。</li><li>因为数据不在堆上，所以不得不进行一次复制。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 通过直接内存操作缓冲区
</span></span></span><span class=line><span class=cl><span class=cm>     * @param directBuf 缓冲区
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>byteBufDirect</span><span class=p>(</span><span class=n>ByteBuf</span><span class=w> </span><span class=n>directBuf</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        检测是否存在数组缓冲区，如果不则认为当前缓冲区是直接内存缓冲区</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>directBuf</span><span class=p>.</span><span class=na>hasArray</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            获取当前缓冲区的可读长度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>length</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>directBuf</span><span class=p>.</span><span class=na>readableBytes</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            分配字节数组来接收</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>array</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>length</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            从缓冲区读取数据到上方数组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>directBuf</span><span class=p>.</span><span class=na>getBytes</span><span class=p>(</span><span class=n>directBuf</span><span class=p>.</span><span class=na>readerIndex</span><span class=p>(),</span><span class=n>array</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//            handleArray(array,offset,len);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>复合缓冲区</li></ul><blockquote><p>Netty通过一个byteBuf子类&ndash;CompositeByteBuf&ndash;实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p></blockquote><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17223414940961722341493900.png loading=lazy alt=17223414940961722341493900.png></p><p>将通常不会变动的数据存放到主体缓冲区，将经常变动的数据存放到头部缓冲区。</p><p>多个头部缓冲区可以共享同一个主体缓冲区。</p><p>将不同的主体和头部组合在一起，可以看做一个不同的缓冲区。</p><blockquote><p>这样操作可以避免没有必要的复制。（主体缓冲区始终只有一份）</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm>     * 复合缓冲区
</span></span></span><span class=line><span class=cl><span class=cm>     * @param headByteBuf 头缓冲区
</span></span></span><span class=line><span class=cl><span class=cm>     * @param bodyBuf 主体缓冲区
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>ByteBufComposite</span><span class=p>(</span><span class=n>ByteBuf</span><span class=w> </span><span class=n>headByteBuf</span><span class=p>,</span><span class=n>ByteBuf</span><span class=w> </span><span class=n>bodyBuf</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CompositeByteBuf</span><span class=w> </span><span class=n>messageBuf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Unpooled</span><span class=p>.</span><span class=na>compositeBuffer</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>messageBuf</span><span class=p>.</span><span class=na>addComponents</span><span class=p>(</span><span class=n>headByteBuf</span><span class=p>,</span><span class=n>bodyBuf</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        访问CompositeByteBuf中的数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>length</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>messageBuf</span><span class=p>.</span><span class=na>readableBytes</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建一个用来存放复合缓冲区中数据的空间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>byte</span><span class=o>[]</span><span class=w> </span><span class=n>array</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>byte</span><span class=o>[</span><span class=n>length</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        将缓冲区中的数据复制到空间中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>messageBuf</span><span class=p>.</span><span class=na>getBytes</span><span class=p>(</span><span class=n>messageBuf</span><span class=p>.</span><span class=na>readerIndex</span><span class=p>(),</span><span class=w> </span><span class=n>array</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        删除复合缓冲区中的第一个缓冲区</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>messageBuf</span><span class=p>.</span><span class=na>removeComponent</span><span class=p>(</span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buf</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>messageBuf</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=na>toString</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=字节级操作-bytebuf相关的操作>字节级操作 ByteBuf相关的操作</h4><ul><li>随机访问索引</li></ul><p>直接通过buffer.getByte(i)通过下标访问缓冲区中的数据</p><p>这样不会改变readerIndex和writerIndex</p><ul><li>顺序访问</li></ul><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17223435050931722343504656.png loading=lazy alt=17223435050931722343504656.png></p><ul><li>可丢弃的字节</li></ul><p>通过调用discardReadBytes()方法来丢弃回收可丢弃的空间。</p><p>被回收的空间会用来分配给可写空间中，但不是直接分配。而是会触发一个整理的过程。所有未读的空间整理到内存的头部，再移动可读和可写的下标。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17223437700931722343769639.png loading=lazy alt=17223437700931722343769639.png></p><blockquote><p>会导致内存复制。</p></blockquote><ul><li>可读字节</li></ul><p>可读字节中的内存存放了真正的数据。</p><ul><li>可写字节</li></ul><p>可写字节表示为被定义、或者写入就绪的内存区域。（这个区域中有可能有部分脏数据）</p><h4 id=bytebufholder接口>ByteBufHolder接口</h4><blockquote><p>Netty用来管理ByteBuf的接口</p></blockquote><div class=table-wrapper><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>content()</td><td>返回由这个ByteBufholder所持有的ByteBuf</td></tr><tr><td>copy</td><td>返回ByteBufHolder的一个深拷贝，包括含有一个其包含的ByteBuf的非共享拷贝</td></tr><tr><td>duplicate</td><td>返回ByteBufHolder的一个浅拷贝，包括一个其所包含的ByteBuf的共享拷贝</td></tr></tbody></table></div><h4 id=bytebuf分配和管理>ByteBuf分配和管理</h4><blockquote><p>管理ByteBuf实例的不同方式</p></blockquote><h5 id=按需分配bytebufallocator接口>按需分配ByteBufAllocator接口</h5><blockquote><p>实现了ByteBuf的池化技术</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//    获取ByteBufAllocator对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>ByteBufAllocator</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=p>,</span><span class=w> </span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        从Channel中获取ByteBufAllocator</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBufAllocator</span><span class=w> </span><span class=n>allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>channel</span><span class=p>.</span><span class=na>alloc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        从ChannelHandler中获取ByteBufAllocator</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBufAllocator</span><span class=w> </span><span class=n>allocator2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ctx</span><span class=p>.</span><span class=na>alloc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Netty提供了两种ByteBufAllocator的实现：</p><ul><li>PooledByteBufAllocator（默认）</li></ul><p>池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片，此实现使用了一种称为jemalloc② 的已被大量现代操作系统所采用的高效方法来分配内存。</p><ul><li>UnpooledByteBufAllocator</li></ul><p>非池化技术</p><h5 id=unpooled缓冲区>Unpooled缓冲区</h5><p>有静态的辅助方法，来提供未池化的ByteBuf实例。</p><h5 id=bytebufutil类>ByteBufUtil类</h5><p>提供了用于操作ByteBuf的辅助方法。</p><h4 id=引用计数>引用计数</h4><p>Netty使用ReferenceCounted实现的引用计数，来管理池化ByteBuf中是否要回收内存。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//    释放ByteBuf的空间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>ByteBufReferenceCounted</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        从Channel中获取池管理器</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBufAllocator</span><span class=w> </span><span class=n>allocator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>channel</span><span class=p>.</span><span class=na>alloc</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        从池中获取ByteBuf对象</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ByteBuf</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>allocator</span><span class=p>.</span><span class=na>directBuffer</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        检查当前ByteBuf引用数是否为1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>assert</span><span class=w> </span><span class=n>buffer</span><span class=p>.</span><span class=na>refCnt</span><span class=p>()</span><span class=o>==</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        释放内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=w> </span><span class=n>release</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>buffer</span><span class=p>.</span><span class=na>release</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=第六章channelhandler和channelpipeline>第六章、ChannelHandler和ChannelPipeline</h3><h4 id=channelhandler家族>Channelhandler家族</h4><h5 id=channel的生命周期>Channel的生命周期</h5><div class=table-wrapper><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel已经被创建，但还未注册到EventLoop</td></tr><tr><td>ChannelRegistered</td><td>Channel已经被注册到了EventLoop</td></tr><tr><td>ChannelActive</td><td>Channel处于活动状态（已经连接到它的远程节点）可以接收和发送数据了</td></tr><tr><td>ChannelInactive</td><td>Channel没有连接到远程节点</td></tr></tbody></table></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph TD
</span></span><span class=line><span class=cl>	a[ChannelUnregistered]--&gt;b[ChannelRegistered]
</span></span><span class=line><span class=cl>	b--&gt;c[ChannelActive]
</span></span><span class=line><span class=cl>	c--&gt;d[ChannelInactive]
</span></span></code></pre></td></tr></table></div></div><h5 id=channelhandler的生命周期>ChannelHandler的生命周期</h5><div class=table-wrapper><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>handlerAdded</td><td>当把ChannelHandler添加到ChannelPipeline中时被调用</td></tr><tr><td>handlerRemoved</td><td>当从ChannelPipeline中移除ChannelHandler时被调用</td></tr><tr><td>exceptionCaught</td><td>当处理过程中在ChannelPipeline中有错误产生时被调用</td></tr></tbody></table></div><p>ChannelHandler下有两个重要的子接口</p><ul><li>ChannelInboundHandler 接口</li></ul><blockquote><p>处理入站数据以及各种状态变化</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//利用ChannelInboundHandlerAdapter显式的释放内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@ChannelHandler.Sharable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DiscardHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ChannelInboundHandlerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    用来显式的释放与池化的ByteBuf实例相关的内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelRead</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        丢失已接收的消息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ReferenceCountUtil</span><span class=p>.</span><span class=na>release</span><span class=p>(</span><span class=n>msg</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//利用SimpleChannelInboundHandler显式的释放内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>class</span> <span class=nc>SimpleDiscardHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>SimpleChannelInboundHandler</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>protected</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>channelRead0</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>msg</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        自动释放内存，不需要手动</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>ChannelOutboundHandler 接口</li></ul><blockquote><p>处理出站操作的接口，可以按需推迟操作或者事件</p></blockquote><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231143465381723114345744.png><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph TD
</span></span><span class=line><span class=cl>	a[ChannelInboundHandlerAdapter]--&gt;c[ChannelInboundHandler]
</span></span><span class=line><span class=cl>	a--&gt;d[ChannelHandlerAdapter]
</span></span><span class=line><span class=cl>	b--&gt;d
</span></span><span class=line><span class=cl>	b[ChannelOutboundHandlerAdapter]--&gt;b1[ChannelOutboundHandler]
</span></span><span class=line><span class=cl>	d--&gt;z[ChannelHandler]
</span></span><span class=line><span class=cl>	b1--&gt;z
</span></span><span class=line><span class=cl>	c--&gt;z
</span></span><span class=line><span class=cl>	
</span></span></code></pre></td></tr></table></div></div><h4 id=channelpipeline接口>ChannelPipeline接口</h4><blockquote><p>ChannelPipeline是一个拦截流经Channel的入站和出站事件的ChannelHandler实例链。</p></blockquote><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231156625241723115661886.png><p>ChannelPipeline的头部和尾部取决于该事件是入站还是出站的。Netty总是将ChannelPipeline的入站口作为头部，将出站口作为尾部。</p><ul><li>修改ChannelPipeline</li></ul><div class=table-wrapper><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>addFirstaddBefore \n addAfteraddLast</td><td>将一个ChannelHandler添加到ChannelPipeline中</td></tr><tr><td>remove</td><td>将一个ChannelHandler从ChannelPipeline中移除</td></tr><tr><td>replace</td><td>将ChannelPipeline中的一个ChannelHandler替换为另一个ChannelHandler</td></tr></tbody></table></div><blockquote><p>下面举例中每个Handler应为不同的Handler，这里为了方便全部使用相同的了。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>ChangeChannelPipeline</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>change</span><span class=p>(</span><span class=n>ChannelPipeline</span><span class=w> </span><span class=n>pipeline</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>C1FirstHandler</span><span class=w> </span><span class=n>c1FirstHandler</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>C1FirstHandler</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        尾插第一个Handler名为handler1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>addLast</span><span class=p>(</span><span class=s>&#34;handler1&#34;</span><span class=p>,</span><span class=n>c1FirstHandler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        头插一个Handler名为handler2</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>addFirst</span><span class=p>(</span><span class=s>&#34;handler2&#34;</span><span class=p>,</span><span class=n>c1FirstHandler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        尾插</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>addLast</span><span class=p>(</span><span class=s>&#34;handler3&#34;</span><span class=p>,</span><span class=n>c1FirstHandler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        按名字删除Handler</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=s>&#34;handler3&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        按照Handler类型来删除</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>c1FirstHandler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        把名为handler2的替换</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>replace</span><span class=p>(</span><span class=s>&#34;handler2&#34;</span><span class=p>,</span><span class=s>&#34;handler4&#34;</span><span class=p>,</span><span class=n>c1FirstHandler</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=总结-1>总结</h5><ul><li>ChannelPipeline保存了与Channel相关联的ChannelHandler</li><li>ChannelPipeline可以根据需要，通过添加或者删除ChannelHandler来动态地修改</li><li>ChannelPipeline有丰富的API可以响应入站和出站事件。</li></ul><h4 id=channelhandlercontext接口>ChannelHandlerContext接口</h4><blockquote><p>管理它所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</p></blockquote><ul><li>ChannelHandlerContext和ChannelHandler之间的关联是永远不会改变的，所以缓存对它的引用是安全的。</li><li>ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来提高性能。</li></ul><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231181995261723118199395.png><ul><li>通过ChannelHandlerContext访问Handler和Pipeline</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>DemoChannelHandlerContext</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    通过ChannelHandlerContext访问Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>getChannel</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        获取与ChannelHandlerContext关联的Channel</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ctx</span><span class=p>.</span><span class=na>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        向Channel中写入数据</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>channel</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;Netty in Action&#34;</span><span class=p>,</span><span class=w> </span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    通过ChannelHandlerContext访问Pipeline</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>getChannelPipeline</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        获取Pipeline</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ChannelPipeline</span><span class=w> </span><span class=n>pipeline</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ctx</span><span class=p>.</span><span class=na>pipeline</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        通过Pipeline写入缓冲区</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pipeline</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=n>Unpooled</span><span class=p>.</span><span class=na>copiedBuffer</span><span class=p>(</span><span class=s>&#34;Netty in Action&#34;</span><span class=p>,</span><span class=n>CharsetUtil</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=一个事件是如何传递的>一个事件是如何传递的</h5><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231187695351723118769210.png><h4 id=异常处理>异常处理</h4><blockquote><p>入站异常</p></blockquote><ul><li>ChannelHandler..exceptionCaught()默认实现是将当前异常转发给ChannelPipeline中的下一个ChannelHandler</li><li>如果异常到达了ChannelPipeline的尾端，它将会被记录为未被处理</li><li>若想自定义异常处理，需要重写exceptionCaught()方法。然后决定是否将该异常传播出去</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//自定义处理入站异常</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>P6InboundExceptionHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ChannelInboundHandlerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    重写exceptionCaught方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>exceptionCaught</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Throwable</span><span class=w> </span><span class=n>cause</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>cause</span><span class=p>.</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ctx</span><span class=p>.</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>出站异常</p></blockquote><ul><li>每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener将在操作完成时被通知该操作是成功还是失败。</li><li>几乎所有的ChannelOutboundHandler上的方法都会被传入一个ChannelPromise实例。作为ChannelFuture的子类，ChannelPromise也可以被分配用于异步通知的监听器。（也可以立即通知）</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//自定义出站规则异常处理</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>P6OutboundExceptionHandler</span><span class=w> </span><span class=kd>extends</span><span class=w> </span><span class=n>ChannelOutboundHandlerAdapter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    将结果的监听器交给operationComplete</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>write</span><span class=p>(</span><span class=n>ChannelHandlerContext</span><span class=w> </span><span class=n>ctx</span><span class=p>,</span><span class=w> </span><span class=n>Object</span><span class=w> </span><span class=n>msg</span><span class=p>,</span><span class=w> </span><span class=n>ChannelPromise</span><span class=w> </span><span class=n>promise</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>promise</span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelFutureListener</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>operationComplete</span><span class=p>(</span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>future</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>future</span><span class=p>.</span><span class=na>isSuccess</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>cause</span><span class=p>().</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>closeFuture</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//    通过将监听器交给Future，两种方法效果相同</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>byChannelFuture</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>channel</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>future</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>channel</span><span class=p>.</span><span class=na>write</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Object</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>future</span><span class=p>.</span><span class=na>addListener</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>ChannelFutureListener</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>operationComplete</span><span class=p>(</span><span class=n>ChannelFuture</span><span class=w> </span><span class=n>future</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>Exception</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>future</span><span class=p>.</span><span class=na>isSuccess</span><span class=p>()){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>cause</span><span class=p>().</span><span class=na>printStackTrace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>close</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>future</span><span class=p>.</span><span class=na>channel</span><span class=p>().</span><span class=na>closeFuture</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=第七章eventloop和线程模型>第七章、EventLoop和线程模型</h3><ul><li>java5的线程池化技术</li></ul><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231877659461723187765894.png><ul><li>存在的问题</li></ul><p>虽然可以重用线程，但是并不能消除由上下文切换带来的开销。性能影响将随着线程数量的增加变得明显，且在高负载下愈演愈烈。</p><h4 id=eventloop接口>EventLoop接口</h4><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231933815271723193380788.png><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph TD
</span></span><span class=line><span class=cl>	a[io.netty.channel]
</span></span><span class=line><span class=cl>	a1[ThreadPerChannelEventLoop]--&gt;a2[SingleThreadEventLoop]
</span></span><span class=line><span class=cl>	a2--&gt;a3[EventLoop]
</span></span><span class=line><span class=cl>	a3--&gt;a4[EventLoopGroup]
</span></span><span class=line><span class=cl>	b[io.netty.util.concurrent]
</span></span><span class=line><span class=cl>	b1[SingleThreadEventExecutor]--&gt;b2[AbstractEventExecutor]
</span></span><span class=line><span class=cl>	b2--&gt;b3[EventExecutor]
</span></span><span class=line><span class=cl>	b3--&gt;b4[EventExecutorGroup]
</span></span><span class=line><span class=cl>	a2--&gt;b1
</span></span><span class=line><span class=cl>	a3--&gt;b3
</span></span><span class=line><span class=cl>	a4--&gt;b4
</span></span><span class=line><span class=cl>	c[java.util.concurrent]
</span></span><span class=line><span class=cl>	b2--&gt;c1[AbstractExecutorService]
</span></span><span class=line><span class=cl>	b4--&gt;c2[ScheduledExecutorService]
</span></span><span class=line><span class=cl>	c1--&gt;c3[ExecutorService]
</span></span><span class=line><span class=cl>	c2--&gt;c3
</span></span><span class=line><span class=cl>	c3--&gt;c4[Executor]
</span></span></code></pre></td></tr></table></div></div><p>一个EventLoop将由一个永远不会改变的Thread驱动，同时任务（Runnable或者Callable）可以直接提交给EventLoop实现，以立即执行或者调度执行。</p><ul><li>Netty4中的IO事件处理</li></ul><p>I/O 操作触发的事件将流经安装了一个或者多个 ChannelHandler 的 ChannelPipeline。传播这些事件的方法调用可以随后被Channel- Handler 所拦截，并且可以按需地处理事件。</p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/17231187695351723118769210.png><ul><li>Netty3中的IO操作</li></ul><p>入站事件会在IO线程中执行，所有的出站事件由调用线程处理。（需要额外的线程，导致上下文切换带来损耗）。</p><h4 id=任务调度>任务调度</h4><ul><li>JDK的任务调度</li></ul><p>jdk提供了JUC包，可以定义一个任务调度线程池</p><p>存在的弊端：需要多个线程，存在上下文切换问题</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//    jdk是如何做任务调度的</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>jdkC</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建一个任务线程池</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ScheduledExecutorService</span><span class=w> </span><span class=n>executor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Executors</span><span class=p>.</span><span class=na>newScheduledThreadPool</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        每60秒执行一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>schedule</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;60 seconds later&#34;</span><span class=p>),</span><span class=n>60</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        关闭线程池</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>executor</span><span class=p>.</span><span class=na>shutdown</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>EventLoop任务调度</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//    利用EventLoop停止一个任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>EventLoopC</span><span class=p>(</span><span class=n>Channel</span><span class=w> </span><span class=n>ch</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        通过EventLoop创建一个任务调度，60s后开始，每60s执行一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>ScheduledFuture</span><span class=o>&lt;?&gt;</span><span class=w> </span><span class=n>future</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ch</span><span class=p>.</span><span class=na>eventLoop</span><span class=p>().</span><span class=na>scheduleAtFixedRate</span><span class=p>(()</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;60s seconds later&#34;</span><span class=p>),</span><span class=w> </span><span class=n>60</span><span class=p>,</span><span class=n>60</span><span class=p>,</span><span class=w> </span><span class=n>TimeUnit</span><span class=p>.</span><span class=na>SECONDS</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        创建一个停止任务的表示</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=w> </span><span class=n>mayInterruptIfRunning</span><span class=o>=</span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//        取消任务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>future</span><span class=p>.</span><span class=na>cancel</span><span class=p>(</span><span class=n>mayInterruptIfRunning</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>EventLoop的优势</li></ul><p>Netty的EventLoop扩展了ScheduledExecutorService，它实现了JDK可用的所有方法。</p><h4 id=实现细节>实现细节</h4><ul><li>线程管理</li></ul><p>Netty线程模型的卓越取决于对于当前Thread的确定。可以确定它是分配给当前Channel以及它的EventLoop的哪个线程。</p><p>如果（当前）调用线程正是支撑EventLoop的线程，那么所提交的代码块将会被（直接）执行。否则EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中。当EventLoop下次处理它的事件时，它会执行队列中的那些任务。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/66f61fa9ee54e_1747188214067.png loading=lazy alt=66f61fa9ee54e.png></p><blockquote><p>永远不要将一个长时间运行的任务放入到执行队列中，因为它将阻塞需要在同一线程上执行的任何其他任务。如果需要执行长时间运行的任务，建议新建一个专门的EventExecutor</p></blockquote><ul><li>EventLoop/线程的分配</li></ul><p>EventLoop包含在EventLoopGroup中，根据不同的传输实现，EventLoop的创建和分配方式不同。</p><ol><li>异步传输</li></ol><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/66f621bd511f9_1747188389323.png loading=lazy alt=66f621bd511f9.png></p><p>EventLoopGroup负责为每个新创建的Channel分配一个EventLoop。使用轮询的方式进行分配以获取一个均衡的分布，相同的EventLoop可能会被分配给多个Channel。</p><p>一旦一个Channel被分配给了一个EventLoop，它将在它的整个生命周期中都使用这个EventLoop（以及相关的Thread）。</p><blockquote><p>因为一个EventLoop支撑了多个Channel，所以对于所有相关的Channel来说，ThreadLocal都是相同的。</p></blockquote><ol start=2><li>阻塞传输</li></ol><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/6704cdd404a5a_1747188395147.png loading=lazy alt=6704cdd404a5a.png></p><p>每个Channel的事件都由一个Thread处理</p><h4 id=总结-2>总结</h4><ul><li>netty线程模型的伸缩性：</li></ul><blockquote><p>可伸缩性就是可以通过增加计算资源(CPU，内存)来提供程序的吞吐量或者性能。</p></blockquote><p>由于netty的EventLoop都绑定着一个确定的Thread，所以，可以根据EventLoop的数量来调整cpu核心数量。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/netty/>Netty</a>
<a href=/tags/java/>Java</a>
<a href=/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/>读后感</a>
<a href=/tags/rpc/>Rpc</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/nettyio%E6%A8%A1%E5%9E%8B/><div class=article-image><img src=/p/nettyio%E6%A8%A1%E5%9E%8B/20205-05-29.332e46be036aa4d6e58c13a2bf201374_hu_2cc0139b4e7ec47e.png width=250 height=150 loading=lazy alt="Featured image of post NettyIO模型" data-hash="md5-My5GvgNqpNbljBOivyATdA=="></div><div class=article-details><h2 class=article-title>NettyIO模型</h2></div></a></article><article class=has-image><a href=/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAv3.7a938c68cb8d638aedb4ae81627b8f0b_hu_9bb77bf9d1481dbf.png width=250 height=150 loading=lazy alt="Featured image of post 读《深入理解java虚拟机2019版》有感" data-hash="md5-epOMaMuNY4rttK6BYnuPCw=="></div><div class=article-details><h2 class=article-title>读《深入理解java虚拟机2019版》有感</h2></div></a></article><article class=has-image><a href=/p/spring%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3v6%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/spring%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3v6%E6%9C%89%E6%84%9F/springFrameworkV6.45c4949ea90685e7afd2cf20ba4c38ce_hu_f0359f2a328cfc6b.png width=250 height=150 loading=lazy alt="Featured image of post spring中文说明文档v6有感" data-hash="md5-RcSUnqkGheev0s8gukw4zg=="></div><div class=article-details><h2 class=article-title>spring中文说明文档v6有感</h2></div></a></article><article class=has-image><a href=/p/java-ontwerp-patroon/><div class=article-image><img src=/p/java-ontwerp-patroon/1.81a9dce623b1d6fe4485ac670cb7da98_hu_10158e7e9c50ff2e.png width=250 height=150 loading=lazy alt="Featured image of post 读《重学java设计模式》有感" data-key=java-Ontwerp-patroon data-hash="md5-ganc5iOx1v5EhaxnDLfamA=="></div><div class=article-details><h2 class=article-title>读《重学java设计模式》有感</h2></div></a></article><article class=has-image><a href=/p/icyfenix-hoeksteen/><div class=article-image><img src=/p/icyfenix-hoeksteen/1.9ce725d0528cc3b0d5321b62181de3a9_hu_fa570a2a13ed75d3.png width=250 height=150 loading=lazy alt="Featured image of post 读《凤凰架构》有感--分布式基石" data-key=icyfenix-Hoeksteen data-hash="md5-nOcl0FKMw7DVMhtiGB3jqQ=="></div><div class=article-details><h2 class=article-title>读《凤凰架构》有感--分布式基石</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//thecoolboyhan.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 韩永发的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>