<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="补档之前redis"><title>redis5之前</title><link rel=canonical href=https://thecoolboyhan.github.io/p/redis5%E4%B9%8B%E5%89%8D/><link rel=stylesheet href=/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css><meta property='og:title' content="redis5之前"><meta property='og:description' content="补档之前redis"><meta property='og:url' content='https://thecoolboyhan.github.io/p/redis5%E4%B9%8B%E5%89%8D/'><meta property='og:site_name' content='韩永发的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='redis'><meta property='article:tag' content='book'><meta property='article:tag' content='读后感'><meta property='article:tag' content='缓存'><meta property='article:published_time' content='2023-10-03T00:00:00+00:00'><meta property='article:modified_time' content='2023-10-03T00:00:00+00:00'><meta property='og:image' content='https://thecoolboyhan.github.io/p/redis5%E4%B9%8B%E5%89%8D/1.png'><meta name=twitter:title content="redis5之前"><meta name=twitter:description content="补档之前redis"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://thecoolboyhan.github.io/p/redis5%E4%B9%8B%E5%89%8D/1.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_3d339d0f8c590cc9.png width=300 height=400 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>韩永发的博客</a></h1><h2 class=site-description>目前人在上海，20年毕业，普通muggle，java开发。邮箱：hanyongfa2013@163.com 。</h2></div></header><ol class=menu-social><li><a href=https://github.com/thecoolboyhan target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://leetcode.cn/u/thecoolboy/ target=_blank title=力扣 rel=me><svg role="img" viewBox="0 0 24 24"><title>LeetCode</title><path d="M13.483.0a1.374 1.374.0 00-.961.438L7.116 6.226l-3.854 4.126a5.266 5.266.0 00-1.209 2.104 5.35 5.35.0 00-.125.513 5.527 5.527.0 00.062 2.362 5.83 5.83.0 00.349 1.017 5.938 5.938.0 001.271 1.818l4.277 4.193.039.038c2.248 2.165 5.852 2.133 8.063-.074l2.396-2.392c.54-.54.54-1.414.003-1.955a1.378 1.378.0 00-1.951-.003l-2.396 2.392a3.021 3.021.0 01-4.205.038l-.02-.019-4.276-4.193c-.652-.64-.972-1.469-.948-2.263a2.68 2.68.0 01.066-.523 2.545 2.545.0 01.619-1.164L9.13 8.114c1.058-1.134 3.204-1.27 4.43-.278l3.501 2.831c.593.48 1.461.387 1.94-.207a1.384 1.384.0 00-.207-1.943l-3.5-2.831c-.8-.647-1.766-1.045-2.774-1.202l2.015-2.158A1.384 1.384.0 0013.483.0zm-2.866 12.815a1.38 1.38.0 00-1.38 1.382 1.38 1.38.0 001.38 1.382H20.79a1.38 1.38.0 001.38-1.382 1.38 1.38.0 00-1.38-1.382z"/></svg></a></li><li><a href=mailto:hanyongfa2013@163.com target=_blank title=邮箱 rel=me><svg id="mdi-email-arrow-right-outline" viewBox="0 0 24 24"><path d="M13 19C13 18.66 13.04 18.33 13.09 18H4V8l8 5 8-5v5.09C20.72 13.21 21.39 13.46 22 13.81V6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18c0 1.1.9 2 2 2h9.09C13.04 19.67 13 19.34 13 19M20 6l-8 5L4 6H20m0 16V20H16V18h4V16l3 3-3 3z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#拉钩的redis>拉钩的redis</a><ol><li><a href=#数据结构>数据结构</a><ol><li><a href=#基本数据类型>基本数据类型</a></li><li><a href=#redisdb结构>redisDB结构</a></li><li><a href=#redis的7种type>redis的7种type</a></li></ol></li><li><a href=#过期和淘汰策略>过期和淘汰策略</a></li></ol></li><li><a href=#redis高可用方案>redis高可用方案</a><ol><li><a href=#主从同步>主从同步</a></li><li><a href=#哨兵模式>哨兵模式</a><ol><li><a href=#故障转移>故障转移</a></li></ol></li><li><a href=#集群与分区>集群与分区</a><ol><li><a href=#客户端分区>客户端分区</a></li><li><a href=#proxy端分区>proxy端分区</a></li><li><a href=#官方cluster分区>官方cluster分区</a></li></ol></li><li><a href=#容灾>容灾</a></li></ol></li><li><a href=#企业实战>企业实战</a><ol><li><a href=#缓存问题>缓存问题</a><ol><li><a href=#缓存穿透>缓存穿透</a></li><li><a href=#缓存雪崩>缓存雪崩</a></li><li><a href=#缓存击穿>缓存击穿</a></li><li><a href=#数据不一致>数据不一致</a></li><li><a href=#hot-key>Hot Key</a></li><li><a href=#big-key>Big Key</a></li></ol></li><li><a href=#分布式锁>分布式锁</a><ol><li><a href=#利用watch实现redis乐观锁>利用Watch实现redis乐观锁</a></li><li><a href=#实现方式>实现方式</a></li><li><a href=#存在的问题>存在的问题</a></li></ol></li></ol></li><li><a href=#大厂面试提>大厂面试提</a><ol><li><a href=#缓存雪崩缓存穿透缓存击穿>缓存雪崩，缓存穿透，缓存击穿</a></li><li><a href=#数据一致性问题>数据一致性问题</a></li><li><a href=#redis为什么这么快>redis为什么这么快</a></li><li><a href=#如何在多个核心的cpu上利用redis的性能>如何在多个核心的CPU上利用redis的性能</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/redis5%E4%B9%8B%E5%89%8D/><img src=/p/redis5%E4%B9%8B%E5%89%8D/1_hu_4fa83cf3a42bf5c5.png srcset="/p/redis5%E4%B9%8B%E5%89%8D/1_hu_4fa83cf3a42bf5c5.png 800w, /p/redis5%E4%B9%8B%E5%89%8D/1_hu_b933fed1455242e0.png 1600w" width=800 height=533 loading=lazy alt="Featured image of post redis5之前"></a></div><div class=article-details><header class=article-category><a href=/categories/%E7%B2%BE%E9%80%89/>精选
</a><a href=/categories/%E7%BC%93%E5%AD%98/>缓存</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/redis5%E4%B9%8B%E5%89%8D/>redis5之前</a></h2><h3 class=article-subtitle>补档之前redis</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Oct 03, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 18 分钟</time></div></footer></div></header><section class=article-content><h2 id=拉钩的redis>拉钩的redis</h2><h3 id=数据结构>数据结构</h3><h4 id=基本数据类型>基本数据类型</h4><ul><li><p>string字符串</p></li><li><p>list</p></li><li><p>set集合</p></li><li><p>sortedset有序集合</p></li><li><p>hash类型（散列表）</p></li><li><p>bitmap位图类型</p></li><li><p>geo地理位置类型</p></li><li><p>stream数据流类型</p></li></ul><h4 id=redisdb结构>redisDB结构</h4><p>redis会在初始化时，会预先分配16个数据库</p><ul><li>redisDB的具体结构：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>redisDb</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>id</span><span class=p>;</span>      <span class=c1>//id数据库序号，为0-15（默认redis有16个数据库）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=n>avg_ttl</span><span class=p>;</span><span class=c1>//存储数据库对象的平均ttl（time to live），用于统计
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>dict</span><span class=p>;</span><span class=c1>//存储所有的key-value
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>blocking_keys</span><span class=p>;</span><span class=c1>//blpop存储阻塞key和客户端对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>ready_keys</span><span class=p>;</span><span class=c1>//阻塞后push响应阻塞客户端，存储阻塞后push的key和客户端对象
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>wathced_keys</span><span class=p>;</span><span class=c1>//存储watch监控的key和客户端对象
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=redis的7种type>redis的7种type</h4><h5 id=字符串-sds>字符串 SDS</h5><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-412:55:27-1693803326815.png loading=lazy></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sdshdr</span><span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=c1>//记录buf数据中已使用字节的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//记录buf数组中未使用字节的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//字符数组，用于保存字符串
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>优势：</p><ol><li>通过len和free可以用O（1）的时间复杂度来获取字符串的长度（c语言是O(n)）</li><li>因为已经记录了长度，所以可以在可能会发生缓冲区溢出时自动重新分配内存。</li></ol><h5 id=跳跃表重点>跳跃表（重点)</h5><p>跳跃表是有序集合（sorted-set）的底层实现，效率高，实现简单。</p><ul><li>思想：</li></ul><blockquote><p>将有序链表中的部分节点分层，每层都是一个有序链表。</p></blockquote><ul><li>查找：</li></ul><p>优先从最高层开始向后查找，当到达某个节点时，如果next节点值大于要查找的值或next指针指向null，则从当前节点下降一层继续向后查找。</p><p>举例：</p><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-512:17:01-1693887420857.png loading=lazy></p><blockquote><p>类似于2分查找</p></blockquote><ul><li>插入和删除：</li></ul><p>先从最下层开始构建，除开始和结束节点，每向上一层，都要有1/2的几率解决是否构建当前元素。</p><p>删除：</p><p>在每一层都找到指定元素，删除需要删除的元素。</p><ul><li>跳表的特点：</li></ul><ol><li>每层都是一个有序链表</li><li>查找次数近似于层数的1/2</li><li>最底层包含所有元素</li><li>空间复杂度O(n)扩充了一倍</li></ol><ul><li>Redis的跳表实现：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zskiplistNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sds</span> <span class=n>ele</span><span class=p>;</span><span class=c1>//存储字符串类型数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>score</span><span class=p>;</span><span class=c1>//存储排序的分值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>backward</span><span class=p>;</span><span class=c1>//后退指针，指向当前节点最底层的前一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//层，柔性数组，随机生成1-64的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>zskiplistLevel</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>forward</span><span class=p>;</span><span class=c1>//指向本层下一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>span</span><span class=p>;</span><span class=c1>//本层下一个节点到本层的元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>level</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>zskiplistNode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//链表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zskiplist</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//表头节点和为节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>zskiplistNode</span> <span class=o>*</span><span class=n>header</span><span class=p>,</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//表中节点的数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//表中层数最大的节点的层数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>level</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>zskiplist</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>结构示意图：</p><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-512:30:46-1693888245130.png loading=lazy></p><h5 id=字典重点难点>字典（重点+难点）</h5><p>字典dict又称散列表（hash），用来存储键值对的一种数据结构。</p><p>Redis整个数据库是用字典来存储的。</p><p>对redis进行curd其实就是对字典数据进行curd。</p><ul><li>数组：数据量少时，使用数组加偏移量的方式来存储对象，可以O(1）时间复杂度来获取对象。</li></ul><p>如果数据变多时，还是需要使用到hash表</p><ul><li>hash：</li></ul><p>redis解决hash冲突时，采用拉链法来处理。</p><p>情况类似于java的hashmap（没有树化）</p><ul><li>渐进式rehash</li></ul><p>扩容时需要rehash，但当数据特别大时，rehash是一个非常缓慢的过程，所以需要进行优化。</p><p>服务器忙，则只对一个节点进行rehash。</p><p>服务器闲，可批量rehash（100个节点）</p><p>字典的应用场景：</p><ol><li>数据库存储数据</li><li>散列表对象</li><li>哨兵模式的主从节点管理</li></ol><h5 id=压缩列表>压缩列表</h5><blockquote><p>由一系列特殊编码的连续内存块组成的顺序型数据结构。</p></blockquote><ul><li>结构：</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-613:26:19-1693977978141.png loading=lazy></p><p>zibytes:压缩列表的字节长度</p><p>zltail：压缩列表的尾元素相对于起始地址的偏移量</p><p>zlien：压缩列表的元素个数</p><p>entry1..entryx：压缩列表的各个节点</p><p>zlend：压缩列表的结尾，占一个字节，恒为0xFF（255）</p><ul><li>entry的编码结构：</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-614:13:54-1693980833194.png loading=lazy></p><p>previous_entry_length：前一个元素的字节长度</p><p>encoding：表示当前元素的编码</p><p>content：数据内容</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>zlentry</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>prevrawlensize</span><span class=p>;</span>  <span class=c1>//previous_entry_length字段的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>prevrawlen</span><span class=p>;</span>	<span class=c1>//previous_entry_length字段存储的内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>lensize</span><span class=p>;</span>		<span class=c1>//encoding字段的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>			<span class=c1>//数据内容长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>headersize</span><span class=p>;</span>	<span class=c1>//当前元素的首部长度，即previous_entry_length字段长度与encoding字段长度之和。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>encoding</span><span class=p>;</span>		<span class=c1>//数据类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>			<span class=c1>//当前元素首地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>zlentry</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>应用场景：</li></ul><p>sroted-set和hash元素个数少且是小整数或短字符串（直接使用）</p><p>list用快速链表（quicklist）数据结构存储，而快速链表是双向列表和压缩列表的组合（间接使用）</p><h5 id=整数集合intset>整数集合（intset)</h5><blockquote><p>有序的（整数升序），存储整数的连续存储结构。</p></blockquote><p>当Redis集合类型的元素都是整数并且都处在64位有效符号整数范围内，就使用该结构存储。</p><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-1516:11:05-1694765465742.png loading=lazy alt=2023-9-1516:11:05-1694765465742.png></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>intset</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint32_t</span> <span class=n>encoding</span><span class=p>;</span>	<span class=c1>//编码方式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>length</span><span class=p>;</span>	<span class=c1>//集合包含的元素数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int8_t</span> <span class=n>contents</span><span class=p>[];</span>	<span class=c1>//保存元素的数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>应用场景：</li></ul><p>可以存储整数值，并且保证集合中不会出现重复元素。</p><h5 id=快速列表重点>快速列表（重点）</h5><blockquote><p>快速列表（quicklist）是Redis底层重要的数据结构。是列表的底层实现。（Redis 3.2之前，Redis采用双向链表和压缩列表实现）。在Redis 3.2 之后，结合双向链表和压缩列表的优点，设计出了qucklist。</p></blockquote><p>快速列表是一个双向链表，链表中的每个节点是一个压缩列表结构。每个节点的压缩列表都可以存储多个数据元素。</p><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-9-1516:26:51-1694766411320.png loading=lazy alt=2023-9-1516:26:51-1694766411320.png></p><ul><li>数据结构：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>quicklist</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>		<span class=c1>//指向quicklist的头部
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>		<span class=c1>//指向quicklist的尾部
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>count</span><span class=p>;</span>		<span class=c1>//列表中所有元素项个数的总和
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>len</span><span class=p>;</span>			<span class=c1>//quicklist节点的个数，即ziplist的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nl>fill</span> <span class=p>:</span> <span class=mi>16</span><span class=p>;</span>				<span class=c1>//ziplist大小限定，由list-max-ziplist-size 给定（Redis设定）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>compress</span><span class=p>:</span> <span class=mi>16</span><span class=p>;</span> <span class=c1>//节点压缩深度设置，由list-compress-depth给定（redis设定）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>quicklist</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=n>struck</span> <span class=n>quicklistNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>	<span class=c1>//指向上一个ziplist节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>	<span class=c1>//指向下一个ziplist节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zl</span><span class=p>;</span>			<span class=c1>//数据指针，如果没有被压缩，就指向ziplist结构，反之指向qucklistLZF结构。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span>			<span class=c1>//指向ziplist结构的总长度（内存占用长度）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>count</span> <span class=p>:</span> <span class=mi>16</span><span class=p>;</span>	<span class=c1>//表示ziplist中数据项个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>encoding</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span>	<span class=c1>//编码方式，1--ziplist，2--quicklistLZF
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>container</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span>	<span class=c1>//预留字段，存放数据的方式，1--NONE，2--ziplist
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>recompress</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span><span class=c1>//解压标记，当查看一个被压缩的数据时，需要暂时解压缩，标记此参数为1之后再重新进行压缩。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>attempted_compress</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span>	<span class=c1>//测试相关
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>extra</span> <span class=p>:</span> <span class=mi>10</span><span class=p>;</span>	<span class=c1>//扩展字段，暂时没用
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>quicklistNode</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>数据压缩</li></ul><p>quicklist每个节点的实际数据存储结构为ziplist，这种结构的优势在于节省存储空间。为了进一步降低ziplist的存储空间。还可以对ziplist进行压缩。Redis采用的压缩算法是LZF。其基本思想是：数据与前面重复的记录重复位置及长度。不重复的记录原始数据。</p><blockquote><p>压缩过后的数据可以分成多个片段，每个片段有两个部分，</p></blockquote><h3 id=过期和淘汰策略>过期和淘汰策略</h3><ul><li><p>maxmemory</p><p>redis服务器物理内存的最大值，如果达到maxmemory设定的值，通过缓存淘汰策略，从内存中删除对象</p></li><li><p>删除策略</p></li></ul><blockquote><p>redis默认采用惰性删除+主动删除的方式。</p></blockquote><ul><li>定时删除</li></ul><p>在设置key的同时，创建一个定时器，让定时器在key的过期时间来临时，立刻执行对key删除操作。</p><p>需要创建定时器，而且消耗CPU，一般不推荐。</p><ul><li>惰性删除</li></ul><p>在key被访问时，如果发现他已经失效，那么就删除它。</p><p>调用expirelfNeeded函数，该函数的意义是：读取数据之前先检查它有没有失效，如果失效了就删除它。</p><p>代码实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>expireIfNeeded</span><span class=p>(</span><span class=n>redisDb</span> <span class=o>*</span><span class=n>db</span><span class=p>,</span> <span class=n>robj</span> <span class=o>*</span><span class=n>key</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=c1>//获取主键的失效时间， get当前时间-创建时间&gt;ttl
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=kt>long</span> <span class=n>when</span> <span class=o>=</span> <span class=nf>getExpire</span><span class=p>(</span><span class=n>db</span><span class=p>,</span><span class=n>key</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//假如失效时间为负数，说明该主键未设置失效时间（失效时间默认为-1）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=redis高可用方案>redis高可用方案</h2><h3 id=主从同步>主从同步</h3><ul><li>redis2.8之前</li></ul><ol><li><p>从服务器发送SYNC命令给主服务器</p></li><li><p>主服务器生成RDB文件给从服务器，同时发送所有写命令给从服务器</p></li><li><p>从服务器清空之前的数据，读取RDB文件</p></li><li><p>通过命令传播的形式保持数据一致性</p></li></ol><blockquote><p>如果同步过程中断掉，主服务器重新生成RDB文件和mast命令给从服务器，从服务器重新恢复</p></blockquote><ul><li>redis 2.8之后</li></ul><ol><li>redis主从同步，分为全量同步和增量同步</li><li>从服务器第一次连接上主机是全量同步</li><li>断线重连可能触发全量同步也可能是增量同步</li><li>除此之外的情况都是增量同步</li></ol><h3 id=哨兵模式>哨兵模式</h3><p>Sentinel是一个特殊的Redis服务器</p><p>不会进行持久化</p><p>每个Sentinel启动后，会创建两个连向主服务器的网络连接</p><p>命令连接：用于向主服务器发送命令，并接收相应</p><p>订阅连接：用于订阅主服务器的&ndash;Sentinel&mdash;-Hello频道</p><p>Sentinel默认每十秒向主服务器发送info命令获取redis的信息</p><blockquote><p>Sentinel之间只创建命令连接，不创建订阅连接，因为Sentinel在通过订阅主服务器或者从服务器，就可以感知到新的Sentinel的加入。</p></blockquote><ul><li>检测主观下线状态</li></ul><p>如果一个哨兵检测到主服务器没在down-after-milliseconds未响应</p><p>哨兵就认为该实例主观下线</p><p>向其他哨兵发送消息确认是否主观下线</p><p>当哨兵集群的选举数半数以上，该主就客观下线</p><h4 id=故障转移>故障转移</h4><ul><li>哨兵leader选举</li></ul><blockquote><p>当一个主服务器被判断为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法（raft），选出一个Leader 哨兵去执行故障转移操作</p></blockquote><ul><li>Raft</li></ul><p>Raft一般有三种身份，主，跟随者，候选人。</p><p>Raft协议将时间分为一个一个任期（term），可以认为是一种逻辑时间</p><p>选举流程：</p><p>Raft采用心跳检测触发Leader选举</p><p>系统启动后，全部节点初始化为跟随者。term为0</p><p>节点如果接收到了请求投票命令或者附录命令，就会保持自己的跟随者身份</p><p>节点如果一段时间内没有收到附录消息，在该节点的超时时间内还没有发现Leader，跟随者会自动转换为候选人，开始竞选leader</p><ul><li>竞选：</li></ul><ol><li>增加自己的term</li><li>启动新的定时器</li><li>给自己投一票（每个节点只能投一票，候选人投给自己，跟随者投给收到的第一个发送投票命令的节点）</li><li>向 所有其他节点发送投票命令，并等待其他节点回复</li></ol><p>如果在计时超时前，节点收到多数节点的同意投票，就转换为Leader，同时向其他所有节点发送附录命令，告知自己成为Leader</p><ul><li>故障转移</li></ul><ol><li>把失效的主其中的一个从升级为新的主，并将原失效主和其他的从都改为复制新的主。</li><li>当客户端连接原失效主失败时，集群会给客户端返回新的master，让客户端重新连接新的master</li><li>主和从服务器切换后，原主和从的配置文件都会发生改变，也就是原主中会多一行复制新主服务器。</li></ol><h3 id=集群与分区>集群与分区</h3><h4 id=客户端分区>客户端分区</h4><ul><li>普通hash</li></ul><p>客户端在存放数据的时候先做一个hash计算，根据结果来决定存到哪台redis服务器上</p><p>优点：</p><p>存放的数据key可以是中文或者字符串</p><p>热点数据分布均匀，不会存在哪一台机器上key特别多的情况</p><p>缺点：</p><p>扩展成本高，添加新redis服务器的时候，所有的数据都需要重新hash计算</p><ul><li>一致性hash</li></ul><p>普通的hash是对主机数取模，而一致性hash是对2^32^取模。我们把2^32^想象成一个圆，就像钟表一样。</p><p>再把redis服务器的hash（ip）对2^32取模， 确定redis服务器在这个圆上的位置。</p><p>存入的数据经过hash%2^32^之后，在圆上确定一个位置，当前点向右的第一个服务器就是存放此key 的位置。</p><p>当有新的redis服务器添加时，取圆上的位置。</p><p>服务器数据只需要修改新服务器圆上位置向右的第一个服务器的数据重新hash即可。</p><p>优点：</p><p>添加或移除节点时，数据只需要进行部分的迁移，其他服务器保持不变。</p><ul><li>虚拟映射</li></ul><p>如果上述hash环之后，数据还是分布不均匀，可以在圆上取服务器节点的对角，来映射重排数据，使数据分布均匀。</p><p>缺点：</p><p>复杂度高</p><h4 id=proxy端分区>proxy端分区</h4><p>codis豌豆荚提供的redis分区管理工具，推特也有一个叫TwemProxy。</p><p>codis在redis的基础上做了一层包装，引入了槽的概念。代理提供redis的分区功能。</p><ul><li>缺点：</li></ul><p>redis更新后，proxy也要跟着维护</p><h4 id=官方cluster分区>官方cluster分区</h4><blockquote><p>redis-cluster把所有的物理节点映射到（0-26383）个slot上，基本上采用平均分配和连续分配的方式。</p></blockquote><p>添加一个新的节点时，会自动进行槽迁移，槽中的数据也会跟着移动。</p><p>cluster采用去中心化设计，每个主节点间都会互相通讯，就算客户端连接到错误的主节点，redis会转发到正确的节点。</p><h3 id=容灾>容灾</h3><ul><li>故障检测</li></ul><p>redis中每个节点都会给其他节点发送ping命令，如果一个节点ping另一个节点超时，他会给其他节点发送pfile命令，当有半数以上的节点都投出pfail票数后，则认为此节点故障。</p><ul><li>cluster失效的判断</li></ul><ol><li>集群中半数以上的主节点都宕机（无法投票）</li><li>宕机的主节点的从节点也宕机了（sloct槽分配不连续）</li></ol><ul><li>副本飘逸</li></ul><p>如果一个master宕机，它只有一个从节点，从节点成为新的主节点，它没有从节点，会从其他从节点最多的一个主机点那移动一个从节点成为自己的从节点。</p><h2 id=企业实战>企业实战</h2><h3 id=缓存问题>缓存问题</h3><h4 id=缓存穿透>缓存穿透</h4><blockquote><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查询（不如DB）。</p><p>缓存穿透是指在高并发下查询key不存在的数据（不存在的key），会穿过缓存查询数据库。导致数据库压力过大而宕机。</p></blockquote><p>解决方案：</p><ul><li><p>对查询结果为空的情况也设置缓存，缓存事件设置短一点，或者该key对应的数据insert了之后清除缓存。</p><p>问题：缓存太多空值，占用了更多空间</p></li><li><p>使用布隆过滤器，在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询key是否存在，如果不存在就直接返回，存在再查询缓存和DB。（一个大数组，对key多次不同hash计算，记录此key分别出现在数组哪个位置，来判断缓存和数据库中是否有此key）</p><p>如果数据库更新，布隆过滤器一定要添加</p></li></ul><h4 id=缓存雪崩>缓存雪崩</h4><blockquote><p>当缓存服务器重启或者大量缓存集中在某一时间段失效，这样在失效的时候，也会给后端系统带来很大的压力。（数据库崩溃）</p></blockquote><p>解决方案：</p><ol><li>key的失效期分散开，不同的key设置不同的有效期</li><li>设置二级缓存（数据库不一定一致）</li><li>高可用（脏读）</li></ol><h4 id=缓存击穿>缓存击穿</h4><p>对于一些设置了过期时间的key，如果这些key可能会在某些事件点被超高并发的访问，是一种非常“热点”的数据。这个时候需要考虑一个问题，缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。</p><blockquote><p>缓存的某个时间点过期的时候，恰好在这个时间点对这个key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的缓存可能会瞬间把DB压垮。</p></blockquote><p>解决方案：</p><ol><li><p>用分布式锁控制访问的线程</p><p>使用redis的setnx互斥锁进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去操作数据库</p></li><li><p>不设置超时时间，volatile-lru但会造成写一致问题</p><p>当数据库数据发生更新时，缓存中的数据不会及时更新，这样会造成数据库中的数据和缓存中的数据的不一致，应用会从缓存中读取到脏数据，可采用延时双删策略处理。</p></li></ol><h4 id=数据不一致>数据不一致</h4><ul><li>保持数据最终一致性（延时双删）</li></ul><ol><li>先更新数据库同时删除缓存项（Key），等读的时候再填充缓存。</li><li>2秒后再删除一次缓存项（key）</li><li>设置缓存过期时间比如十秒或者1小时</li><li>将缓存删除失败记录到日志中，利用脚本提取失败记录再次删除（缓存失效期过长7＊24）。</li></ol><p>升级方案</p><p>通过数据库的binlog来异步淘汰key，利用工具（canal）将binlog日志采集发送到mq中，然后通过ACK机制确认处理删除缓存</p><h4 id=hot-key>Hot Key</h4><blockquote><p>当有大量的请求访问某个Redis某个Key时，由于流量集中达到网络上限，从而导致这个redis的服务器宕机。造成缓存击穿，接下来对这个key的访问将直接访问数据库造成数据库崩溃，或者访问数据库回填Redis再访问redis，继续崩溃。</p></blockquote><ul><li>如何处理热Key：</li></ul><ol><li><p>变分布式缓存为本地缓存</p><p>发现热key之后，把缓存取出后，直接加载到本地缓存中，可以采用Ehcache、Guava Cache都可以，这样系统在访问热key数据时就可以直接访问自己的缓存了。（数据不要求实时一致）</p></li><li><p>在每个redis主节点上备份热Jey数据，这样可以在读取时采用随机读取的方式，将访问压力负载到每个redis上。</p></li><li><p>利用对热点数据的限流，熔断保护措施</p><p>每个系统实例每秒最多请求缓存集群读操作不超过400次，一超过就可以熔断掉，不让请求缓存集群，直接返回一个空白信息，然后用户稍后会自行再次重新刷新页面之类的。（首页不行，系统友好性差）</p><p>通过系统层自己直接加限流熔断保护措施，可以很好的保护后面的缓存集群。</p></li></ol><h4 id=big-key>Big Key</h4><p>大key指的是存储的值（Value）非常大，常见场景：</p><ul><li>热门话题下的讨论</li><li>大v的粉丝列表</li><li>序列化后的图片</li><li>没有及时处理的垃圾数据</li></ul><p>大Key 的影响：</p><ul><li>大key会大量占用内存，在集群中无法均衡</li><li>Redis的性能下降，主从复制异常</li><li>在主动删除或过期删除时会操作时间过长而引起服务阻塞</li></ul><p>如何发现大key：</p><ol><li><p>redis-cli &ndash;bigkeys命令。可以找到某个实例5种数据类型（String,hash,list,set,zset）的最大Key。</p><p>但如果redis的key比较多，执行该命令会比较慢。</p></li><li><p>获取生产redis的RDB文件，通过rdbtools分析rdb生成csv文件，在导入MySQL或其他数据库中进行分析统计，根据size_in_bytes统计bigKey。</p></li></ol><p>大key的处理：</p><ol><li><p>String 类型的big Key，尽量不要存入Redis中，可以使用文档型数据库MongoDB或缓存到CDN上。</p><p>如果必须redis存储，最好单独存储，不要和其他的key一起存储，采用一主一从或多从。</p></li><li><p>单个简单的key存储的value很大，可以尝试将对象分拆成几个key-value，使用mget获取值，这样分拆的意义在于分拆单次操作的压力，将单次操作压力平摊到多次操作中，降低对redis的IO影响。</p><p>hash、set、zset、list中存储过多的元素，可以将这些元素分拆（分页）。</p></li><li><p>删除大Key时 不要使用del，因为del是阻塞命令，删除时会影响性能。</p></li><li><p>使用lazy delete（unlink命令）undel</p><p>删除指定的key（s），若key不存在则该key被跳过。但是，相比DEl会会产生阻塞，该命令会在另一个线程中回收内存，应为它是非阻塞的。这也是该命令名字的由来，仅将keys从key空间中删除，真正的数据删除会在后续异步操作。</p></li></ol><h3 id=分布式锁>分布式锁</h3><blockquote><p>分布式锁是控制系统之间的同步访问共享资源的一种方式。</p><p>利用redis的单线程特性对共享资源进行串行化处理。</p></blockquote><h4 id=利用watch实现redis乐观锁>利用Watch实现redis乐观锁</h4><ol><li>利用redis的watch功能，监控这个rediskey 的状态值</li><li>获取rediskey的值</li><li>创建redis事务</li><li>给这个key的值+1</li><li>然后去执行 这个事务，如果key的值被修改过则回滚。</li></ol><h4 id=实现方式>实现方式</h4><ul><li>使用set命令实现</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>getLock</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>lockKey</span><span class=p>,</span><span class=n>String</span><span class=w> </span><span class=n>requestId</span><span class=p>,</span><span class=kt>int</span><span class=w> </span><span class=n>expireTime</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//setnx:查询是否有这个key存在，如果没有就设置成功，如果有就不能设置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//ex：过期时间，如果上面设置的key没有被当前线程手动删除，到达过期时间此key自动失效（删除）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>result</span><span class=o>=</span><span class=w> </span><span class=n>jedis</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>lockKey</span><span class=p>,</span><span class=n>requestId</span><span class=p>,</span><span class=s>&#34;NX&#34;</span><span class=p>,</span><span class=s>&#34;EX&#34;</span><span class=p>,</span><span class=n>expireTime</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=p>(</span><span class=s>&#34;OK&#34;</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>result</span><span class=p>)){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>释放锁：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>releaseLock</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>lockKey</span><span class=p>,</span><span class=n>String</span><span class=w> </span><span class=n>requestId</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=p>(</span><span class=n>requestId</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>jedis</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>lockKey</span><span class=p>))){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>jedis</span><span class=p>.</span><span class=na>del</span><span class=p>(</span><span class=n>lockKey</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人家的锁。比如客户端A加锁，一段时间后客户端A解锁，在执行jedis.del()之前，锁突然过期了，客户端B尝试加锁成功。然后客户端A在执行del方法，则将客户端B的锁解锁。</p></blockquote><ul><li>redis+lua脚本实现</li></ul><blockquote><p>因为lua脚本是原子性的，不存在拿到锁，再误删别人锁的情况。</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>releasLock</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>lockKey</span><span class=p>,</span><span class=n>String</span><span class=w> </span><span class=n>requestId</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>script</span><span class=o>=</span><span class=s>&#34;if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Object</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>jedis</span><span class=p>.</span><span class=na>eval</span><span class=p>(</span><span class=n>script</span><span class=p>,</span><span class=w> </span><span class=n>Collections</span><span class=p>.</span><span class=na>singletonList</span><span class=p>(</span><span class=n>lockKey</span><span class=p>),</span><span class=n>Collections</span><span class=p>.</span><span class=na>singletonList</span><span class=p>(</span><span class=n>requestId</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=na>equals</span><span class=p>(</span><span class=n>1L</span><span class=p>)){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=存在的问题>存在的问题</h4><p>无法保证强一致性，在主机宕机的情况下会造成锁的重复获取。</p><blockquote><p>A在主获得锁，setnx，此时还没有触发主从同步，redis主节点挂了，从变为主，b在新主节点上又获得锁，此时就有两个线程同时获得了同一把锁。</p></blockquote><ul><li>redLock</li></ul><p>不要只在一个主节点上获取锁setnx，至少在半数以上的节点通过setnx成功后才能获取锁。</p><h5 id=redission分布式锁的使用>Redission分布式锁的使用</h5><blockquote><p>Redission是架设在Redis基础上的一个java驻内存数据网络。</p><p>Redission在基于NIO的Netty框架上，生产环境使用分布式锁。</p></blockquote><p><img src=https://www.helloimg.com/images/2022/04/29/RMp24A.png loading=lazy></p><ul><li>watch dog</li></ul><p>后台有一个线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><h2 id=大厂面试提>大厂面试提</h2><h3 id=缓存雪崩缓存穿透缓存击穿>缓存雪崩，缓存穿透，缓存击穿</h3><p>穿透： 不存在的key</p><p>雪崩：大量的key失效</p><p>击穿： 一个key或一些key 热点数据</p><h3 id=数据一致性问题>数据一致性问题</h3><ul><li>延时双删</li></ul><p>不是实时一直，而是最终一致。</p><p>如果延时双删不成功，就等key失效。</p><ul><li>热点数据和冷数据</li></ul><p>热点数据怎么处理</p><p>冷数据如果淘汰过期</p><h3 id=redis为什么这么快>redis为什么这么快</h3><ul><li>redis在内存中操作，正常情况下和硬盘不会频繁swap</li><li>maxmemory的设置+淘汰策略</li><li>数据结构简单，有压缩处理，专门设计的</li><li>单线程没有锁，没有多线程的切换和调度，不会死锁，没有性能消耗</li><li>使用i/o多路复用模型，非阻塞io</li><li>构建了多种通讯模式，进一步提升了性能</li></ul><h3 id=如何在多个核心的cpu上利用redis的性能>如何在多个核心的CPU上利用redis的性能</h3><p>redis是单线程的，如果想在多个CPU或者多个核心上充分利用redis性能，</p><p>在单个机器上部署多个redis实例，然后使用taskset指令将不同的redis绑定到不同的核心上。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/redis/>Redis</a>
<a href=/tags/book/>Book</a>
<a href=/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/>读后感</a>
<a href=/tags/%E7%BC%93%E5%AD%98/>缓存</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/1.22118b12382a925a0654108c896ac30f_hu_f9de550d13cfbb7a.png width=250 height=150 loading=lazy alt="Featured image of post 读《mysql是怎样运行的》有感" data-hash="md5-IhGLEjgqkloGVBCMiWrDDw=="></div><div class=article-details><h2 class=article-title>读《mysql是怎样运行的》有感</h2></div></a></article><article class=has-image><a href=/p/%E8%AF%BB%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/%E8%AF%BB%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E6%9C%89%E6%84%9F/1.2f893e4f34ccc66142386d9b11d1711c_hu_f3b69de56dea9b7c.png width=250 height=150 loading=lazy alt="Featured image of post 读《并发编程的艺术》有感" data-hash="md5-L4k+TzTMxmFCOG2bEdFxHA=="></div><div class=article-details><h2 class=article-title>读《并发编程的艺术》有感</h2></div></a></article><article class=has-image><a href=/p/java-ontwerp-patroon/><div class=article-image><img src=/p/java-ontwerp-patroon/1.81a9dce623b1d6fe4485ac670cb7da98_hu_10158e7e9c50ff2e.png width=250 height=150 loading=lazy alt="Featured image of post 读《重学java设计模式》有感" data-key=java-Ontwerp-patroon data-hash="md5-ganc5iOx1v5EhaxnDLfamA=="></div><div class=article-details><h2 class=article-title>读《重学java设计模式》有感</h2></div></a></article><article class=has-image><a href=/p/icyfenix-hoeksteen/><div class=article-image><img src=/p/icyfenix-hoeksteen/1.9ce725d0528cc3b0d5321b62181de3a9_hu_fa570a2a13ed75d3.png width=250 height=150 loading=lazy alt="Featured image of post 读《凤凰架构》有感--分布式基石" data-key=icyfenix-Hoeksteen data-hash="md5-nOcl0FKMw7DVMhtiGB3jqQ=="></div><div class=article-details><h2 class=article-title>读《凤凰架构》有感--分布式基石</h2></div></a></article><article class=has-image><a href=/p/icyfenix-argitektuur/><div class=article-image><img src=/p/icyfenix-argitektuur/1.ba219af96a0f1cdca5fb92348980d969_hu_a5ddc70effcb6e98.png width=250 height=150 loading=lazy alt="Featured image of post 读《凤凰架构》有感--架构篇" data-key=icyfenix-Argitektuur data-hash="md5-uiGa+WoPHNyl+5I0iYDZaQ=="></div><div class=article-details><h2 class=article-title>读《凤凰架构》有感--架构篇</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//thecoolboyhan.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 韩永发的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.31.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>