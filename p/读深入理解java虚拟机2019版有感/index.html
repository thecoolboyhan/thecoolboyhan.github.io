<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="非常nice的java虚拟机书籍"><title>读《深入理解java虚拟机2019版》有感</title><link rel=canonical href=https://thecoolboyhan.github.io/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/><link rel=stylesheet href=/scss/style.min.833d6eed45de56f48306bf57268d5b8cdfc8a60e8e7bdc99810464fcd033f7c6.css><meta property='og:title' content="读《深入理解java虚拟机2019版》有感"><meta property='og:description' content="非常nice的java虚拟机书籍"><meta property='og:url' content='https://thecoolboyhan.github.io/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/'><meta property='og:site_name' content='韩永发的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='JVM'><meta property='article:tag' content='GC'><meta property='article:tag' content='java'><meta property='article:tag' content='读后感'><meta property='article:published_time' content='2024-09-10T00:00:00+00:00'><meta property='article:modified_time' content='2024-09-10T00:00:00+00:00'><meta property='og:image' content='https://thecoolboyhan.github.io/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAv3.png'><meta name=twitter:title content="读《深入理解java虚拟机2019版》有感"><meta name=twitter:description content="非常nice的java虚拟机书籍"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://thecoolboyhan.github.io/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAv3.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_63165f4306fe5eb3.png width=300 height=400 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>韩永发的博客</a></h1><h2 class=site-description>目前人在上海，20年毕业，普通muggle，java开发。邮箱：hanyongfa2013@163.com 。</h2></div></header><ol class=menu-social><li><a href=https://github.com/thecoolboyhan target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://leetcode.cn/u/thecoolboy/ target=_blank title=力扣 rel=me><svg role="img" viewBox="0 0 24 24"><title>LeetCode</title><path d="M13.483.0a1.374 1.374.0 00-.961.438L7.116 6.226l-3.854 4.126a5.266 5.266.0 00-1.209 2.104 5.35 5.35.0 00-.125.513 5.527 5.527.0 00.062 2.362 5.83 5.83.0 00.349 1.017 5.938 5.938.0 001.271 1.818l4.277 4.193.039.038c2.248 2.165 5.852 2.133 8.063-.074l2.396-2.392c.54-.54.54-1.414.003-1.955a1.378 1.378.0 00-1.951-.003l-2.396 2.392a3.021 3.021.0 01-4.205.038l-.02-.019-4.276-4.193c-.652-.64-.972-1.469-.948-2.263a2.68 2.68.0 01.066-.523 2.545 2.545.0 01.619-1.164L9.13 8.114c1.058-1.134 3.204-1.27 4.43-.278l3.501 2.831c.593.48 1.461.387 1.94-.207a1.384 1.384.0 00-.207-1.943l-3.5-2.831c-.8-.647-1.766-1.045-2.774-1.202l2.015-2.158A1.384 1.384.0 0013.483.0zm-2.866 12.815a1.38 1.38.0 00-1.38 1.382 1.38 1.38.0 001.38 1.382H20.79a1.38 1.38.0 001.38-1.382 1.38 1.38.0 00-1.38-1.382z"/></svg></a></li><li><a href=mailto:hanyongfa2013@163.com target=_blank title=邮箱 rel=me><svg id="mdi-email-arrow-right-outline" viewBox="0 0 24 24"><path d="M13 19C13 18.66 13.04 18.33 13.09 18H4V8l8 5 8-5v5.09C20.72 13.21 21.39 13.46 22 13.81V6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18c0 1.1.9 2 2 2h9.09C13.04 19.67 13 19.34 13 19M20 6l-8 5L4 6H20m0 16V20H16V18h4V16l3 3-3 3z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#类加载器子系统>类加载器子系统</a><ol><li><a href=#类加载的过程>类加载的过程</a><ol><li><a href=#加载>加载</a></li><li><a href=#链接>链接</a></li><li><a href=#初始化>初始化</a></li></ol></li><li><a href=#类加载器>类加载器</a><ol><li><a href=#启动类加载器引导类加载器bootstrap-classloader>启动类加载器（引导类加载器、Bootstrap ClassLoader）</a></li></ol></li><li><a href=#双亲委派机制>双亲委派机制</a><ol><li><a href=#沙箱安全机制>沙箱安全机制</a></li></ol></li></ol></li><li><a href=#运行时数据区>运行时数据区</a><ol><li><a href=#程序计数器pc寄存器>程序计数器（pc寄存器）</a></li></ol></li><li><a href=#栈>栈</a><ol><li><a href=#栈的特点>栈的特点</a></li><li><a href=#栈的存储单位>栈的存储单位</a><ol><li><a href=#栈帧的内部结构>栈帧的内部结构</a></li></ol></li><li><a href=#关于操作数栈和局部变量表的举例和说明>关于操作数栈和局部变量表的举例和说明</a><ol><li><a href=#操作数栈和局部变量表的联动>操作数栈和局部变量表的联动</a></li></ol></li></ol></li><li><a href=#类加载过程>类加载过程</a><ol><li><a href=#loading-加载>loading 加载</a></li><li><a href=#classloader的源码>ClassLoader的源码</a></li><li><a href=#自定义类加载器>自定义类加载器</a></li><li><a href=#linking>linking</a><ol><li><a href=#校验>校验</a></li><li><a href=#赋值默认值>赋值（默认值）</a></li><li><a href=#解析-1>解析</a></li></ol></li><li><a href=#赋初始值>赋初始值</a><ol><li><a href=#总结>总结</a></li></ol></li><li><a href=#一些常用的分析>一些常用的分析</a><ol><li><a href=#静态绑定和动态绑定>静态绑定和动态绑定</a></li><li><a href=#多态的原理>多态的原理</a></li><li><a href=#finally>finally</a></li><li><a href=#对于反射的优化>对于反射的优化</a></li></ol></li></ol></li><li><a href=#jmm>JMM</a><ol><li><a href=#程序计数器>程序计数器</a></li><li><a href=#栈-1>栈</a></li><li><a href=#本地方法栈>本地方法栈</a></li><li><a href=#方法区>方法区</a><ol><li><a href=#方法区内存结构图>方法区内存结构图</a></li><li><a href=#方法区内存溢出问题>方法区内存溢出问题</a></li></ol></li><li><a href=#运行时常量池>运行时常量池</a><ol><li><a href=#stringtable字符串池>stringTable（字符串池）</a></li></ol></li><li><a href=#直接内存>直接内存</a><ol><li><a href=#direct-memory-大文件拷贝>direct Memory 大文件拷贝</a></li><li><a href=#直接内存释放原理>直接内存释放原理</a></li></ol></li></ol></li><li><a href=#gc>gc</a><ol><li><ol><li><a href=#四种引用>四种引用</a></li></ol></li><li><a href=#一些常用参数>一些常用参数</a><ol><li><a href=#usegcoverheadlimit>UseGCOverheadLimit</a></li><li><a href=#-xx-disableexplicitgc>-xx: +DisableExplicitGC</a></li></ol></li><li><a href=#gc的常用算法>gc的常用算法</a></li><li><a href=#常见的垃圾回收器>常见的垃圾回收器</a><ol><li><a href=#g1和其他的垃圾回收器的区别>G1和其他的垃圾回收器的区别</a></li></ol></li><li><a href=#jvm调优>JVM调优</a></li><li><a href=#jvm调优经验>jvm调优经验</a></li><li><a href=#g1jdk9的默认回收器>G1（JDK9的默认回收器）</a><ol><li><a href=#cms老年带回收器><strong>CMS</strong>（老年带回收器）</a></li><li><a href=#g1垃圾优先>G1（垃圾优先）</a></li><li><a href=#三色标记算法>三色标记算法</a></li><li><a href=#g1的优化>G1的优化</a></li><li><a href=#jdk-8u40并发标记类卸载>JDK 8u40并发标记类卸载</a></li><li><a href=#jdk-8-u60回收巨型对象>JDK 8 u60回收巨型对象</a></li><li><a href=#jdk9-并发标记起始时间调整>JDK9 并发标记起始时间调整</a></li></ol></li></ol></li><li><a href=#读深入理解java虚拟机第3版有感>读《深入理解java虚拟机（第3版）》有感</a><ol><li><a href=#自动内存管理>自动内存管理</a><ol><li><a href=#java内存区域和内存溢出异常>java内存区域和内存溢出异常</a></li></ol></li><li><a href=#hotspot>HotSpot</a><ol><li><a href=#对象的创建>对象的创建</a></li></ol></li></ol></li><li><a href=#垃圾收集器和内存分配策略>垃圾收集器和内存分配策略</a><ol><li><a href=#确认对象需要被回收>确认对象需要被回收</a><ol><li><a href=#引用计数算法>引用计数算法</a></li><li><a href=#可达性分析算法>可达性分析算法</a></li></ol></li><li><a href=#垃圾回收算法>垃圾回收算法</a></li><li><a href=#垃圾回收器>垃圾回收器</a></li><li><a href=#低延迟垃圾收集器>低延迟垃圾收集器</a><ol><li><a href=#shenandoah谢南多厄收集器>Shenandoah（谢南多厄）收集器</a></li><li><a href=#zgc>ZGC</a></li></ol></li></ol></li><li><a href=#虚拟机性能监控故障处理>虚拟机性能监控，故障处理</a></li><li><a href=#调优案例分析和实战>调优案例分析和实战</a><ol><li><a href=#大内存硬件上的程序部署策略>大内存硬件上的程序部署策略</a></li><li><a href=#由于数据结构问题导致的gc时间变长>由于数据结构问题导致的GC时间变长</a></li></ol></li><li><a href=#类加载机制>类加载机制</a></li><li><a href=#高效并发>高效并发</a><ol><li><a href=#java内存模型和线程>java内存模型和线程</a><ol><li><a href=#java内存交互操作>java内存交互操作</a></li><li><a href=#对于volatile型变量的特殊规则>对于volatile型变量的特殊规则</a></li><li><a href=#happens-before先行发生规则>Happens-Before（先行发生规则）</a></li></ol></li><li><a href=#java与线程>java与线程</a><ol><li><a href=#线程的实现>线程的实现</a></li><li><a href=#java线程调度>java线程调度</a></li><li><a href=#协程>协程</a></li><li><a href=#纤程>纤程</a></li></ol></li><li><a href=#线程安全和锁优化>线程安全和锁优化</a><ol><li><a href=#线程安全的实现方法>线程安全的实现方法</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/><img src=/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAv3_hu_8d3e5aaedbdbd070.png srcset="/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAv3_hu_8d3e5aaedbdbd070.png 800w, /p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BAv3_hu_6c6568a4658fb89d.png 1600w" width=800 height=533 loading=lazy alt="Featured image of post 读《深入理解java虚拟机2019版》有感"></a></div><div class=article-details><header class=article-category><a href=/categories/%E7%B2%BE%E9%80%89/>精选</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%AF%BB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA2019%E7%89%88%E6%9C%89%E6%84%9F/>读《深入理解java虚拟机2019版》有感</a></h2><h3 class=article-subtitle>非常nice的java虚拟机书籍</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2024-09-10T00:00:00Z>Sep 10, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 34 分钟</time></div></footer></div></header><section class=article-content><h2 id=类加载器子系统>类加载器子系统</h2><ul><li><p>类加载子系统负责从文件系统或者网络中加载class文件，class文件在文件的开头有特定的文件标识。</p></li><li><p>CLassLoader只负责classs文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。</p></li><li><p>加载的类信息存放于一块称为方法区的内存空间，除了类的信息外， 方法区中还会存放运行时常量池信息，可能还包含字符串字面量和数字常量（这部分常量信息是lass文件中常量池部分的内存映射）</p></li></ul><h3 id=类加载的过程>类加载的过程</h3><h4 id=加载>加载</h4><ol><li>通过一个类的全限定名获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时结构</li><li>在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据的访问入口</li></ol><h4 id=链接>链接</h4><h5 id=验证>验证</h5><ul><li>目的在于确保class文件的字节流中包含的信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害虚拟机自身的安全。</li><li>主要包括四种验证：文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ul><h5 id=准备>准备</h5><ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li>这里不包含用final修饰的static，因为final在编译的时候就分配了，准备阶段会显式初始化。</li><li>这里不会实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。</li></ul><blockquote><p>此环境只给变量分配内存，和默认初始值，没赋值。</p><p>final 修饰的static会赋值。</p></blockquote><h5 id=解析>解析</h5><ul><li>常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作往往会伴随着jvm在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标，符号引用的字面量形式明确定义在（java虚拟机规范）的class文件格式中，直接引用就是直接指向目标的指针，相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段 、类方法、接口方法、方法类型等。</li></ul><h4 id=初始化>初始化</h4><ul><li>初始化阶段就是执行类构造器方法<clinit>()的过程。</li><li>此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><clinit>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init>()）</li><li>若该类具有父类，jvm会保证子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程下被同步加锁。</li></ul><h3 id=类加载器>类加载器</h3><h4 id=启动类加载器引导类加载器bootstrap-classloader>启动类加载器（引导类加载器、Bootstrap ClassLoader）</h4><ul><li><p>这个类加载器使用c/c++实现的，嵌套在JVM内部。</p></li><li><p>它用来加载java的核心库（JAVA_HOME/jre/lib/rt.jar，resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</p></li><li><p>并不继承自java.lang.ClassLoader,没有父加载器</p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p></li></ul><h3 id=双亲委派机制>双亲委派机制</h3><ul><li>原理</li></ul><blockquote><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ol></blockquote><h4 id=沙箱安全机制>沙箱安全机制</h4><blockquote><p>由于双委派机制，用户直接私自篡改java核心包下的类，（如自定义一个String类），这种保护机制叫沙箱安全机制。</p></blockquote><h2 id=运行时数据区>运行时数据区</h2><h3 id=程序计数器pc寄存器>程序计数器（pc寄存器）</h3><blockquote><p>JVM中的程序计数器，它的命名来源于cpu的寄存器，寄存器存储指令相关的现场信息，cpu只有把数据转载到寄存器才能运行。</p><p>程序计数器不是广义上的物理寄存器，JVM中的程序计数器是对cpu中的寄存器的一种抽象模拟。</p></blockquote><ul><li>作用</li></ul><p>pc寄存器用来储存指向下一条指令的地址，也就是即将要执行的下一条指令，由执行引擎来读取下一条指令。</p><p><img src=https://ae01.alicdn.com/kf/U1651b01ab9de4497847316b52a39c466c.jpg loading=lazy></p><blockquote><ul><li><p>它是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储空间。</p></li><li><p>在JVM规范中，每个线程都有自己的程序计数器，是线程私有的，它的生命周期和线程的生命周期保持一致。</p></li><li><p>任何时间一个线程都只有一个方法在执行，也就是当前方法，程序计数器会存储当前正在执行的指令方法的jvm指令地址，如果执行的是navtive方法，它其中就是未指定值（ undefined）</p></li><li><p>它是唯一一个jvm没有规定任何OOM的区域。</p></li></ul></blockquote><p><img src=https://ae01.alicdn.com/kf/U1651b01ab9de4497847316b52a39c466c.jpg loading=lazy></p><h2 id=栈>栈</h2><blockquote><p>栈是运行时单位，而堆是存储的单位</p><p>栈解决程序的运行问题，（程序如何执行）或者如何处理数据，堆解决的是数据存储的问题，数据怎么放，放在哪儿。</p></blockquote><ul><li>栈中 存放的东西</li></ul><blockquote><p>主管java的运行，保存方法的局部变量（八种基本数据类型的值，对象的引用地址），部分结果，并参与方法的调用和返回。</p></blockquote><h3 id=栈的特点>栈的特点</h3><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</li><li>JVM直接对java的操作有两种：<ul><li>每个方法按执行，伴随着进栈（入栈，压栈）</li><li>执行结果后的出栈操作</li></ul></li><li>对于栈来说不存在垃圾回收的问题。</li></ul><blockquote><p>java默认的栈大小是动态的（不固定但是不是无限大），但是可以手动设置大小，如果超出后会报栈溢出</p></blockquote><ul><li>-Xss设置栈大小</li></ul><h3 id=栈的存储单位>栈的存储单位</h3><blockquote><p>栈的基本单位是栈帧，在一个线程中，一个时间节点只有一个活动的栈帧。</p></blockquote><h4 id=栈帧的内部结构>栈帧的内部结构</h4><ul><li>局部变量表</li></ul><blockquote><p>定义为一个数组，主要用于存储方法参数和定义在方法体内部的局部变量。</p></blockquote><p>局部变量表所需大小是在编译期就确定下来的，并保存在方法的Code属性的maximun local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。</p><ul><li><ul><li>Slot（槽）</li></ul></li></ul><blockquote><p>槽是局部变量表中的计量单位，32位以内的数据（byte，short，char，int）只占一个Slot槽位，64位类型的数据（long和double）占两个。</p></blockquote><p>Slot是放在栈里的数组中，数据的大小是不会动态改变的，如果前面的槽位被释放，后面有新的slot可重新去用之前的空间，这就是slot的重复利用。</p><ul><li>操作数栈（表达式栈）</li></ul><blockquote><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新pc寄存器中下一条需要执行的字节码指令。</p></blockquote><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>java虚拟机的解释引擎是基于栈的执行引擎，其中栈指的就是操作数栈。</p><p>用来临时存储操作过程的中间结果。</p><ul><li>动态链接</li></ul><blockquote><p>用来记录方法区常量池中对象的地址。</p></blockquote><p>关于静态链接和动态链接</p><blockquote><p>当一个字节码文件被装载进jvm内部时，如果被调用的方法在编译期可知，且运行期保持不变，这种情况下，被调用的方法的符号引用转换为直接引用的过程叫做静态链接。</p></blockquote><blockquote><p>被调用的方法在编译期无法被确定下来，只能在程序的运行期间，被调用的方法的符号引用被转化为直接引用，这种转化过程具有动态性，就叫动态链接。</p></blockquote><ul><li>方法返回地址</li><li>一些附加信息</li></ul><h3 id=关于操作数栈和局部变量表的举例和说明>关于操作数栈和局部变量表的举例和说明</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=o>&lt;</span><span class=n>10</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>x</span><span class=o>=</span><span class=n>x</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>i</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//结果是0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>x</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>局部变量表</li></ul><p>一个类中的变量其实都是局部变量表中的一个值。</p><ul><li>操作数栈</li></ul><p>用来临时存储操作过程的中间结果，就是一个值变化过程的临时存储。</p><h4 id=操作数栈和局部变量表的联动>操作数栈和局部变量表的联动</h4><p>以x=x++为例：</p><ul><li>读取</li></ul><p>首先从局部变量表中读取load对映hash槽里读取x的值，此时操作数栈中为0，局部变量表也为0</p><ul><li>x++</li></ul><p>x++操作是在局部变量表中进行的，所以局部变量表中的值加1，此时操作数栈中为0，局部变量表为0</p><ul><li>赋值</li></ul><p>等于操作是把操作数栈中的值赋值到对应的局部变量表中，操作数栈的值为0，局部变量表中的为1，用操作数栈的0来覆盖局部变量表中的1，所以x重新变为0。</p><h2 id=类加载过程>类加载过程</h2><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1624503795185-1624503795168.png loading=lazy></p><h3 id=loading-加载>loading 加载</h3><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1624513152313-1624513152293.png loading=lazy></p><ul><li>父加载器</li></ul><blockquote><p>父加载器不是“类加载器的加载器”，也不是类加载器的父类加载器。</p></blockquote><p><strong>父加载器只当前类加载器的parent对象指向的加载器。</strong></p><h3 id=classloader的源码>ClassLoader的源码</h3><p>findInCache-> parentLoadClass -> findClass()</p><h3 id=自定义类加载器>自定义类加载器</h3><ol><li>extends ClassLoader</li><li>overwrite findClass（）-》defineClass（bytep[]->class clazz）</li></ol><p>混合执行，编译执行，解释执行</p><h3 id=linking>linking</h3><h4 id=校验>校验</h4><ol><li>验证文件是否符合jvm规定</li></ol><h4 id=赋值默认值>赋值（默认值）</h4><ol><li>静态成员变量赋默认值。</li></ol><h4 id=解析-1>解析</h4><ol><li>将类。方法，属性等符号引用解析为直接引用，指向内存的详细地址。</li></ol><h3 id=赋初始值>赋初始值</h3><h4 id=总结>总结</h4><blockquote><p>load- 默认值- 初始值</p><p>new -申请内存- 默认值-初始值</p></blockquote><h3 id=一些常用的分析>一些常用的分析</h3><h4 id=静态绑定和动态绑定>静态绑定和动态绑定</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=nf>Demo3_9</span><span class=p>(){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>test1</span><span class=p>(){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>test2</span><span class=p>(){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>test3</span><span class=p>(){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>test4</span><span class=p>(){}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Demo3_9</span><span class=w> </span><span class=n>demo3_9</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Demo3_9</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>demo3_9</span><span class=p>.</span><span class=na>test1</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>demo3_9</span><span class=p>.</span><span class=na>test2</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>demo3_9</span><span class=p>.</span><span class=na>test3</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Demo3_9</span><span class=p>.</span><span class=na>test4</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>test1,test2,test4都是可以直接确定要调用哪个方法，称为静态绑定。invokespecial（私有方法） invokestatic（静态方法）</p><p>test3是public的方法，可能会被重写，只有在运行的过程当中才能确定具体调用的哪个方法，被称为动态绑定。invokevirtual</p><blockquote><p>静态绑定的运行效率要远远高于动态绑定的方法。</p></blockquote><h4 id=多态的原理>多态的原理</h4><blockquote><p>虚方法表是在链接阶段生成的</p></blockquote><ul><li>虚方法表(vtable)</li></ul><p>动态绑定的方法会存在虚方法表中。静态方法，私有方法，final修饰的方法都不在虚方法表中。虚方法表在一个类的二进制文件的最后一行。</p><blockquote><p>虚方法中会记录此类中的方法具体是调用的哪个父类或自己的具体方法。</p></blockquote><h4 id=finally>finally</h4><p>finally会捕获try中的异常，catch中的异常，会普通代码里的异常 ，拷贝三份一样的代码，来确保finally中的代码一定会被执行。</p><p>如果finally中有return，finally中的return会在代码中的return之后执行。finally中的return不会抛异常。</p><h4 id=对于反射的优化>对于反射的优化</h4><ul><li>sun.reflect.noInfloation可以用来禁用膨胀（直接生成GeneratedMethodAccessorl，但首次生成比较耗时，如果仅反射调用一次，不划算）</li><li>sun.reflect.inflationThreshold可以修改膨胀阀值</li></ul><h2 id=jmm>JMM</h2><ul><li>jvm分区</li></ul><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1627032589921-1627032589890.png loading=lazy></p><p>padding（缓存一次读取64个字节的数据）</p><p>三级缓存</p><ul><li>合并写（寄存器只能处理四个字节）</li></ul><p>每四个字节同时修改。</p><p>零拷贝</p><p>jvm直接去访问os管理的内存。不需要不复制到jvm内存中，就是直接内存的使用。</p><h3 id=程序计数器>程序计数器</h3><ul><li>线程私有的</li></ul><blockquote><p>记录下一条指令的执行地址</p></blockquote><p>程序计数器不会存在内存溢出问题。</p><h3 id=栈-1>栈</h3><ul><li>线程私有的</li></ul><p>线程运行需要的内存空间</p><h3 id=本地方法栈>本地方法栈</h3><ul><li>线程私有的</li></ul><blockquote><p>java代码调用native方法来调用c/c++的代码运行所用的空间。</p></blockquote><h3 id=方法区>方法区</h3><blockquote><p>线程共享的区域</p></blockquote><ul><li>1.8之前</li></ul><p>字符串常量存储在永久区（堆内存）</p><p>FGC不会清理</p><ul><li>1.8之后（元数据区）（系统本地内存）</li></ul><p>字符串常量位于堆</p><p>会触发FGC清理</p><h4 id=方法区内存结构图>方法区内存结构图</h4><p><img src=https://i.loli.net/2021/10/19/AbP1EDVZFyWgaxJ.png loading=lazy></p><h4 id=方法区内存溢出问题>方法区内存溢出问题</h4><p>元空间默认使用的是系统内存，一般不会发生内存溢出问题，</p><blockquote><p>当类的加载器创建的类过多时，就会导致方法区内存溢出。</p></blockquote><h3 id=运行时常量池>运行时常量池</h3><blockquote><p>运行时常量池，常量池是*.class 文件中的，当该类被加载，它的常量池</p></blockquote><ul><li>类基本信息</li><li>常量池</li></ul><p>给指令提一些常量符合，让执行器根据这些符号来找到要去执行哪些方法。</p><blockquote><p>常量池，就是一张表，虚拟机指令根据这张表常量池表找到执行的类名，方法名，参数类型，字面量等信息</p></blockquote><ul><li>类方法定义</li><li>虚拟机指令</li></ul><h4 id=stringtable字符串池>stringTable（字符串池）</h4><blockquote><p>StringTable的底层实现类似hashtable，是hash表。</p></blockquote><p>常量池中的信息都会被加载到运行时常量池中，这时这些都是常量池中的符号，还没有变为java字符串对象。</p><p>所有字符串都是懒惰加载的，只有在使用时才会创建，字符串创建前先要去字符串池中判断当前字符串是否存在，如果不存在就创建。</p><ul><li>常量池中的字符串只是符号，第一次用到时才变为对象。</li><li>利用串池的机制，来避免重复创建字符串对象。</li><li>字符串变量拼接的原理是StringBuilder。（1.8）</li><li>字符串常量拼接的原理是编译器优化。</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放串池中。</li></ul><h5 id=stringtable的垃圾回收>StringTable的垃圾回收</h5><p>当内存紧张时，且放入stringTable的字符串没有引用时，也会发生GC现象。</p><h5 id=stringtable的性能调优>stringTable的性能调优</h5><p>&ndash;XX StringTableSize=20000 修改stringTable单个桶大小，当stringtable中的字符串常量非常多时，可以调整桶大小减少hash冲突，来提升性能。</p><p>让字符串入池可以极大的减少堆内存的占用。</p><h3 id=直接内存>直接内存</h3><p>直接内存属于操作系统内存。</p><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id=direct-memory-大文件拷贝>direct Memory 大文件拷贝</h4><p>byteBuffer可以使用直接内存来完成文件NIO操作，它的大文件拷贝效率要比传统的FileInputStream（IO流）高效很多。</p><ul><li>传统IO拷贝操作</li></ul><p><img src=https://i.loli.net/2021/11/05/XMEYhASzBukWe3v.png loading=lazy></p><p>文件要先被读取到系统内存中，后被拷贝到JVM堆内存中。</p><p>cpu从java用户态先切换到内核态，再切换回用户态来完成拷贝。</p><ul><li>使用直接内存来完成大文件拷贝</li></ul><p><img src=https://i.loli.net/2021/11/05/rHAD3pktg7YcFWV.png loading=lazy></p><p>会在系统内存中生成一块名为direct memory的内存空间，这块空间java可以直接访问。</p><p>cpu从用户态切换到内核态，将文件读取到此内存中，然后切换回用户态直接在这块内存进行操作。</p><blockquote><p>比传统方式少了一次缓冲区复制操作。</p></blockquote><h4 id=直接内存释放原理>直接内存释放原理</h4><ul><li>通过unsafe分配直接内存和释放内存</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kt>long</span><span class=w> </span><span class=n>base</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>unsafe</span><span class=p>.</span><span class=na>allocateMemory</span><span class=p>(</span><span class=n>_1Gb</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//分配内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>unsafe</span><span class=p>.</span><span class=na>setMemory</span><span class=p>(</span><span class=n>base</span><span class=p>,</span><span class=n>_1Gb</span><span class=p>,(</span><span class=kt>byte</span><span class=p>)</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>System</span><span class=p>.</span><span class=na>in</span><span class=p>.</span><span class=na>read</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//释放内存</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>unsafe</span><span class=p>.</span><span class=na>freeMemory</span><span class=p>(</span><span class=n>base</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>System</span><span class=p>.</span><span class=na>in</span><span class=p>.</span><span class=na>read</span><span class=p>()</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://i.loli.net/2021/11/05/2OX187sLqhSzIBA.png loading=lazy></p><h2 id=gc>gc</h2><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625217137382-1625217137375.png loading=lazy></p><p>这些不会被垃圾回收</p><h4 id=四种引用>四种引用</h4><p><img src=https://i.loli.net/2021/11/05/HIXqKvshlSgfEjM.png loading=lazy></p><blockquote><p>软引用和虚引用在被 gc时，要进入引用队列然后被gc回收所占用的空间。</p></blockquote><ul><li>强</li></ul><p>只有所有GC Roots对象不通过（强引用）引用该对象，该对象才能被 垃圾回收。</p><p>只要能通过gc root找到，就不会被垃圾回收。</p><ul><li>软</li></ul><p>只要没有被强引用引用到，在gc时就可能会被回收</p><p>普通gc后，如果内存当内存不足时gc</p><ul><li>弱</li></ul><p>只要没有被强引用引用到，在gc时就可能会被回收</p><p>只要发生gc就会被回收。</p><ul><li>虚</li></ul><p>必须配合引用对象使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。</p><p>虚引用被回收时，就会被加入到引用队列中，当此引用不再被强引用引用时，会调用unsafe中的freeMemory方法回收。</p><ul><li>终结器引用</li></ul><p>终结方法被重写后，重写的终结方法就可以被gc回收。</p><p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象。</p><h3 id=一些常用参数>一些常用参数</h3><ul><li>堆初始大小</li></ul><p>-Xms</p><ul><li>堆最大大小</li></ul><p>-Xmx或-XX:MaxHeapSize=size</p><ul><li>新生代大小</li></ul><p>-Xnm或（-XX:NewSize=size + -XX:MaxNewSize=size）</p><ul><li>幸存区比例（动态）</li></ul><p>-XX:InitialSurvivorRatio=ratio和-XX:-UseAdptiveSizePolicy</p><ul><li>幸存区比例</li></ul><p>-XX:SurvivorRatio=ratio</p><ul><li>晋升阀值</li></ul><p>-XX:MaxTenuringThreshold=threshold</p><ul><li>晋升详情</li></ul><p>-XX:+PrintTemuringDistributtion</p><ul><li>GC详情</li></ul><p>-XX:+PrintGCDetails -verbose:gc</p><ul><li>FullGC 前MinorGC</li></ul><p>-XX:+ScavengeBeforeFullGC</p><h4 id=usegcoverheadlimit>UseGCOverheadLimit</h4><p>当打开此开关后，如果gc花费98%的时间，也只能回收不到2%的堆空间时，就不再发生gc而是报出此错。</p><h4 id=-xx-disableexplicitgc>-xx: +DisableExplicitGC</h4><p>禁用显示的垃圾回收，让代码中的System.gc()无效。</p><p>system.gc() 是一种Full GC</p><h3 id=gc的常用算法>gc的常用算法</h3><ul><li>标记清除</li></ul><p>存活对象比较多的话效率高。</p><p>需要两遍扫描，效率低。容易 产生碎片。</p><ul><li>拷贝</li></ul><p>把内存一分为二，有用的拷贝，然后清除一边内存。</p><p>适合存活对象少的，只扫描一次，效率高。</p><p>需要移动对象，对象的引用也需要调整，</p><ul><li>标记压缩</li></ul><p>清理的同时压缩调整内存位置。</p><p>不会产生碎片，方便分配。</p><p>需要扫描两遍，需要移动对象，效率低。</p><h3 id=常见的垃圾回收器>常见的垃圾回收器</h3><ul><li>Serial</li></ul><p>单线程回收器</p><p>回收时所有线程都停止，单线程清除后继续。</p><ul><li>PS（默认的回收器）</li></ul><p>回收时所有线程停止，多线程清理后继续。</p><ul><li>ParNew</li></ul><p>回收时所有线程停止，可以配合CMS使用。</p><ul><li><p>垃圾回收器跟内存大小的关系</p><ul><li>serial 几十兆</li><li>PS 上百兆-几个G（JDK默认的垃圾回收器）</li><li>CMS 20G</li><li>G1 上百G</li><li>ZGC 4T - 16T（JDK13）</li></ul></li><li><p>常见的垃圾回收器的组合参数设定（1.8）</p></li></ul><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625225994247-1625225994234.png loading=lazy></p><ul><li>内存泄露</li></ul><blockquote><p>有废对象占据内存空间，这块空间不被回收也无法使用，</p></blockquote><ul><li>内存溢出</li></ul><blockquote><p>不断地有数据占据内存，最后把内存空间占满。</p></blockquote><h4 id=g1和其他的垃圾回收器的区别>G1和其他的垃圾回收器的区别</h4><ul><li>G1之前的垃圾回收器，有逻辑上的分带，还有物理上的分带。</li><li>G1只有逻辑上的分带，没有物理上的分带。</li><li>ZGC没有逻辑分带和物理分带，只有内存。</li></ul><h3 id=jvm调优>JVM调优</h3><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625228423227-1625228423217.png loading=lazy></p><p>调优案例</p><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625449464803-1625449464792.png loading=lazy></p><ul><li>系统cpu经常100%。如何调优？（面试高频）</li></ul><blockquote><p>cpu 100%那么一定是有线程在占用系统资源。</p></blockquote><ol><li>找出哪个进程cpu高（top）</li><li>该进程中的哪个线程cpu占用高（top -Hp）</li><li>导出该线程的堆栈（jstack）</li><li>查找哪个方法（栈帧）的消耗时间（jstack）</li><li>工作线程占比高|垃圾回收线程占比高</li></ol><h3 id=jvm调优经验>jvm调优经验</h3><p>jps 定位具体java进程</p><p>jstack 定位线程状态，重点关注 WAITING BOCKED</p><p>加入有一个进程中100个线程，很多线程都在waiting on<xxx>，一定要找到是哪个线程持有这把锁。</p><p>jinfo +线程名：显示进程详细信息。</p><p>jstat -gc 线程号： 显示gc信息。（不好看）</p><ul><li>利用JMX实现的图形化界面工具</li></ul><p>利用 JMX会消耗服务器性能，还挺大。</p><p>jconsole ：jdk自带的可视化工具。</p><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625463036770-1625463036755.png loading=lazy></p><p>jvisualvm： 新的可视化工具（JDK自带）</p><p>jprofiler最好用的图形化界面工具。（收费）</p><ul><li>如何定位OOM问题</li></ul><p>cmdline: arthas</p><p>jmap -histo 1736 | head -20</p><blockquote><p>显示前20行的占用cpu的对象。</p></blockquote><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625464536097-1625464536091.png loading=lazy></p><blockquote><p>池线上系统，内存特别大，jmap转dump执行期间会对进程产生很大的影响，甚至卡顿，（电商系统不适合）</p></blockquote><ol><li>设定参数HeapDump，OOM时会自动产生堆转储文件</li><li><font color=red>很多服务器备份（高可用），停一台服务器对其他的不影响。</font></li></ol><p>在线分析</p><ul><li>arthas：阿里的在线jvm分析工具。</li></ul><p>heapdump导出堆内存的情况。（也会影响性嫩）</p><p>分析dump</p><ul><li>jhat（jdk自带的dump分析工具）</li></ul><p>默认是多大dump文件用多大的内存去分析，分析时最好指定最大内存。</p><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625469300750-1625469300744.png loading=lazy></p><blockquote><p>分析完成后它会返回一个port端口，我们可以通过远程连接这个端口来分析dump中的数据。</p></blockquote><h3 id=g1jdk9的默认回收器>G1（JDK9的默认回收器）</h3><h4 id=cms老年带回收器><strong>CMS</strong>（老年带回收器）</h4><ul><li>concurrent mark sweep</li></ul><p>垃圾回收的线程和工作线程同时运行。</p><p><img src=https://i.loli.net/2021/11/08/PIS7chgOrfAF5N9.png loading=lazy></p><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625216803062-1625216803045.png loading=lazy></p><ul><li>CMS的缺点</li></ul><p>当老年带满时（内存条碎片过多），会调用老年带单线程回收器来清理。（FGC）</p><ul><li>CMS</li></ul><ol><li><p>初始标记：通过GCroot找到根对象。（STW的）</p><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625536953783-1625536953770.png loading=lazy></p></li><li><p>并发标记：不影响主线程的运行，在程序的运行当中来标记要回收的垃圾。</p></li><li><p>重新标记：假如之前并发标记的垃圾被又被root重新连接了，（又不能回收）在STW的情况下重新标记一遍。</p></li><li><p>并发清理：不影响程序运行的情况下清理。</p></li></ol><h4 id=g1垃圾优先>G1（垃圾优先）</h4><blockquote><p>G1是一种服务端应用使用的垃圾回收器，目标是用在多核、大内存的机器上，它在大多数情况下可以实现指定的GC暂停时间，同时还能保持较高的吞吐量。</p></blockquote><p>特点</p><ul><li>并发收集</li><li>压缩空闲空间不会延长GC的暂停时间</li><li>更易预测的GC暂停时间</li><li>适用不需要实现很高的吞吐量的场景</li></ul><blockquote><p>把内存分成多个不同的分区，每个分区都可能是年轻代也可能是老年代。同一时间一个分区只能属于一个代。</p></blockquote><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625553178210-1625553178204.png loading=lazy></p><h4 id=三色标记算法>三色标记算法</h4><ul><li>白色：未被标记的对象</li><li>灰色：自身被标记，成员变量未被标记</li><li>黑色：自身和成员变量均已标记完成，</li></ul><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625554564046-1625554563987.png loading=lazy></p><p>CMS解决三色标记问题</p><p><img src=https://cdn.jsdelivr.net/gh/weidadeyongshi2/th_blogs@main/image/1625556799695-1625556799674.png loading=lazy></p><p>CMS使用增量更新</p><p>G1使用SATB</p><h4 id=g1的优化>G1的优化</h4><h5 id=jdk-8u20-字符串去重>JDK 8u20 字符串去重</h5><ul><li>优点：节省大量内存</li><li>缺点：略微多占用的cpu时间，新生代回收时间略微增加。</li></ul><p>-XX:+UseStringDeduplication</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>String</span><span class=w> </span><span class=n>s1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=n>String</span><span class=w> </span><span class=n>s2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>String</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><ul><li>将所有新分配的字符放入一个队列</li><li>当新生代回收时，G1并发检查是否由字符串重复</li><li>如果他们值一样，让他们引用同一个char[]</li><li>注意，与String.intern()不一样<ul><li>String.intern()关注的是字符串对</li><li>而字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串表</li></ul></li></ul><h4 id=jdk-8u40并发标记类卸载>JDK 8u40并发标记类卸载</h4><p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类。</p><p>-XX:+ClassUnloadingWithConcurrentMark默认启用。</p><h4 id=jdk-8-u60回收巨型对象>JDK 8 u60回收巨型对象</h4><ul><li>一个对象大于region的一半时，称之为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>巨型对象回收时会被优先考虑</li><li>G1会跟踪老年代所有的incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><h4 id=jdk9-并发标记起始时间调整>JDK9 并发标记起始时间调整</h4><ul><li>并发标记必须在堆空间占满前完成，否则退化为FullGC</li><li>JDK9之前需使用-XX:InitiatingHeapOccupancyPercent</li><li>JDK9可以动态调整<ul><li>-XX:InitiatingHeapOccupancyPercent用来设置初始值</li><li>进行数据采样并动态调整</li><li>总会添加一个安全的空档空间</li></ul></li></ul><h2 id=读深入理解java虚拟机第3版有感>读《深入理解java虚拟机（第3版）》有感</h2><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-816:42:08-1675845727393.png loading=lazy></p><h3 id=自动内存管理>自动内存管理</h3><h4 id=java内存区域和内存溢出异常>java内存区域和内存溢出异常</h4><h5 id=运行时数据区-1>运行时数据区</h5><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-1710:57:17-1676602637615.png loading=lazy></p><ul><li>程序计数器</li></ul><blockquote><p>字节码解释器通过改变程序计数器的值来选取需要执行的下一条指令。</p></blockquote><p>由于JVM的多线程是通过线程轮流切换来实现的，同一时刻，一个CPU的一个内核，只能执行一条线程中的指令。每条线程都需要有一个独立的程序计数器，每个程序计数器的区域都是线程私有的。</p><p>如果一个线程正在运行，执行的为java方法，计数器记录的为正在执行的虚拟机字节码指令的地址。</p><p>如果正在执行的是本地方法（native），计数器的值则为空。</p><p><strong>程序计数器是JVM中唯一没有任何内存溢出的区域</strong></p><ul><li>java虚拟机栈</li></ul><blockquote><p>也是线程私有的，生命周期与线程相同。</p></blockquote><p>java每个方法被执行的时候，都会创建一个栈帧用于存储，局部变量表，操作数栈，动态连接，方法出口等。每个方法被调用完毕，就对应着一个栈帧的入栈和出栈。</p><ol><li>局部变量表：存放了，基本数据类型，对象的引用，和returnAddress类型。</li></ol><p>数据类型在局部变量表中以sort（槽）来存放，64位长度的long和double类型占用两个槽，其余只占用一个槽。</p><ul><li>本地方法栈</li></ul><blockquote><p>虚拟机执行native方法时，需要把本地方法入栈。</p></blockquote><ul><li>方法区</li></ul><blockquote><p>各个线程共享的区域，存储被虚拟机加载类型信息，常量，静态变量，即时编译器编译后的代码缓存等信息。</p></blockquote><ul><li>运行时常量池</li></ul><p>用于存储编译期生成的各种字面量和符号引用。</p><h3 id=hotspot>HotSpot</h3><h4 id=对象的创建>对象的创建</h4><ul><li>指针碰撞</li></ul><p>如果内存的空间是规整的（已使用的内存，是连续的，未使用的内存也是连续的）</p><p>在创建新对象时，指针只需要移动所要创建的对象大小的内存就好。</p><ul><li>空闲列表</li></ul><p>如果java堆中的内存不是规整的，已被使用的内存和未被使用的内存相互交错在一起</p><p>虚拟机会维护一个列表，记录哪些内存块是可用的，在列表中找到一块空间足够大的内存空间给对象实例，并在列表上更新实例。</p><blockquote><p>是选择指针碰撞还是空间列表的方式，取决于所采用的垃圾回收器是否有空间压缩整理的能力。</p></blockquote><p>Serial、ParNew等带有压缩整理过程的收集器，系统采用的分配算法是指针碰撞。</p><p>CMS这种基于Sweep算法的收集器，使用空闲列表的方式来分配内存。</p><ul><li>并发安全问题</li></ul><p>如果在并发的情况下，两个线程同时分配内存。可以有两种解决方案：</p><ol><li><p>对分配内存的动作进行同步处理，虚拟机是采用CAS配上失败重试的方式来保证更新操作的原子性。</p></li><li><p>TLAB：把内存分配的动作按照线程，按照线程划分成不同的内存进行。</p><p>当每个线程预分配的空间（本地线程分配缓冲）不够时，就采用1中同步的方式给这个线程分配新的缓冲区。</p></li></ol><blockquote><p>虚拟机是否采用TLAB：通过-XX：+/-UseTLAB参数来 设定。</p></blockquote><p>实际CMS使用TLAB分配对象的速度更快，因为这样可以减少同步方法。</p><h2 id=垃圾收集器和内存分配策略>垃圾收集器和内存分配策略</h2><h3 id=确认对象需要被回收>确认对象需要被回收</h3><h4 id=引用计数算法>引用计数算法</h4><blockquote><p>在对象中添加一个引用计数器，每当有一个地方 引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可 能再被使用的。</p></blockquote><p>但是主流的JVM都没有使用引用计数算法来管理内存，原因是引用计数器无法处理很多意外情况。例如循环依赖问题。</p><h4 id=可达性分析算法>可达性分析算法</h4><p>从GCroot作为起始节点，通过引用关系向下搜索，搜索过的路径叫做引用链。如果某个对象没有任何引用链，就证明此对象不再被使用。</p><ul><li>GCROOT</li></ul><ol><li>在栈中的引用对象，每个线程使用到的参数，局部变量，临时变量等。</li><li>在方法区中的静态变量。</li><li>在方法区中常量引用的对象，如字符串池中的对象。</li><li>native方法引用的对象。</li><li>虚拟机系统引用的对象，如基本数据类型的class对象，异常对象，系统的类加载器等。</li><li>所有被同步锁（（synchronized关键字）持有的对象。</li></ol><ul><li>并发情况的可达性分析算法</li></ul><p>·白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p><p>·黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。</p><p>·灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</p><h3 id=垃圾回收算法>垃圾回收算法</h3><ul><li>标记清除算法：最基本的垃圾回收算法，可用于新生代和老年带。</li><li>标记复制算法：常用于新生代，目前主流的垃圾回收期新生代都是采用此算法。</li><li>标记整理算法：老年带才会用的垃圾回收算法，性能消耗很高。</li></ul><blockquote><p>标记整理和标记清除算法都需要停掉用户线程来处理（STW）</p></blockquote><h3 id=垃圾回收器>垃圾回收器</h3><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2318:53:19-1677149598308.png loading=lazy></p><ul><li>Serial收集器</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2318:54:13-1677149652489.png loading=lazy></p><ul><li>ParNew收集器</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2318:56:13-1677149772287.png loading=lazy></p><p>目前只有ParNew和Serial才能和CMS配合使用。</p><ul><li>CMS收集器</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2319:01:03-1677150062735.png loading=lazy></p><ul><li>Garbage First收集器</li></ul><p>面对堆内存组成回收集来进行回收，不再管他是哪个分带。</p><p>把连续的java堆划分成大小相同的内存区域。</p><p>回收过程：</p><ol><li>初始标记：只标记和GCROOT有直接关联的对象。（没有停顿）</li><li>并发标记：从GCroot开始，对堆中的对象进行可达性分析。（与用户进程同步运行）</li><li>最终标记：对用户线程进行暂停，处理2步遗留的有变动的标记。</li><li>筛选回收：暂停用户线程，按照每个内存区域的价值，来决定回收哪个区域的内存。（把回收内存中需要留下的数据复制到新的地方，然后清理掉整个区域的数据）。</li></ol><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2319:13:12-1677150791924.png loading=lazy></p><blockquote><p>G1不再追求能够回收所有的垃圾，只要回收速度能追的上使用创建的速度就可以。所以一次不会回收掉全部的垃圾。</p></blockquote><h3 id=低延迟垃圾收集器>低延迟垃圾收集器</h3><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2319:18:34-1677151113863.png loading=lazy></p><h4 id=shenandoah谢南多厄收集器>Shenandoah（谢南多厄）收集器</h4><ol><li>初始标记：标记与GCroot直接关联的对象。此阶段STW</li><li>并发标记：遍历对象图，标记出全部可达对象。与用户线程一起运行。</li><li>最终标记：标记并发标记中间变动的对象。小段的STW</li><li>并发清理：清理整个区域一个存活对象都没有的区域。与用户线程一起</li><li>并发回收：把需要回收的内存区域中存活的对象，复制到其他区域。利用读屏障和转发指针，实现此操作和用户线程一起运行。（G1这一步需要暂停用户线程）</li><li>初始引用更新：把堆中所有指向旧对象地址的指针全部指向新的对象（只是统计出哪些对象指针需要被更新）。会有短暂的STW。</li><li>并发引用更新：并发的更新上面统计的引用。与用户线程一起运行。</li><li>最终引用更新：修正GCROOT中的引用。需要STW</li><li>并发清理：清理需要被清理的内存块。与用户线程一起。</li></ol><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2319:35:45-1677152145027.png loading=lazy></p><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2319:37:34-1677152253748.png loading=lazy></p><h4 id=zgc>ZGC</h4><p>目前最强垃圾回收器，回收的停顿时间只与GCROOT的大小有关，与堆内存无关。领先其他回收器一个数量级的差距。吞吐量第一。</p><blockquote><p>引入了染色指针的概念，把少量的信息存在了指针上。但是如果内存超过4TB将无法使用此技术。而且只能在LINUX环境下运行。</p></blockquote><ol><li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的 阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记（尽管ZGC中的名字不叫这些）的 短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1、Shenandoah不同的是，ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志 位。</li><li>并发预备重新分配：扫描整个堆内存区域，把所有存活的对象都记录下来。</li><li>并发重分配：把被标记的对象都复制到新的内存块中，在旧的内存块中为这些对象建立一个转发表。如果用户线程这个时候并发访问了就的对象，会被内存屏障截取，把这个对象的引用修正到新的区域。（指针的自愈）。</li><li>并发重映射：如果某个旧对象一直没被用户线程访问，就在下一次垃圾回收的并发标记阶段里把这些对象的引用指向新的地址。</li></ol><blockquote><p>一旦某个内存块中的引用全部指向了新的地址。此转发表被释放，内存区域也被回收。</p></blockquote><h2 id=虚拟机性能监控故障处理>虚拟机性能监控，故障处理</h2><ul><li>jps</li></ul><p>可以显示目前运行的java进程</p><p>jps还可以通过RMI协议查询远程的RMI虚拟机进程</p><ul><li>jstat</li></ul><p>监视虚拟机各种运行状态的命令行工具。</p><p>显示虚拟当前的运行状态，是在运行期查看虚拟当前状态的工具。</p><ul><li>jinfo</li></ul><p>实时的查看和修改虚拟机的各项参数。</p><ul><li>jmap</li></ul><p>用于生成堆内存快照文件。dump文件。</p><ul><li>jhat（不推荐使用）</li></ul><p>与jmap配合使用，用于分析jmap生成的dump文件。</p><p>非常耗费性能，而且分析的很简陋。</p><ul><li>jstack</li></ul><p>用于生成虚拟机当前时刻的线程快照。</p><p>利用java.lang.Thread类中的getAllStackTraces()方法可以获取所有线程的stack对象，可以实现jstack大部分的功能。</p><ul><li>个人用jstack分析分析的线程状态：
运行：RUNNABLE，备注：runnable
在等待获取锁的阻塞:BLOCKED，备注：waiting for monitor entry
调用sleep方法：TIME_WAITING，备注：waiting on condition
调用wait方法：WAITING，备注：in Object.wait()</li></ul><h2 id=调优案例分析和实战>调优案例分析和实战</h2><h3 id=大内存硬件上的程序部署策略>大内存硬件上的程序部署策略</h3><p>一个文档网站，每次操作都会把文档整个读到内存中来。由于文件内容很大，读取到堆内存中就直接到了老年代，不会在Minor GC中被回收。</p><p>之前服务器是32位操作系统，只给程序分配了1.5G堆内存。当时用户感受到缓慢但不至于等十几秒。</p><p>后来升级了硬件，64位操作系统，程序分配了12G堆内存，垃圾回收器使用了默认的吞吐量优先收集器，由于文档都直接进入了老年代，内存很快就达到阈值，每几分钟就要触发一次full GC，需要等十几秒。</p><blockquote><p>升级了硬件，加大内存条，程序运行更慢，用户体验更差了。</p></blockquote><ul><li>解决方案</li></ul><ol><li>通过一个单独的JVM虚拟机，来管理大量的java堆内存。</li><li>同时使用若干个java虚拟机，建立逻辑集群来利用硬件资源。</li></ol><p>方案1的问题：</p><p>方案1需要使用G1，谢南多厄等注重延迟的垃圾回收器。这些垃圾回收器并不成熟，而且光垃圾回收器本身就非常耗费性能。</p><p>单个JVM管理大堆内存，必须在64位的操作系统中运行。</p><p>由于压缩指针的关系，相同的程序，在32位系统中，运行速度和占用内存大小，都要优于64位操作系统。</p><p>方案2的问题：</p><p>节点竞争系统资源，磁盘资源，各节点如果同时写入某个文件，容易产生IO异常。</p><p>如果单个服务器上大量的使用HashMap等本地缓存，每个逻辑JVM节点上都有一份相同的缓存，容易造成内存的浪费。（所以小容量的JVM内存建议使用 集中式缓存）</p><ul><li>大结局</li></ul><p>最后的部署方案并没有选择升级JDK版本，而 是调整为建立5个32位JDK的逻辑集群，每个进程按2GB内存计算（其中堆固定为1.5GB），占用了 10GB内存。另外建立一个Apache服务作为前端均衡代理作为访问门户。考虑到用户对响应速度比较关心，并且文档服务的主要压力集中在磁盘和内存访问，处理器资源敏感度较低，因此改为CMS收集器 进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比起硬件升级前有较大提升。</p><ul><li>堆外内存导致的内存溢出问题</li></ul><p>当堆外内存被不断使用时，由于JVM默认的GC监控没有监控堆外内存的使用量，只在乎堆内存被使用到一定比例时才触发GC。只有FULL GC才会顺手清理一下堆外内存。</p><p>严格控制好堆外内存。</p><h3 id=由于数据结构问题导致的gc时间变长>由于数据结构问题导致的GC时间变长</h3><p>程序中有一个巨大的map在新生代，如果触发了Minor GC，而map中的数据也不能被回收。在调用复制算法的时候，就会到导致大量的信息被复制，让GC时间变长。</p><ul><li>解决方案</li></ul><p>可以禁用缓冲区，让此对象直接被复制到老年代。等到老年代GC的时候再去清理它。</p><h2 id=类加载机制>类加载机制</h2><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-2-2716:07:21-1677485240979.png loading=lazy></p><blockquote><p>如果是动态链接的情况下，解析会在验证之前</p></blockquote><h2 id=高效并发>高效并发</h2><h3 id=java内存模型和线程>java内存模型和线程</h3><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-3-3010:54:40-1680144880028.png loading=lazy></p><h4 id=java内存交互操作>java内存交互操作</h4><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识成线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的对象释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，把一个变量的值从主内存传递到工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，把一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码指令时，都会执行此操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中一个变量的值传递到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><ol><li>一个变量在同一时刻，只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行lock或assign操作以初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>一个变量执行unlock操作之前，必须先把此变量同步回主内存，（执行store、write操作）</li></ol><h4 id=对于volatile型变量的特殊规则>对于volatile型变量的特殊规则</h4><blockquote><p>java虚拟机提供的最轻量级的同步机制。</p></blockquote><ul><li>案例一</li></ul><p>一个用volatile修饰的整型变量，多个线程同时调用++操作来修改此变量。</p><p>最终结果并不正确。</p><p>原因：volatile只能保证元素的可见性，只有在读取此变量时，可以保证此值的正确性，在执行++操作时，可以其他线程已经完成了++并赋值，导致当前线程给此值赋错值。</p><blockquote><p>所以volatile还是要加synchronized或者JUC相关的锁，来保证操作的原子性。</p></blockquote><ul><li>volatile是怎么禁止指令重排序的</li></ul><blockquote><p>指令重排序指，在单个线程内，指令一操作先后顺序对指令二没有影响，cpu会随机的先执行指令1或者指令2</p></blockquote><p>被volatile修饰的变量和普通的变量区别在于，被volatile修饰的变量，在读操作和写操作的时候，都会加lock前缀指令（内存屏障）。</p><ul><li>volatile的内存屏障的作用</li></ul><p>volatile的内存屏障加在此变量的每次读取（load）的前后，和write的前后。</p><p>加了内存屏障之后，内存屏障前的指令不会在内存屏障后面运行，内存屏障后的指令不会在内存屏障前运行。</p><p>且加了内存屏障的数据，如果是写操作，就会强制把此数据从工作内存写回主内存。让其他的工作内存强制失效，重新从主内存读取数据。</p><ul><li>volatile的lock前缀的方式</li></ul><p>lock前缀不是一种内存屏障，但它能完成类似内存屏障的功能。</p><p>lock先对总线/缓存加锁，然后执行后面的指令，最后释放锁后，把高速缓存中的脏数据全部刷新回主内存。</p><blockquote><p>如果lock锁住总线的时候，其他CPU的读写请求会全部被阻塞，知道锁释放。lock后的写操作会让其他CPU相关cache失效，从而从新的内存中读取最新的数据，这个是通过缓存一致性协议做的。</p></blockquote><p>性能：volatile的读操作的性能消耗与普通变量几乎没有什么区别，但写操作可能会慢上一些。（因为lock前缀禁用了CPU的指令重排序）但也比锁的开销低。</p><ul><li>再来说说++的问题</li></ul><p>这个和++的特性有关，++操作分</p><ol><li>获取i</li><li>i自增</li><li>回写i</li></ol><p>在执行第1步操作时，volatile生效，保证两条线程一定能拿到最新的i</p><p>2操作时，有可能线程A自增了i并回写，但线程B此时已经拿到了i，不会再重新读取A回写的i，因此会产生问题。</p><p>虽然volatile会让B线程的i失效，但B线程已经走到了2，不存在读取i的操作，所以会存在问题。</p><p>这本身是++指令的问题。</p><h4 id=happens-before先行发生规则>Happens-Before（先行发生规则）</h4><blockquote><p>先行发生是java内存模型中定义的两项操作之间的编序关系，操作A先行于操作B，就是说发生操作B之前，操作A产生的影响能被操作B观察到。影响包括修改了内存中共享变量的值，发送了消息，调用了方法等。</p></blockquote><p>几种java已经默认实现了的先行发生规则：</p><ul><li>管道锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。（必须是同一个锁，后面只时间上的先后）</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。（后面指时间上的先后）</li><li>线程启动规则：Thread的start方法先行发生于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都先行发生于此线程的终止检测，我们可以通过Thread.join（）方法，Thread::isAlive（）的返回值，检测线程是否已经终止执行。</li><li>线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted（）方法检测到是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成，先行发生于它的finalize（）方法的开始。</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-4-416:15:53-1680596152950.png loading=lazy></p><p>一个普通的set，get方法。两个线程操作同一个对象。</p><p>A线程时间上先调用set（1）</p><p>B线程时间上后调用get方法</p><p>问B线程返回值是多少？</p><p>由于上面的操作完全没有遵守先行发生规则，所以虽然时间上A操作先于B，但无法判断B线程get方法的返回值，换句话说，这里的操作不是线程安全的。</p><p>解决方案：</p><p>把get和set方法都用synchronized修饰，或者把此字段值用volatile修饰，这样可以实现先行发生关系。</p><p>时间先后顺序与先行发生原则之间基本没有因果关系，所以我们衡量并发安全问题的时候不要受时间顺序的干扰，一切必须以先行发生原则为准。</p><h3 id=java与线程>java与线程</h3><h4 id=线程的实现>线程的实现</h4><ul><li>操作系统的线程</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-4-619:30:36-1680780636323.png loading=lazy></p><p>在一个操作系统中，一个线程相当于一个轻量级进程，对应一个内核核心。</p><p>每个线程的操作都是由调度器来统一调度。线程切换需要消耗很大的资源，需要从内核态，切换为系统态，再由调度器来统一分配。</p><ul><li>用户线程</li></ul><p>完全由用户态统一模拟的线程，利用代码，实现了轻量级进程的大部分操作。</p><p>这样的代码设计起来复杂，而且有些问题是在用户态下无法解决的问题。（如果一个用户虚拟线程阻塞，则整个进程都阻塞）。</p><ul><li>混合实现</li></ul><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-4-619:46:53-1680781613499.png loading=lazy></p><p>线程的创建，切换，析构等操作由用户态模拟实现，系统内核用来处理处理的映射，用户线程的调用由内核调度器来完成。（这样可以大大降低整个进程被完全阻塞的风险）</p><ul><li>java线程的实现</li></ul><p>jdk1.3之前，主流都是使用一种叫“绿色线程”的虚拟线程实现。</p><p>之后采用轻量级进程来实现线程，线程的大部分操作都是由操作系统统一来处理的。</p><p>jdk18开始，java又支持了虚拟线程的新实现。</p><h4 id=java线程调度>java线程调度</h4><p><img src=https://gitee.com/grsswh/drawing-bed/raw/master/image/2023-4-620:05:45-1680782745395.png loading=lazy></p><h4 id=协程>协程</h4><ul><li>内核线程调度切换为什么成本高？</li></ul><p>主要来自于用户态与核心态之间的状态转换。</p><p>如果发生了状态转换，操作系统需要把当前线程需要的所有上下文对象保存起来，这些保存动作会涉及到大量设变之间的拷贝。成本极高。</p><ul><li>协程的实现</li></ul><p>由用户自己模拟多线程，自己来维护线程间切换时保存上下文对象的操作。恢复操作也由用户态自己模拟。</p><ul><li>协程的优势</li></ul><p>轻量级，一个协程占用内存非常小，java线程池中的线程如果达到两百时，就已经到达瓶颈。</p><p>协程可以达到几十万的并存的协程。</p><ul><li>缺点</li></ul><p>如果遇到synchronize关键字，还是会把整个线程全部挂起。</p><h4 id=纤程>纤程</h4><blockquote><p>java的loom项目</p></blockquote><p>在java虚拟机里，建立了两个并存的java虚拟机实现，可以在程序中同时使用。新模型和旧模型同时使用。</p><p>新模型被分为两部分</p><ul><li>执行过程</li></ul><p>用于维护执行现场，保护、恢复上下文。</p><ul><li>调度器</li></ul><p>编排所有要执行的代码和顺序。默认的调度器实现就是jdk1.7加入的ForkJoinPool</p><h3 id=线程安全和锁优化>线程安全和锁优化</h3><ul><li>绝对线程安全</li></ul><blockquote><p>不管运行环境如何，调用者不需要任何额外的同步措施，调用这个对象都可以得到正确的答案。</p></blockquote><p>vector的获取和修改操作都是同步的。但是在多线程环境下，还是可能出现问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=n>Vector</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>vector</span><span class=o>=</span><span class=k>new</span><span class=w> </span><span class=n>Vector</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=kd>throws</span><span class=w> </span><span class=n>InterruptedException</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=kc>true</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=o>=</span><span class=n>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>10</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>vector</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Thread</span><span class=w> </span><span class=n>removeThread</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>//要想安全必须在这一步锁住整个vector</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>vector</span><span class=p>.</span><span class=na>size</span><span class=p>();</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>vector</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Thread</span><span class=w> </span><span class=n>printThread</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Thread</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=n>Runnable</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nd>@Override</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>run</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>//要想安全必须在这一步锁住整个vector</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>vector</span><span class=p>.</span><span class=na>size</span><span class=p>();</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>vector</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>i</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>removeThread</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>printThread</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>//不要同时产生过多的线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>Thread</span><span class=p>.</span><span class=na>activeCount</span><span class=p>()</span><span class=o>&gt;</span><span class=n>20</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>如何解决vector的线程安全问题？</p><p>如果让想让vector达到完全的线程安全，需要维护一组一致性的快照访问（类似于mysql），每个对其中元素进行改动的操作都要产生新的快照。这样需要付出极大的维护成本。</p><h4 id=线程安全的实现方法>线程安全的实现方法</h4><ol><li>互斥同步</li></ol><p>共享数据在同一时刻。只能被一条（或一些，当使用信号量的时候）线程使用。</p><p>synchronize：</p><p>详见JUC相关的笔记</p><p>lock接口的各种锁实现</p><ol start=2><li>非阻塞同步</li></ol><p>先不管是否存在线程竞争问题，先去做，做完后检查，如果没有被更改，就提交操作。</p><p>CAS</p><p>如果发生ABA问题，其实采用加锁的同步方案，要比加版本号的方案更好。</p><ol start=3><li>无同步方案</li></ol><p>可重入代码（纯代码）：</p><p>可以在代码执行的任何时刻中断它，转而去执行新代码（也可以是自己），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果造成影响。如：Rust。</p><p>所有可重入代码都是线程安全的，并不是所有线程安全的代码都是可重入代码。</p><p>线程本地存储：</p><p>把当前线程需要操作的数据，只保存在一个线程中独有，其他线程无法获取和改变这个变量。ThreadLocal。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/jvm/>JVM</a>
<a href=/tags/gc/>GC</a>
<a href=/tags/java/>Java</a>
<a href=/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/>读后感</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/jdk25-1/><div class=article-image><img src=/p/jdk25-1/1.a1fcd903c65bcaf940dee4edad9ec466_hu_64b6616386f91f8a.png width=250 height=150 loading=lazy alt="Featured image of post 备战JDK25--垃圾回收器" data-key=JDK25-1 data-hash="md5-ofzZA8ZbyvlA3uTtrZ7EZg=="></div><div class=article-details><h2 class=article-title>备战JDK25--垃圾回收器</h2></div></a></article><article><a href=/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/><div class=article-details><h2 class=article-title>JVM垃圾回收器</h2></div></a></article><article class=has-image><a href=/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/%E8%AF%BBnetty-in-action%E6%9C%89%E6%84%9F/nettyinac.4b936fec8eb554f2dfbdc656bbb2818e_hu_bde81e70e7a98525.png width=250 height=150 loading=lazy alt="Featured image of post 读《netty in action》有感" data-hash="md5-S5Nv7I61VPLfvcZWu7KBjg=="></div><div class=article-details><h2 class=article-title>读《netty in action》有感</h2></div></a></article><article class=has-image><a href=/p/spring%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3v6%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/spring%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3v6%E6%9C%89%E6%84%9F/springFrameworkV6.45c4949ea90685e7afd2cf20ba4c38ce_hu_6fdd7fdad2841555.png width=250 height=150 loading=lazy alt="Featured image of post spring中文说明文档v6有感" data-hash="md5-RcSUnqkGheev0s8gukw4zg=="></div><div class=article-details><h2 class=article-title>spring中文说明文档v6有感</h2></div></a></article><article class=has-image><a href=/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/1.b6c59dbf772a12590b4b5e33955593f2_hu_9424f85e3bd38ebb.png width=250 height=150 loading=lazy alt="Featured image of post 读《Kafka权威指南》有感" data-hash="md5-tsWdv3cqElkLS14zlVWT8g=="></div><div class=article-details><h2 class=article-title>读《Kafka权威指南》有感</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//thecoolboyhan.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2026 韩永发的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.33.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>