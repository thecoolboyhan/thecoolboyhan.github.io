<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="最近kafka越来越被常提及，总结其中的权威书籍。Kafka权威指南，作者Neha Narkhede、Gwen Shapira和Todd Palino ( 0’Reilly），版权归Neha Narkhede、GwenShapira和Todd Palino所有，978-1-4919-3616-0"><title>读《Kafka权威指南》有感</title><link rel=canonical href=https://thecoolboyhan.github.io/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/><link rel=stylesheet href=/scss/style.min.833d6eed45de56f48306bf57268d5b8cdfc8a60e8e7bdc99810464fcd033f7c6.css><meta property='og:title' content="读《Kafka权威指南》有感"><meta property='og:description' content="最近kafka越来越被常提及，总结其中的权威书籍。Kafka权威指南，作者Neha Narkhede、Gwen Shapira和Todd Palino ( 0’Reilly），版权归Neha Narkhede、GwenShapira和Todd Palino所有，978-1-4919-3616-0"><meta property='og:url' content='https://thecoolboyhan.github.io/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/'><meta property='og:site_name' content='韩永发的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='架构'><meta property='article:tag' content='book'><meta property='article:tag' content='读后感'><meta property='article:published_time' content='2025-11-18T00:00:00+00:00'><meta property='article:modified_time' content='2025-11-18T00:00:00+00:00'><meta property='og:image' content='https://thecoolboyhan.github.io/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/1.png'><meta name=twitter:title content="读《Kafka权威指南》有感"><meta name=twitter:description content="最近kafka越来越被常提及，总结其中的权威书籍。Kafka权威指南，作者Neha Narkhede、Gwen Shapira和Todd Palino ( 0’Reilly），版权归Neha Narkhede、GwenShapira和Todd Palino所有，978-1-4919-3616-0"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://thecoolboyhan.github.io/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/1.png'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_63165f4306fe5eb3.png width=300 height=400 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>韩永发的博客</a></h1><h2 class=site-description>目前人在上海，20年毕业，普通muggle，java开发。邮箱：hanyongfa2013@163.com 。</h2></div></header><ol class=menu-social><li><a href=https://github.com/thecoolboyhan target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://leetcode.cn/u/thecoolboy/ target=_blank title=力扣 rel=me><svg role="img" viewBox="0 0 24 24"><title>LeetCode</title><path d="M13.483.0a1.374 1.374.0 00-.961.438L7.116 6.226l-3.854 4.126a5.266 5.266.0 00-1.209 2.104 5.35 5.35.0 00-.125.513 5.527 5.527.0 00.062 2.362 5.83 5.83.0 00.349 1.017 5.938 5.938.0 001.271 1.818l4.277 4.193.039.038c2.248 2.165 5.852 2.133 8.063-.074l2.396-2.392c.54-.54.54-1.414.003-1.955a1.378 1.378.0 00-1.951-.003l-2.396 2.392a3.021 3.021.0 01-4.205.038l-.02-.019-4.276-4.193c-.652-.64-.972-1.469-.948-2.263a2.68 2.68.0 01.066-.523 2.545 2.545.0 01.619-1.164L9.13 8.114c1.058-1.134 3.204-1.27 4.43-.278l3.501 2.831c.593.48 1.461.387 1.94-.207a1.384 1.384.0 00-.207-1.943l-3.5-2.831c-.8-.647-1.766-1.045-2.774-1.202l2.015-2.158A1.384 1.384.0 0013.483.0zm-2.866 12.815a1.38 1.38.0 00-1.38 1.382 1.38 1.38.0 001.38 1.382H20.79a1.38 1.38.0 001.38-1.382 1.38 1.38.0 00-1.38-1.382z"/></svg></a></li><li><a href=mailto:hanyongfa2013@163.com target=_blank title=邮箱 rel=me><svg id="mdi-email-arrow-right-outline" viewBox="0 0 24 24"><path d="M13 19C13 18.66 13.04 18.33 13.09 18H4V8l8 5 8-5v5.09C20.72 13.21 21.39 13.46 22 13.81V6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18c0 1.1.9 2 2 2h9.09C13.04 19.67 13 19.34 13 19M20 6l-8 5L4 6H20m0 16V20H16V18h4V16l3 3-3 3z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#第一章初识kafka>第一章、初识Kafka</a><ol><li><a href=#11-发布与订阅消息系统>1.1 发布与订阅消息系统</a></li><li><a href=#12-kafka登场简介>1.2 Kafka登场（简介）</a></li><li><a href=#13-why-kafka>1.3 Why kafka</a></li></ol></li><li><a href=#第三章向kafka写入数据生产者>第三章、向kafka写入数据（生产者）</a><ol><li><a href=#生产者概览>生产者概览</a></li><li><a href=#发送消息到kafka>发送消息到kafka</a></li><li><a href=#生产者配置>生产者配置</a></li></ol></li><li><a href=#第四章从kafka读取数据消费者>第四章、从kafka读取数据（消费者）</a><ol><li><a href=#kafkaconsumer概念>kafkaConsumer概念</a></li><li><a href=#提交和偏移量>提交和偏移量</a></li></ol></li><li><a href=#第五章深入kafka>第五章、深入kafka</a><ol><li><a href=#分区和节点管理>分区和节点管理</a></li><li><a href=#复制>复制</a></li><li><a href=#请求处理>请求处理</a></li><li><a href=#数据存储>数据存储</a></li></ol></li><li><a href=#第六章可靠的数据传递>第六章、可靠的数据传递</a><ol><li><a href=#可靠性保证>可靠性保证</a></li><li><a href=#broker配置>broker配置</a></li><li><a href=#可靠的生产者>可靠的生产者</a></li><li><a href=#可靠的消费者如何提交偏移量>可靠的消费者（如何提交偏移量）</a></li></ol></li><li><a href=#第七章构建数据管道>第七章、构建数据管道</a><ol><li><a href=#构建数据管道时需要考虑的问题kafka的优势>构建数据管道时需要考虑的问题（kafka的优势）</a></li><li><a href=#kafka-connect>kafka Connect</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/><img src=/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/1_hu_632664dfe9518789.png srcset="/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/1_hu_632664dfe9518789.png 800w, /p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/1_hu_2dea56ad73d241ed.png 1600w" width=800 height=533 loading=lazy alt="Featured image of post 读《Kafka权威指南》有感"></a></div><div class=article-details><header class=article-category><a href=/categories/%E7%B2%BE%E9%80%89/>精选</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%AF%BBkafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/>读《Kafka权威指南》有感</a></h2><h3 class=article-subtitle>最近kafka越来越被常提及，总结其中的权威书籍。Kafka权威指南，作者Neha Narkhede、Gwen Shapira和Todd Palino ( 0’Reilly），版权归Neha Narkhede、GwenShapira和Todd Palino所有，978-1-4919-3616-0</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-11-18T00:00:00Z>Nov 18, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 16 分钟</time></div></footer></div></header><section class=article-content><h1 id=kafka权威指南>《kafka权威指南》</h1><h2 id=第一章初识kafka>第一章、初识Kafka</h2><blockquote><p>一个分布式的、可分区的、可复制的提交日志服务。</p></blockquote><h3 id=11-发布与订阅消息系统>1.1 发布与订阅消息系统</h3><blockquote><p>传统的发布订阅消息系统</p></blockquote><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1762999538762_1762999538774.png loading=lazy alt=1762999538762.png></p><p>一个独立的应用程序，用于接收所有其他应用程序的指标，并为其他系统提供一个查询接口。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1762999732109_1762999732147.png loading=lazy alt=1762999732109.png></p><p>在传统发布订阅的基础上，增加发布与订阅日志和发布与订阅跟踪。这样又新增了2个独立的应用程序单独负责。</p><p>三个独立的应用程序，有太多重复的部分，且各自之间也存在缺陷和不足。所以需要一个单一的集中式系统的需求就应孕而生。（公司业务规模越大，此需求越大）</p><h3 id=12-kafka登场简介>1.2 Kafka登场（简介）</h3><blockquote><p>kafka就是统一上面三个独立应用程序而创造的消息系统。一般被称为“分布式提交日志”或者“分布式流平台”。文件系统或数据库来提供所有事务的持久记录，通过重放日志可以重建系统的状态。Kafka的日志是按照顺序持久化保存的，可以按需读取。kafka的数据分布在整个传统里，具备数据故障保护和性能伸缩能力。</p></blockquote><ul><li>消息和批次</li></ul><p>消息：</p><p>kafka的数据单元被称为<strong>消息</strong>，类似于mysql中的数行或一条记录。消息由byte数组组成，消息里的数据没有特别的格式和含义。消息可以有一个可选的元数据（key），key也是一个字节数组，和消息一样没有格式和特殊含义。消息根据key存入一个一致性散列值（hash表），根据散列值把消息存入不同的分区。这样可以保证具有相同key的消息总被分配到相同的分区上。</p><p>批次：</p><p>为了提高效率，消息被分批次写入kafka。<strong>批次</strong>就是一组消息，这些消息属于同一个主题和分区。如果消息不按照批次处理，大量消息将导致网络开销巨大。不过批次越大，单位时间内处理的消息就越多，单个消息传输的时间就越长。<font color=red>(吞吐量越大，时间延迟越高)</font> 批次内的消息会被压缩。</p><ul><li>主题和分区</li></ul><p>kafka的消息通过主题进行分类，主题就好比数据库的表。一个主题可以被分为若干个<strong>分区</strong>，一个消息就是一个提交日志，消息以追加的方式写入分区，然后以先入先出的顺序读取。<font color=red>一个主题一般包含多个分区，因此无法在整个主题范围内保证消息的顺序，但可以保证单个分区内的顺序。</font> 每个分区可以分布在不同的服务器上，一个主题可以横跨多个服务器，以此来提供更强大的性能。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763001993571_1763001993608.png loading=lazy alt=1763001993571.png></p><p><strong>流</strong>指一组从生产者移动到消费者的数据。框架以实时的方式处理消息，也就是所谓的流式处理。</p><ul><li>生产者和消费者</li></ul><p><strong>生产者</strong>创建消息，生产者把消息均衡地分布到主题的所有分区上，而并不关心特定消息会被写到哪个分区。（消息会根据key来决定会被分布到哪个分区）</p><p><strong>消费者</strong>读取消息，消费者订阅一个或多个主题，并按照消息生成的顺序读取他们，消费者通过偏移量来确定消息是否已经读取过。<strong>偏移量</strong>是一个不断递增的元数据，在消息被创建时，kafka会把它添加到消息里，在给定的分区内，每个消息的偏移量都是唯一的。消费者把每个分区最后读取的偏移量保存在ZooKeeper或者kafka上，如果消费者服务器重启，它的读取状态不会丢失。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763002943557_1763002943602.png loading=lazy alt=1763002943557.png></p><ul><li>broker和集群</li></ul><p>一个独立的kafka服务器被称为 <strong>broker</strong>，broker接收来自生产者的消息，为消息设置偏移量，并把消息保存到磁盘。broker为消费者提供服务，对读取分区的请求做出响应。</p><p>broker是 <strong>集群</strong>的组成部分，每个集群都有一个<strong>broker</strong>同时充当集群控制器的角色（leader）。控制器负责管理工作，包括将分区分配给broker和监视broker。一个分区可以被分配给一个或多个broker，（分区复制）。这种复制机制为分区提供了消息冗余，如果一个broker失效，其他broker可以接管。不过相关的生产者消费者要连接到新的接管broker上。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763003433977_1763003434014.png loading=lazy alt=1763003433977.png></p><p><strong>消息保留</strong>，kafka可以保留一段时间（7天）或者保留到消息达到一定大小的字节数（1GB）。当消息达到上限时，旧的消息会过期并删除。</p><ul><li>多集群</li></ul><blockquote><p>如果kafka数量众多，可以基于一下几点原因，使用多个集群。</p><p>数据类型分离、安全需求隔离、多数据中心（灾备）</p></blockquote><p>如果使用了多个集群，则需要在它们之间复制消息。这样才可以保证应用程序可以多个站点中访问到相同的数据。<font color=red>kafka基于broker的消息复制机制，只能在单个集群中进行。</font> 为了让消息在多个集群间复制，kafka提供了一个叫做<strong>MirrorMaker</strong>的工具。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763003900782_1763003900805.png loading=lazy alt=1763003900782.png></p><blockquote><p>中心A生产者发布一个消息到中心A，中心B中的mirrorMaker读取中心A中的消息，传递给中心C中的mirrorMaker，中心C的maker把消息发布到中心C中。</p></blockquote><h3 id=13-why-kafka>1.3 Why kafka</h3><blockquote><p>kafka的优势</p></blockquote><ol><li>多生产者：可以同时接收多个生产者产生的数据，帮助统一格式。</li><li>多消费者：可已让多个消费者组成一个群组，保证每个群组一个消息只被处理一次（同一个消息被多个消费者处理）</li><li>基于磁盘的数据存储：消息被提交到磁盘，可以有效的错峰，或灾备。</li><li>伸缩性：kafka是一个灵活伸缩的系统，可以随着业务的发展来动态调整kafka应用数量。</li><li>高性能：kafka可以轻松处理巨大的消息流，可以保证亚秒级的消息延迟。</li></ol><h2 id=第三章向kafka写入数据生产者>第三章、向kafka写入数据（生产者）</h2><h3 id=生产者概览>生产者概览</h3><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763105117507_1763105117600.png loading=lazy alt=1763105117507.png></p><ol><li>生产者先创建一个ProducerRecord对象，对象中包含目标主题，发送的内容。（同时可以指定键或分区）在发送对象时，生产者把键和值序列化成字节数组。</li><li>数据被传递给分区器，如果之前ProducerRecord对象指定了分区，分区器不会做任何事；如果没有，分区器会根据ProducerRecord对象的键来选择一个分区。选择好分区后，生产者可以得知该往哪个主题的哪个分区发送这条记录。此记录会被添加到一个记录批次里，这个批次里的所有消息都会被发送到相同的主题和分区上。（一个单独的线程负责把这些记录批次发送到相应的broker上）</li><li>服务器在收到消息后。如果消息成功写入kafka，就返回包含主题和分区信息的响应对象，以及记录在分区里的偏移量。如果写入失败就返回一个报错。生产者可以时情况重试或者失败。</li></ol><h3 id=发送消息到kafka>发送消息到kafka</h3><ul><li>发送并忘记（fire-and-forget）</li></ul><p>把消息发送到服务器，并不关心是否正常到达。因为kafka是高可用的，而且生产者会自动尝试重发，但还有可能会丢失一部份消息。</p><ul><li>同步发送</li></ul><p>使用send（）方法后，会返回一个Future对象，调用get（）方法进行等待，可以得知消息是否发送成功。</p><ul><li>异步发送</li></ul><p>使用send（）方法时，指定一个回调函数，服务器在返回响应时调用该函数。</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763106126189_1763106126227.png loading=lazy alt=1763106126189.png></p><blockquote><p>结果返回时，会调用Demo类中的onCompletion方法</p></blockquote><h3 id=生产者配置>生产者配置</h3><ul><li>acks</li></ul><blockquote><p>指定有多少个分区副本收到消息，生产者才会认为消息写入成功。</p></blockquote><p><strong>acks=0</strong>：生产者不会等待任何来自服务器的响应。（如果中间出现了问题，生产者无从得知，消息也会丢失）<font color=red>发送消息速度最快，吞吐量大</font></p><p><strong>acks=1</strong>：只要集群的首领节点收到消息，生产者就会收到来自服务器的成功响应。如果消息无法到达首领节点，生产者会收到一个错误响应，并重试。在重试期间，如果集群选出了一个新的首领。会时新首领有没有收到消息的情况来判断消息是否会丢失。（收到就不丢失，没收到则丢失）<strong>由于存在消息重试，如果是同步发送消息模式，则可能会影响性能和吞吐量</strong></p><p><strong>acks=All</strong>：所有参与复制的节点都收到消息时，生产者才会收到一个服务器的成功响应。此模式最安全，它可以保证就算所有服务器都发生了崩溃，整个集群仍可以正常运行。<font color=red>吞吐量最差，最安全</font></p><h2 id=第四章从kafka读取数据消费者>第四章、从kafka读取数据（消费者）</h2><h3 id=kafkaconsumer概念>kafkaConsumer概念</h3><p>kafka可以视消息生产消费的速度，来动态的调整同一主题下，消息的生产者和消费者数量。（多个生产者向同一个主题写入消息，多个消费者从同一个主题中读取消息）</p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763108784023_1763108784060.png loading=lazy alt=1763108784023.png></p><p><font color=red>一个分区只能给同一消费者群组中的一个消费来消费。多个分区可以同时给一个消费者消费。如果同一消费者群体中，消费者大于分区数，则会导致一个消费者闲置</font></p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763109012314_1763109012353.png loading=lazy alt=1763109012314.png></p><blockquote><p>两个消费者群体读取同一主题的消息，两个消费者群体互不影响（相互隔离）</p></blockquote><h3 id=提交和偏移量>提交和偏移量</h3><p>消费者每次调用poll（）方法，会返回由生产者写入但没有被消费者读取过的记录。</p><p>消费者向_consumer_offerSet的特殊主题发送消息，消息中包含每个分区的偏移量。如果消费者发生崩溃，或者有新的消费者加入群组，就会发生 <strong>再均衡</strong>，每个消费者可能会被分配到新的分区，而不是之前处理的那个。消费者根据偏移量来获取每个分区最后一次提交的偏移量，然后从偏移量指定的地方继续消费。</p><ol><li>提交的偏移量小于客户端处理的最后一个消息的偏移量：导致消息被重复消费</li><li>提交的偏移量大于客户端处理的最后一个消息的偏移量：导致消息丢失。</li></ol><p><strong>消息的几种提交方式：</strong></p><ul><li>自动提交</li></ul><blockquote><p><strong>处理方便，但可能会导致重复消费</strong></p></blockquote><p>每隔一段时候（默认5s），消费者自动把最大的偏移量提交。</p><blockquote><p>如果在最后一次提交的3s后发生了再均衡，新的消费者从最后一次提交的偏移量开始读取消息，会导致在这3s内到达的消息被重复消费。</p></blockquote><ul><li>提交当期偏移量(同步)</li></ul><blockquote><p><strong>开发者自定义，消息重复程度视每次提交间隔的数据</strong></p></blockquote><p>由开发者自己控制偏移量的提交，通过commitSync（）方法主动提交。（<font color=red>返回结果前，会阻塞程序</font>）</p><blockquote><p>如果在主动提交之前程序崩溃，会导致上次提交前的消息都被重复消费。</p></blockquote><ul><li>异步提交偏移量</li></ul><blockquote><p>开发者自定义，无重试，只会异步发送一次提交，不管提交是否成功。</p></blockquote><p>还是开发者自己控制提交偏移量操作，通过commitAsync（）方法。但提交线程不会等待返回结果，直接继续执行。</p><p><font color=red>需要注意，因为异步可能会产生各种延迟问题。可能后发先至，先发后至。开发者应在回调时，自己维护目前最大偏移量，避免出现较小偏移量覆盖较大偏移量的情况。</font></p><ul><li>同步和异步组合提交</li></ul><p>同步提交速度慢，但可靠。异步提交速度快，但可能会出现问题。程序正常运行时，可采用异步提交，就算某次提交失败，也可以在下次提交时，记录最新偏移量。</p><p><strong>程序关闭，或最后一次提交时，应严格采用同步提交。保证偏移量的最终准确性。</strong></p><ul><li>提交特定的偏移量</li></ul><p>上述提交的方式，都是按照“整批”为维度来提交偏移量的。如果一个批次很大，但消费者想在处理到一半时提交偏移量。就需要使用提交本地map的方式来处理。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>while</span><span class=p>(</span><span class=kc>true</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>records</span><span class=o>=</span><span class=n>consumer</span><span class=p>.</span><span class=na>poll</span><span class=p>(</span><span class=n>100</span><span class=p>);</span><span class=w>  </span><span class=k>for</span><span class=p>(</span><span class=n>ConsumerRecords</span><span class=o>&lt;</span><span class=n>String</span><span class=p>,</span><span class=n>String</span><span class=o>&gt;</span><span class=w> </span><span class=n>record</span><span class=p>:</span><span class=n>records</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=p>(</span><span class=n>如果处理达到1000条</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>consumer</span><span class=p>.</span><span class=na>commitAsyc</span><span class=p>(</span><span class=n>当前偏移量的map</span><span class=p>,</span><span class=kc>null</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=第五章深入kafka>第五章、深入kafka</h2><h3 id=分区和节点管理>分区和节点管理</h3><ul><li>如何注册和退出</li></ul><p>kafka通过订阅ZooKeeper的/brokers/ids路径下的节点来管理broker的加入集群或者退出集群。（<strong>ZooKeeper当做kafka的注册中心</strong>）</p><ul><li>如何选择集群leader</li></ul><p>成为leader：集群里的每个broker都会尝试在ZooKeeper目录下创建一个临时节点/controller，只会有一个成功， 其他的创建失败。</p><p>重新选举：通过ZooKeeper的watch机制，当发现之前leader节点下线后，每个broker都会尝试在ZooKeeper中创建临时节点/controller来让自己当选leader。</p><p>离群分区分配：上面成为leader的broker发现某个分区的broker离开了集群，leader的broker会遍历这些分区，并选出一个新的broker来消费当前分区。</p><blockquote><p><strong>kafka通过ZooKeeper的临时节点来选举控制器，并在节点加入集群或退出集群时通知控制器。控制器负责在节点加入或离开集群时进行分区首领选举。控制器通过版本号来避免脑裂</strong></p></blockquote><h3 id=复制>复制</h3><blockquote><p>在个别节点失效时，仍能保证kafka的可用性和持久性。</p></blockquote><ul><li>主从复制</li></ul><p>首领副本：每个分区的主副本，所有生产者和消费者请求都会经过这个副本。</p><p>跟随者副本：首领副本之外的都是跟随者副本，跟随者副本不处理用户请求，只从首领副本复制消息。（在首领部分失效后，成为新的首领副本）</p><ul><li>同步状态检测</li></ul><blockquote><p>首领副本下线后，只有 <strong>同步的跟随者</strong>副本才有可能被选择为新的首领副本。</p></blockquote><p>进度：跟随者副本通过偏移量来向首领副本复制消息，这些偏移量都是有序获取的（1、2、3、4.。。）首领副本通过获取的偏移量，可以得知每个跟随者复制的进度。</p><p>超时：如果跟随者副本10秒内没有请求任何消息，则被认为是不同步的。不同步的跟随者不能成为新的首领。</p><h3 id=请求处理>请求处理</h3><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763359503504_1763359503534.png loading=lazy alt=1763359503504.png></p><p>生产请求和获取请求（生产者和消费者）都必须发送请求给分区的首领副本，如果broker收到的特定分区的请求，而该分区的首领在另一个broker上，则broker会返回一个非分区首领的错误响应。</p><blockquote><p>客户端需要自己负责把请求发送到正确的broker上。</p></blockquote><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763360924683_1763360924725.png loading=lazy alt=1763360924683.png></p><p>客户端通过元数据请求获取最新的分区请求，把不同分区的请求发送给正确的broker。</p><ul><li>生产请求</li></ul><p>首领副本的broker收到生产请求后：</p><ol><li>发送数据的用户是否有主题的写入权限</li><li>请求中的acks值是否有效（0、1、all）</li><li>如果acks=all，判断是否有足够多的同步副本保证消息已经被安全写入</li></ol><blockquote><p>acks为0或1时：broker会立刻返回响应</p><p>acks=all：请求被保存在缓冲区（炼狱），知道首领副本发现所有跟随者副本都复制了消息，才把响应返回给客户端。</p></blockquote><ul><li>获取请求</li></ul><blockquote><p>kafka的broker使用零拷贝技术向客户端发送消息，<strong>kafka直接把消息从文件（Linux文件系统缓存）里发送到网络通道，不需要经过任何中间缓冲区。</strong></p><p>避免了字节复制，也不需要管理内存缓冲区，从而获得更好的性能。</p></blockquote><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763361582440_1763361582478.png loading=lazy alt=1763361582440.png></p><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763361658504_1763361658557.png loading=lazy alt=1763361658504.png></p><p>分区领主只会给消费者返回已经同步过的消息，还没有完全同步的消息会被认为时不安全的。</p><h3 id=数据存储>数据存储</h3><ul><li>分区分配</li></ul><ol><li>kafka会在broker间平均的分布分区副本。</li><li>kafka会确保每个分区的每个副本分布在不同的broker上。（为了保证高可用）</li></ol><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763364138311_1763364138351.png loading=lazy alt=1763364138311.png></p><blockquote><p>kafka在存储消息时，直接按照返回给消费者的格式来存储。（这样才能利用CPU零拷贝技术）</p></blockquote><p><img src=https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-11/1763364299983_1763364299998.png loading=lazy alt=1763364299983.png></p><h2 id=第六章可靠的数据传递>第六章、可靠的数据传递</h2><h3 id=可靠性保证>可靠性保证</h3><blockquote><p>**保证：**确保系统在各种不同的环境下能够发生一致的行为。<font color=red>一致性</font></p></blockquote><p>ACID是关系型数据库普遍支持的标准可靠性保证。</p><p>如果一个供应商说他们的数据库遵循 <strong>原子性、一致性、隔离性和持久性</strong>规范，其实就是说他的数据库支持与事务相关的行为。</p><ol><li>kafka可以保证分区消息的顺序。先写入的消息一定先被读到。</li><li>只有消息被写入分区的所有同步副本时（不一定是写入磁盘时），此消息才会被认为是“已提交”。（<strong>原子性</strong>）</li><li>只要有一个副本是活跃的，那么已经提交的消息就不会被丢失。（高可用）</li><li>消费者只能读取已提交的事务。（隔离性的表现）</li></ol><blockquote><p>以上几个机制可以用来构建可靠的系统，但仅依赖他们不能保证系统的完全可靠。</p></blockquote><h3 id=broker配置>broker配置</h3><p>管理员可以通过broker配置，来让主题变成可靠的或非可靠的。</p><ul><li>复制系数</li></ul><blockquote><p>每个分区应该有多少个不同的broker了保存副本。</p></blockquote><p>系数越高，系统越可靠。但性能消耗和空间也会成几何倍数增长。</p><p>如果系数为1：下线后只能等原broker上线才能使用系统。</p><p>如果系数为2：理论系统仍可正常提供服务，但一个broker出现问题，可能会导致另一个broker也需要重启，可能仍不能一致提供服务。</p><p>因此，默认推荐复制系数为3。保证一个broker下线后，系统仍能正常提供服务。</p><ul><li>不完全的首领选举</li></ul><p>分区首领下线后，默认会让一个 <strong>完全同步</strong>过的副本上线，但如果所有副本都不是完全同步的，则会触发不完全选举。</p><p>如果允许不完全同步选举，随可以保证系统可用，但可能会丢失部分消息。</p><p>如果不允许不完全同步选举，分区需等待原首领上线后才能提供服务，无法保证系统可用。</p><ul><li>最少同步副本</li></ul><p>决定一个消息需要同步到几个副本上，就认为消息被提交了。推荐为3个。如果过少，会导致分区不可用。（在可用性和一致性之间做决策）</p><h3 id=可靠的生产者>可靠的生产者</h3><ul><li>发送确认</li></ul><p><strong>acks=0</strong>：生产这发送消息，就认为消息写入成功。性能最好，但可能会丢失消息。只要此过程中分区发生了选举，就一定会丢失消息。</p><p><strong>acks=1</strong>：只要分区首领接收到了消息，就认为写入成功。为了保证消息可靠，需要在生产者添加消息重试机制。如果此次发生选举，仍可能会丢失部分消息。如分区首领在向分区副本同步时下线。相对丢失消息数量少。</p><p><strong>acks=ALL</strong>：所有副本同步，才算收到消息。同时生成者也需要添加消息重试机制，性能最差，但最保险。</p><h3 id=可靠的消费者如何提交偏移量>可靠的消费者（如何提交偏移量）</h3><blockquote><p>为了达到可靠的目标，如何提交偏移量可以让出问题的影响最小。</p></blockquote><ul><li>总是在处理完成事件后再提交偏移量</li></ul><p>在一批次处理结束后提交（自动提交或者手动提交）偏移量。</p><blockquote><p>可能会导致一批次数据的错误，需要做好事务，如果提交时系统宕机，则导致批次数据被重复消费。</p></blockquote><ul><li>提交操作报错后重试</li></ul><blockquote><p>由于kafka的消息是按照顺序排好的，如果一批次读取到30和31两条数据，30处理失败，31处理成功。如果只提交31偏移量，会让其他消费者认为31之前的数据全部处理成功。</p></blockquote><p>对于上述场景，有两种处理方式：</p><ol><li><p>提交最后一个处理成功的偏移量（31），把没有处理好的消息保存到缓冲区中（30），调用消费者的pause（）方法让其他的轮询不返回数据，然后尝试30的消息，知道重试成功。成功后调用resume（）方法，让消费者继续获取新数据。</p><blockquote><p>暂停现有消费，先提交处理进度，最大努力重试失败的交易。如果系统宕机，可以从缓冲中获取到失败的交易，继续重试。</p></blockquote></li><li><p>把错误写入一个独立的kafka主题，然后继续。由一个独立的消费者负责记录错误的主题，最大努力重试。（dead-letter-queue）</p><blockquote><p>dead-letter-queue <strong>死信队列</strong>：把错误或失败的数据，单独记录，不影响主流程的正常工作。但对于状态机等依赖前置状态的操作不可用。</p></blockquote></li></ol><ul><li>消费者需根据处理进度维护状态 （<strong>记忆化搜索</strong>）</li></ul><p>对于根据处理情况，来维护或统计状态的情况，要在上述处理后提交偏移量的基础上，并把每次处理的新状态写入一个单独的主题，让状态和偏移量对应。这样系统也方便重启或者从某个节点续跑。（有点类似于大数据的拉链表）</p><blockquote><p>存在一个问题，就是kafka两个主题的提交并不存在事务，可能会导致一个主题提交成功，偏移量主题出错。所以要考虑两者的提交顺序。</p></blockquote><ul><li>长时间任务处理</li></ul><blockquote><p>如果有一个耗时长久的任务，会阻塞消费者线程，导致客户端长时间不能向broker发送心跳，broker可能会任务当前消费者下线。</p></blockquote><p>建议使用一个线程池来处理任务，就算任务线程被阻塞，也会一直有线程轮询broker（但不获取新任务）。这样可以保持心跳。</p><ul><li>保证消息仅被消费一次（幂等性）</li></ul><p>利用第三方键值存储引擎，每次消费kafka消息时，生成唯一的键存入。</p><h2 id=第七章构建数据管道>第七章、构建数据管道</h2><h3 id=构建数据管道时需要考虑的问题kafka的优势>构建数据管道时需要考虑的问题（kafka的优势）</h3><ul><li>及时性</li></ul><p>对于消息kafka充当了一个超大型的缓冲区</p><p><strong>实时处理</strong>：消费者可以通过轮询broker的方式，达到接近实时的数据处理。</p><p><strong>批处理</strong>：消费者可以向kafka发送请求来读取自定义批次大小的数据。（可视业务情况动态调整）</p><ul><li>可靠性</li></ul><p><strong>系统可靠性</strong>： kafka的高可用可以有效的避免单点故障问题，而且动态扩容分区副本，可以让kafka集群达到大规模的高可用。</p><p><strong>消息可靠性</strong>：写入时有同步写入或回调，可以保证写入的可靠性。消费者需要配合唯一键值存储引擎来实现读取的可靠性。</p><ul><li>高吞吐量和动态吞吐量</li></ul><p>卡夫卡支持动态的伸缩，可以试情况动态的调整生产者和消费者的数量。如果处理不了的消息，也可以以极低的成本缓存在kafka中慢慢处理。</p><ul><li>数据格式问题</li></ul><p>kafka本身并不在意数据内容的格式，生产者和消费者可以使用各种不同的序列化器来进行格式转换。所以可以用kafka来实现各种跨不同格式系统的数据传输。</p><h3 id=kafka-connect>kafka Connect</h3><blockquote><p>为在kafka和外部数据存储系统之间移动数据提供了一种可靠且可伸缩的方式。</p></blockquote><ol><li><p>连接器</p><ul><li>决定需要运行多少个任务</li><li>按照任务来拆分数据复制</li><li>从worker进程获取任务配置并将其传递下去。</li></ul></li><li><p>任务</p><p>任务只把数据移出或移入kafka。</p></li><li><p>worker进程</p><p>worker进程是连接器和任务的”容器“。连接器和任务负责”数据的移动“，worker进程负责REST API、配置管理、可靠性、高可用性、伸缩性和负载均衡。</p></li></ol></section><footer class=article-footer><section class=article-tags><a href=/tags/%E6%9E%B6%E6%9E%84/>架构</a>
<a href=/tags/book/>Book</a>
<a href=/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/>读后感</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/java-ontwerp-patroon/><div class=article-image><img src=/p/java-ontwerp-patroon/1.81a9dce623b1d6fe4485ac670cb7da98_hu_d1992426cb16f3b7.png width=250 height=150 loading=lazy alt="Featured image of post 读《重学java设计模式》有感" data-key=java-Ontwerp-patroon data-hash="md5-ganc5iOx1v5EhaxnDLfamA=="></div><div class=article-details><h2 class=article-title>读《重学java设计模式》有感</h2></div></a></article><article class=has-image><a href=/p/icyfenix-hoeksteen/><div class=article-image><img src=/p/icyfenix-hoeksteen/1.9ce725d0528cc3b0d5321b62181de3a9_hu_9ac50c4f106c2b5f.png width=250 height=150 loading=lazy alt="Featured image of post 读《凤凰架构》有感--分布式基石" data-key=icyfenix-Hoeksteen data-hash="md5-nOcl0FKMw7DVMhtiGB3jqQ=="></div><div class=article-details><h2 class=article-title>读《凤凰架构》有感--分布式基石</h2></div></a></article><article class=has-image><a href=/p/icyfenix-argitektuur/><div class=article-image><img src=/p/icyfenix-argitektuur/1.ba219af96a0f1cdca5fb92348980d969_hu_2f661c5d754e7fa4.png width=250 height=150 loading=lazy alt="Featured image of post 读《凤凰架构》有感--架构篇" data-key=icyfenix-Argitektuur data-hash="md5-uiGa+WoPHNyl+5I0iYDZaQ=="></div><div class=article-details><h2 class=article-title>读《凤凰架构》有感--架构篇</h2></div></a></article><article class=has-image><a href=/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/><div class=article-image><img src=/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/1.22118b12382a925a0654108c896ac30f_hu_bc88c47cf792dd46.png width=250 height=150 loading=lazy alt="Featured image of post 读《mysql是怎样运行的》有感" data-hash="md5-IhGLEjgqkloGVBCMiWrDDw=="></div><div class=article-details><h2 class=article-title>读《mysql是怎样运行的》有感</h2></div></a></article><article class=has-image><a href=/p/redis5%E4%B9%8B%E5%89%8D/><div class=article-image><img src=/p/redis5%E4%B9%8B%E5%89%8D/1.22dfb88a230066b648597cf692a0dc8d_hu_779f8ea5939ef931.png width=250 height=150 loading=lazy alt="Featured image of post redis5之前" data-hash="md5-It+4iiMAZrZIWXz2kqDcjQ=="></div><div class=article-details><h2 class=article-title>redis5之前</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//thecoolboyhan.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2026 韩永发的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.33.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.c922af694cc257bf1ecc41c0dd7b0430f9114ec280ccf67cd2c6ad55f5316c4e.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>