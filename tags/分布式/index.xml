<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分布式 on 韩永发的博客</title><link>https://thecoolboyhan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link><description>Recent content in 分布式 on 韩永发的博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 20 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thecoolboyhan.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>从seata源码入手分布式事务</title><link>https://thecoolboyhan.github.io/p/seatatransactional/</link><pubDate>Mon, 20 Oct 2025 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/seatatransactional/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/seatatransactional/1.png" alt="Featured image of post 从seata源码入手分布式事务" /&gt;&lt;h1 id="从seata源码入手分布式事务"&gt;从seata源码入手分布式事务
&lt;/h1&gt;&lt;h2 id="at模式可靠消息队列思想"&gt;AT模式（可靠消息队列思想）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;借用本地ACID事务（硬性事务）数据库实现的分布式事务。&lt;/p&gt;
&lt;p&gt;通过Seata 在内部做了对数据库操作的代理层，让本地数据库操作时会检测全局事务，插入回滚日志等。（&lt;strong&gt;目前仅java支持&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="概述"&gt;概述
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;整体机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大致分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地提交：把业务数据和undo_log（回滚日志）同时在本地数据库提交，本地数据库释放锁和数据库连接。（&lt;strong&gt;没有释放全局锁&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;全局提交阶段：
&lt;ol&gt;
&lt;li&gt;提交事务：异步化提交事务，&lt;strong&gt;释放全局锁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;事务回滚：执行undo_log中记录的回滚sql，回滚后&lt;strong&gt;释放全局锁&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;写隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于同一全局锁的数据：一阶段时，A事务持有全局锁，只要A事务不进行二阶段释放全局锁。B事务就始终无法一阶段提交，一阶段提交的必要条件是需要获取全局锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回滚&lt;/strong&gt;：如果A事务二阶段回滚，此时B事务持有A事务一阶段相同的本地锁，A事务会回滚失败，但A事务会无限重试回滚（最大努力交付），直到B事务由于获取全局锁超时而回滚释放本地锁。A事务又可以获取本地锁，A事务回滚成功，释放全局锁。（&lt;strong&gt;有效避免了脏写&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://seata.apache.org/zh-cn/assets/images/seata_at-2-c7537b8cd8036580215240d037ea4278.png"
loading="lazy"
alt="Write-Isolation: Rollback"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;普通select语句是没有读隔离的，可能会读到中间阶段的数据。&lt;strong&gt;读隔离只对select forUpdate语句生效&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A事务持有全局锁没有释放，B事务for update查询数据时，会尝试获取全局锁，获取失败后B事务回滚（&lt;strong&gt;回滚是为了防止出现死锁&lt;/strong&gt;），然后重试B事务流程。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://seata.apache.org/zh-cn/assets/images/seata_at-3-f5d071f55ecde9189c4f2c0d9dec7f5d.png"
loading="lazy"
alt="Read Isolation: SELECT FOR UPDATE"
&gt;&lt;/p&gt;
&lt;h3 id="如何做到代理jdbc操作"&gt;如何做到代理JDBC操作
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前置知识：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring的类在IOC的过程中（依赖注入）需要创建BeanDefinition，每个BeanDefinition都需要通过BeanPostProcessors（后置处理器）阶段来完成，&lt;strong&gt;通过这两个阶段是判断在创建对象时，是否要根据AOP来创建代理对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seata的AT模式通过创建名为GlobalTransactionScanner的bean，来实现AOP。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GlobalTransactionScanner&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kd"&gt;extends&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;AbstractAutoProxyCreator&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;实现了AbstractAutoProxyCreator从而达到AOP的效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何保证可以拦截@GlobalTransactional注解的类？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring BeanDefinition创建过程中，需通过后置处理器的postProcessAfterInitialization来判断经过哪些后置处理（增加AOP代码或者调用）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Seata实现了AbstractAutoProxyCreator并重写了wrapIfNecessary方法，来对所有有@GlobalTransactional注解的类，@GlobalLock注解，类型为SeataDataSourceProxy的数据库实现代理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;创建代理类的过程中，会全程对于存放所有BeanName的PROXYED_SET加锁，来避免多线程创建bean出现冲突。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="本地事务提交"&gt;本地事务提交
&lt;/h3&gt;&lt;p&gt;SQL执行时：会现在被seata代理的ConnectionProxy连接代理类中的commit方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;检测本地上下文中是否有本lockkey的事务如果有直接返回，表示本次请求已经持有锁。&lt;/p&gt;
&lt;p&gt;持有锁，向远程服务器注册锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有尝试去远程服务器获取锁，没有就注册锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果远程服务器中已存在其他事务获取该锁，抛出以后，事务提交失败，走回滚流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以上获取到锁后，提交本地事务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="事务回滚"&gt;事务回滚
&lt;/h3&gt;&lt;p&gt;当前事务回滚，直接执行ACID的回滚逻辑。&lt;/p&gt;
&lt;p&gt;本地AT事务回滚，查询undo_log中记录的回滚日志，循环尝试执行，最大努力交付。&lt;/p&gt;
&lt;p&gt;并向seata，sever发送当前事务回滚请求，提示让全局事务回滚。&lt;/p&gt;
&lt;h3 id="全局事务提交"&gt;全局事务提交
&lt;/h3&gt;&lt;p&gt;GlobalTransaction 对象向 TC 发起 commit 请求
TC 接收到全局提交请求&lt;/p&gt;
&lt;p&gt;TC 将分支事务标记为完成状态
异步删除各个分支的 undo_log 记录
释放相关资源&lt;/p&gt;
&lt;p&gt;主要实现在 Seata Server 端：
DefaultCore.commit() 方法：处理全局事务提交
AbstractCore.doGlobalCommit() 方法：执行具体的提交逻辑
FileManager.removeUndoLog() 方法：清理 undo_log 文件&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-09/1759133601762_1759133601774.png"
loading="lazy"
alt="1759133601762.png"
&gt;&lt;/p&gt;
&lt;h3 id="selectforupdate"&gt;Selectforupdate
&lt;/h3&gt;&lt;p&gt;对于当前读也是和上面类似的逻辑，获取对应sql，在ACID的基础上增加获取锁，释放锁，提交锁等。&lt;/p&gt;
&lt;h2 id="tcc模式"&gt;TCC模式
&lt;/h2&gt;&lt;h3 id="简介"&gt;简介
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;TCC事务是颗粒度细，但对业务有侵入的分布式事务，特点为运行速度极快，但需预占用资源，回滚方便等。常用于金融核心系统，我们的核心事务正是采用TCC实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://seata.apache.org/zh-cn/assets/images/seata_tcc-1-1f7a834639aa755d73fa2af435c4f042.png"
loading="lazy"
alt="Overview of a global transaction"
&gt;&lt;/p&gt;
&lt;p&gt;需要业务代码自己实现Try，Confirm，Cancel三个操作，对业务系统有着非常大的侵入性，设计相对复杂。性能高。&lt;/p&gt;
&lt;p&gt;事务管理器分 2 阶段协调所有资源管理器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try&lt;/strong&gt;：在第一阶段询问所有资源管理器“准备”是否成功。（资源预占用）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Confirm&lt;/strong&gt;：如果所有资源均“准备”成功则在第二阶段执行所有资源的“提交”操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cancel&lt;/strong&gt;：否则在第二阶段执行所有资源的“回滚”操作。&lt;/p&gt;
&lt;p&gt;保证所有资源的最终状态是一致的，要么全部提交要么全部回滚。&lt;/p&gt;
&lt;h3 id="seatatcc的实现方式"&gt;SeataTCC的实现方式
&lt;/h3&gt;&lt;p&gt;prepare、commit、rollback，三个阶段业务逻辑需要代码自己实现。Seata负责对本地实现的三阶段调度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在我们模拟一个场景，需要两个参与者都做一定操作，都成功才能提交，有一个失败事务就整体回滚。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开启事务：seata标准的开启事务方式，在分布式事务发起前添加@GlobalTransactional注解&lt;/p&gt;
&lt;p&gt;seata会利用上文中提到的AOP方式，检测被@GlobalTransactional代理类中的异常，如果出现异常就回滚。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务提交：SeataTCC事务提交不由任意单个客户端控制，而是由SeataServer统一调度，在所有参与者都资源占用成功后，seata Server统一协调参与者提交事务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nd"&gt;@TwoPhaseBusinessAction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;SofaTccActionTwo&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;commitMethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;commit&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;rollbackMethod&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;#34;rollback&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;每个参与者都如上由@TwoPhaseBusinessAction注解修饰，name为当前参与者“小事务”的名字，commitMethod和rollbackMethod分别表示提交和回滚事务需要调用的方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SeataServer如何做到可以调用commit和rollback？&lt;/p&gt;
&lt;p&gt;同上TccActionInterceptorHandler在代理类方法运行时，ActionInterceptorHandler为占用方法调用前将调用SeataServer的doTxActionLogStore方法，此方法通过状态机来判断当前事务所处的状态。来判断当前调用原有资源占用方法，commit方法，还是rollback方法。&lt;/p&gt;
&lt;p&gt;通过DefaultCoordinator实现调用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下文将详细讲解Seata基于状态机实现的全局事务会话类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="幂等问题"&gt;幂等问题
&lt;/h3&gt;&lt;p&gt;同一个操作，无论执行多少次，结果都是一样的。TCC中，Confirm和Cancel操作可以会被反复重复调用。&lt;/p&gt;
&lt;p&gt;Seata的TCCResourceManager（事务状态管理器）为每个TCC全局事务创建不同的全局事务ID和分支事务ID。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个小事务在资源占用时Try阶段：都会向事务状态管理器发起注册registerResource，判断是否可以占用资源，是否已经做过相同操作。&lt;/li&gt;
&lt;li&gt;Confirm阶段调用branchCommit方法，先判断当前事务是否已经提交，如果已提交就不会重复执行。&lt;/li&gt;
&lt;li&gt;Cancel阶段：调用branchRollback方法，先判断是否存在当前事务，如果不存在就直接返回，存在则执行取消方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="空回滚问题"&gt;空回滚问题
&lt;/h3&gt;&lt;p&gt;在Try方法执行之前，Cancel方法已经被执行了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么会出现这种情况？&lt;/p&gt;
&lt;p&gt;try阶段由于网络延迟，或者消息乱序（同时发起两个相同的try），导致Cancel操作已经执行完毕。此时可能出现重复占用情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCC的Aop类TccActionInterceptorHandler中会调用prepareFence方法来通过向数据库插入日志的方式来检测当前事务是否已经存在，如果插入失败就直接返回，不执行Try阶段代码。&lt;/p&gt;
&lt;h3 id="悬挂问题"&gt;悬挂问题
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;假设有A、B两个分支，Atry成功，B由于网络问题无法Try，等全局事务回滚后，B又成功Try。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Seata利用上面提到的日志机制，记录每个分支状态，（已try，已cancel等）来防止悬挂。&lt;/p&gt;
&lt;h2 id="saga模式状态机"&gt;Saga模式（状态机）
&lt;/h2&gt;&lt;p&gt;Saga 模式是 SEATA 提供的长事务解决方案，在 Saga 模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。&lt;/p&gt;
&lt;p&gt;&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAb0AAAG8CAMAAAB9rIvTAAAIwnRFWHRteGZpbGUAJTNDbXhmaWxlJTIwbW9kaWZpZWQlM0QlMjIyMDIwLTAxLTA3VDEyJTNBMjMlM0E0NS41MjlaJTIyJTIwaG9zdCUzRCUyMkVsZWN0cm9uJTIyJTIwYWdlbnQlM0QlMjJNb3ppbGxhJTJGNS4wJTIwKE1hY2ludG9zaCUzQiUyMEludGVsJTIwTWFjJTIwT1MlMjBYJTIwMTBfMTFfNiklMjBBcHBsZVdlYktpdCUyRjUzNy4zNiUyMChLSFRNTCUyQyUyMGxpa2UlMjBHZWNrbyklMjBkcmF3LmlvJTJGMTIuMy4yJTIwQ2hyb21lJTJGNzguMC4zOTA0LjExMyUyMEVsZWN0cm9uJTJGNy4xLjIlMjBTYWZhcmklMkY1MzcuMzYlMjIlMjBldGFnJTNEJTIyT0hZZnpnOGdHY3N4V2tkek1EMEolMjIlMjB2ZXJzaW9uJTNEJTIyMTIuMy4yJTIyJTIwdHlwZSUzRCUyMmRldmljZSUyMiUyMHBhZ2VzJTNEJTIyMSUyMiUzRSUzQ2RpYWdyYW0lMjBpZCUzRCUyMjhWczRpZ09wTWhPZDBTQzJNc2dCJTIyJTIwbmFtZSUzRCUyMlBhZ2UtMSUyMiUzRTVWcGRjNXM0RlAwMWZzd09RbnclMkJPbzZUN1d6YTZVNDYyJTJCMmpBckt0TGtZZUljZDJmdjBLSXd4STJCQnFqSk8lMkJlTkNWRU9qYzQzdnVGUnJCeVhMN3dOQnE4Wm1HT0JxWlJyZ2R3YnVSYWZxV0kzNVR3eTR6T0o2UkdlYU1oSmtKRklZbjhvcWxNUiUyQjJKaUZPS2dNNXBSRW5xNm94b0hHTUExNnhJY2JvcGpwc1JxUHFVMWRvampYRFU0QWkzZnFkaEh5UldUM1RMZXglMkZZakpmNUU4R2pwJTJGMUxGRSUyQldLNGtXYUNRYmtvbU9CM0JDYU9VWjFmTDdRUkhLWFk1THRsOTkwZDZEeSUyRkdjTXpiM1BBUSUyRnZWUHRQbk9qT25OZW1xdnZkMXVQTDR4WVRiTkM0cldjc1h5YmZrdWg0RFJkUnppZEJaakJHODNDOEx4MHdvRmFlOUclMkJGellGbndaaVJZUWx5RktGdnV4YVdOR1l5NWRDanpSMWw5WnJ1SUZNNDYzSlpOY3dnT21TOHpaVGd5UnZkQ1FieXo1QktDRWQxTjRCempTdGloNUJocVdaSVZreFB3d2R3R2F1SkM0dlFGRDRMd3pESDJnUUFqYVFXZ1pmbDhRYWdoJTJCQXljd0JNMFlxckROU0JSTmFFVFpmaTRZMnRnTExXRlBPS1AlMkY0VktQWno1RHh6a1AwQ0NQWWpuU2RnMVp6UnFrYyUyRlRQRDdUWHpGVWNpZ2dvbTVUeEJaM1RHRVhUd25wYlpYTXg1cEhTbGNUJTJGSiUyQlo4SngyQTFweWU5czVSckJPNlpnRSUyQkZjQ2tKaUEyeDd5WlllbmFUbnFPNFFoeDhsS04lMkZtZDNnNm56JTJGVlRNZUs5OFAlMkZCNE1MN3I4dllOZmtDZ1laNTFEQWEwcFFNZGYwQ2dMWGRvUnR2TkFWeGttcXYwY2hiaDdUak5nUVVXT0E3bDVWMFFvU1Fod1dtMDhaYndmOU1BJTJGNGN0V3olMkZreVBUNmJpdGolMkY3NnhrdzNWUXdoN3M2RE9RMDdnNGVmWkw4WDl2QlpvaXZ0bXk3aGY4cWRkNDg3YzFsb2U1Qk8lMkJVaUpXVm1TdnB2SyUyRmhRcE5zblhMdThySnZEcVJxMFJhVDVrb0EwYWJhRSUyQjV3N0s3czdCRnlqc1VDd1dWMks1MFU5cjhVZTRyYnR1M2htQnYyNndGWGhWN2dhZVF6dXpJWHVDcThuVlo5cm9YWW05SEpsNTc3SVV0Mld0ZEZYdE5xRWk1ZFNiMldxNXpVZmJxSmR5azMySjU1Z1U0cUNYVHMyZGJ0bkdtblIzejZvcGxRMGU2M3pKdEdLU0hMOU9BdmdFMDZiZE9Hd2JwNGVzMDBHTER0NlJ6TVkyeHVpUFpJbDhESmQwcVZLd3BYNnRvWkNHWlIxU3l1MzYxclIyOHE5WXZzNnQlMkJtVW9hQiUyRnpMWmw5QTN5czRKd1U3MHFrTGRidFRzRzBCa0V2UXRYRFFha2pjVzNQUVZ5WUNGJTJCWmdpMjJVajg3QnRtbDhMczdYd2tFMSUyRlZiRFYlMkJzOUZMT2hJT2liZzNvWmVqJTJGJTJCOVBpa0VUR3ZSUU1VUlhUTm0zT2ZGV1pFdkIxbXhVMWZDNU5HMXhWTkNDYzBOaVdsR09Vb2JZdW1YMU5iM3Q4N3puNSUyRjlYanF0S0NNdklxbm9FaE9tV1NQcyUyQjNTNCUyRmJraHNMd2pKSzAwJTJGVFBrM1JwaFo1Wms5NGFOUVFGME80cjYlMkZLYncwMSUyRiUyQjJYR3lRRHk5c1Q0Mkw0RzZDOWpNOTVseW1ZNVNzcldkY05NbThpOWJLaks2ZG8zZjMlMkJKaTRabFZlWFdTeDF6V25EVFZpazBucVpwODhlRzY5cXYxYkkxOVNOQmE2VTBsSW5VenhaOTAwJTJCdkdMNVF0a1Rwalp5aE9FRkJLaWlKeGttaEdMekt1Q3FUWkY1WHBwMDBvWWpNVTRVS0JBbjJvcG5xRHhGaU9wWWRTeEtHJTJCOE1RZFZwY1BTRFJ3eEVlejZrNHhIZDFoWE5yaUtYR24lMkZNZGFORHo2UWxkcnJCd0RTZnglMkZMZjFrMXJuMURqcThDODl0Nk51bHk3M1h1eFA4ZVBUbDFkbiUyRnZuRyUyQnR1cU9YbHlmWUc4UTFLaFJOd2FydzMyeWRmMXE3RXozd0o4JTJCeWRmWlNLZ1ROUTVDSXRtY1F3MUcxNmM1WVhUJTJGd0UlM0QlM0MlMkZkaWFncmFtJTNFJTNDJTJGbXhmaWxlJTNFL3urqwAAAD9QTFRF////g7Rnfn592qimAwMD2uj8uVVR1ejU&amp;#43;M7M/2Zm211cMCsrq7ilxNHAV1BP8vHx0YaDcpPCrcHflZeU5rq4RH8w0QAAFQJJREFUeNrsnYu6myoQhbORar6CYra8/7Mebiq5eRoDMuqatmkSRRmXjL9gmMsFBoPBYDDYMaxp2&amp;#43;YMfjIuvL&amp;#43;8&amp;#43;6CUECq8U&amp;#43;t3bYoq0WXwqeXWusT6/X91tz8WjPPhY/WU4KGmkrdrK2yLKiHSizdwLgbj1/qqratugWNhvWyKqXdRKkfLk15EoRKrt1zdAsfCqtdN6jVdiDjD0HRCmVfWdY1inXANtGVCsDZSb&amp;#43;h4J8PK09KLK&amp;#43;ZKqEEIIeOibh&amp;#43;CNVPRh70&amp;#43;FfzYBJfjm&amp;#43;Zx27Mvg2w70bkKKSY61vxPvefqzmtd7BZbOVyKHQvGW2Fjp1NPmpLCnrpGHtsm3Wswdr9YhTZovvIrq4fCroStCr/bsns3brtzsX6x4OfAMjU5ey4/bTvswNece8&amp;#43;dLddbTdWN1pJhc&amp;#43;WOBeNNY2OnVU&amp;#43;JsEll3onWvnbKts7WhKPObqa9uHf3kdOvfLfUFJPmnTsl3MrzQldtZg6bL/qw16eCK9Tr7kL83bYnX&amp;#43;xHv&amp;#43;ASVhFqsd5xdcNazhXV8YLHwrQ988&amp;#43;vI63S7ivloo4vIh3W2LdSXt6oZ5v641LzatqB3UwbFfX7UGKu8d1enwp&amp;#43;p97jtidflKdmsyCs/2b3U73jAxzWGl0peCyY36X06klfC&amp;#43;md8xTkPA7OM9fGn2rsY9W8VPgtKx9NZLzQH7&amp;#43;56MNenwt&amp;#43;oZ562vbkS8Bz89nGKmPcHrCFekfqjWsFSmEFjwXzzVj4c6ENm/LyeBcjj81W2PCq7fnTZFraTV7Jzl0H5qIzmM01nvf6VHDFndN03TMR6nHb79WzQLNU70i9blG9TY&amp;#43;FUy&amp;#43;QZzgX2Bv1GhuJzdF5rV68dNyxbe7KUNQwL/T7UOZcmms87/Wp4CrmHIKMvHnc9qN6A29bH6yadrneL9WTryLnlsfCq&amp;#43;fOB9sE3a7d&amp;#43;fFKPeYcfqfevHT2b/AbmBf6fQzRlTre61PB9fd7jksetx3HEbOSgb3Gt1V7vVqs9wv1/MYZL3gsurGteqjkUlqMfqMeZ9IGYRmr18mxxvPS6bQx37UDd1gbFrp9MEu5vuj9Xp8Kruv8830t9kA8bPvuKjAMDsjZ&amp;#43;G653mN1o5Bm7zg6zgseCxa&amp;#43;ZY5LbQT1WCYi9WT4wt3ftOYGU039nC2fPkVL/Y7HEgGC/cKwj3YsGu/1VcF1PRfuTkldnrY9&amp;#43;WJb5rjOEO6rluvdhOpGa7mSbOrgKn8smqZZIAXVNJfHHh21vHTcYLRQjbtQC3tVyzX5dzdeb8fpMNVjYfdxvZ/2oux3UecyyWNxQEsxuNGE6x7D4dyheq4LS6y8OMO&amp;#43;UY8NCTYyCC4YYhoMBoPBYDAYDAaDwWAwGAwGS21sHHMl&amp;#43;wpPF3w6z3l6QJ/4aY75ET3lpzm7jugpO4165/EUVyt4CoPi8BTMCeYEc4I5wZxgTngKg&amp;#43;LwFNEWzAnmBHOCOREFcbWCpzAo/j&amp;#43;etvJH/mxhZj9tWp/eRFvd9329hZn96KLM2ZhD2jbbWGtOlCY7c17rvtLXbUxXfX0tx5xSNtva2&amp;#43;aXijmr/rqt9VUp5txcPCOfzOrp5uItyZf3utxsL56Rr8noqd5ePCPftQjJ/DQl7CdjPKmvJawuwZytLKJeOvLkJJqeaXy6AHPKtoh6rczGnH1VRL2qL8CcP4XU&amp;#43;8nGnL0uop7Ort6Lc7tM4DShM5unZQKnCZ0FmPOnkHo/2TytC6mXH1uIq5cknhxWPXZA9Thx9bIy5&amp;#43;4jJ3X1&amp;#43;GnU4weMnPw0kZMfkFrAnGBOMCeYE8wJ5gRzgjnBnGBOMCeYE8wJ5gRzrlNPV1V1BuZs52y8bmxQsv0zp&amp;#43;58IqpxmJwdljnlg3qCt3tnTu3SU9pENf6z4PrIzNmOkrU2IV27d&amp;#43;YUvLNyVYIP5tW6pA/NnKN6Lkt4u3PmlFz4N4NtfM4lfWjmnNpeK1OqV4Y5O9vkfAi1/3RFVD2WWr31170u2wStK9SrHiOpPipzJlKPEHPmVY&amp;#43;fRj1eKHKO6ml9BuakpN731MLG614V8EWchDkJRM7v1Ru40EFGll69y2nUK9TPGe73Bh5CqDgNc7al1UvQU2ZuEXjHzI3eMHa9gDn3189ZnYQ5Dze2rquvZynA2DrG1jG2jrF1jK1jbB3Pc&amp;#43;J5zl2rB&amp;#43;bcc&amp;#43;QEc4I5wZxgTjAnmBPMCeYEc4I5d82cmCsplfUlmJPSPGVJPP1La56yrEZqjsAk8YTYHIFZmRPzc6YKnCXm5yQ1N26aOeFpzY2bd054SvNSp5kT/kpqXurMc8IXiJ3v4ibmhP/cNpfvp83sKaV8DNmNTC6UZPGEUC6UzJ765vdpHqJhNOQhKpyHaIXdfke7bXF2beKTkbzWyVsMxdyXtz&amp;#43;j3Qp7mpAKDDimT2lCMfclHfUSWp1jlI5ifsA86pX1tHY/fK4vx7c86hVVPPSP5u&amp;#43;vPGrkLBltp3vExPduJJmTTORM5FPUvZaWXMCc&amp;#43;c9tFXdt1wrMuSvmrLM9HgbmzG4PecPokguY8wWxPA7HVxXBYw7mfGkvRuN7Te&amp;#43;Ygzlf4ubfFyMHf6/kjjmY8/&amp;#43;JJTW5gDmz2psnCPVfMCd9T98&amp;#43;QHhg8DwMcy48RNETA08w5xOx9GueEwNzkmBOZR9s8KajZ9pHS9FlBubMd25Xk83kWc9fgjmpM&amp;#43;fTfUPa8Vkw557VA3NuoTh99cCce46cYM7t1QNz7jlygjnBnGBOMCeYc7&amp;#43;e/s6/PZnVm78Ec1JmThUpNakXKapKeArm/Ff7Mze5Z7v9AXPSZs6ozT1aisAJ5sxrb&amp;#43;VLctUDc24Gmw9xE8y5B09vtMQDc35PLgmIBcy5yZZeXPp&amp;#43;m3L1A3N&amp;#43;KV&amp;#43;y&amp;#43;3Qw5xbk8pvpogfm3B48y/Z0gjk/NRXLd1NFfQJzfgOeiXATzLnhliZySTqyAObciAqCfGmHhcCc25LL7TCenmlsPch3K18NMOdacklJLGDOba8rv7dfAmdXMvXmXw7tjTk/nxt3pS3PjZuQOcnMjZudOcnMS53MU0LzUucmMSmpJELBnPD0xTPyyazXSlL5GPJSAaVcKGmu5ZpULhTkIfrMpxPlISKVAywJcxLLAZY39yWl/Htpcl/Syr&amp;#43;H3JefqXem3JeU8s4miSfE8s5mZU7kW0e&amp;#43;deRbR7515FvfdeRM4ulhI&amp;#43;flgJGTunqX06h3OWDkBHOCOcGcYE4wJ5gTzAnmBHOCOcGcYE4wJ5gTzLlOPV1V1RmYs&amp;#43;WTyaaRjLFh98ypO&amp;#43;cP84Pk1qWjMqeM1WPuf7Fz5tSC844ZBTvzwbvU6eMyZyt4G5QcWik42zdzCi9WJfhwtS5p844dmDmDeswGT6Nht2vmlFz4N4NpfIzbqFm5ZnhU5gzqde6/Npl6ZZiz4&amp;#43;NlTtsPVVr1OFn1vLE16pmrjNGK3b/yp29WvK5Q7wk3GUX1WAb1zGWPt7tmzif1zGWP62My5716rWlDot03c87qaR1uH4S&amp;#43;Hpc5J/Wkv&amp;#43;vbdz8nG697lcWXyrp07H7OoJ65c2cp&amp;#43;1rKMOcwNjVm7hMqvuJmYa/MOTQp1SvUzxnu9wZuQugMoIdnThE6XbqC1JLgbt0Gy44ZZwarZHDp&amp;#43;MxJQb2E/ZzVNYN6GFvPP7auq69nKcDYOsbWMbaOsXWMrWNsHc9z4nnODagFz3PieU4wJ5gTzAnmBHOCOcGcYE4wJ5jzcMyJuZJSWV&amp;#43;COSnNU5bkWv6X1jxlWZmT1ByBSZiT2ByBmJ/zo3hypvk5Sc2Nm8ZTWnPj5p0TntK81Gk8vZKalzqzFYidSxk1EsSTE80JX0C&amp;#43;n4TivYy2lPIxZM9DRCYXSrI8RIRyoZDMQzSMhjxEhfMQrbDb72i3zFFwOzPkkYE9KOa&amp;#43;vGXJ113W0/p6kryXmdQrqnjtfv5FWD52QPVSRdvQwVb1ZI85J65ewdyX001G6js3fhr1yuVbj/pnEpMLSeYko14SU3HfaK3AnLvytC4&amp;#43;Sg7mXE8s&amp;#43;p8GWsGcFJnzaTw3JbmAOfP69GI4d7nzC8xJhzmbv1mH68CcGxJLcnIBc&amp;#43;a0N4&amp;#43;g6b9gTvok9vYJtORdZmDO5NF2YRQ&amp;#43;EXiCObP5tPgAUxpyAXPmOreVHRn3pqN79dGSdJmBObNZNdlMnvX8JZhzJ57W5&amp;#43;nlPODY&amp;#43;g7UA3Nurx6Yc8/qgTn3HDnBnHumFjAnmBPMCeYEc&amp;#43;6XOX/nXy/M6s1fgjkpM6eKlJrUixRVJeoH5vxX&amp;#43;zM3uWe7/QFz0mbOqM09WoLACeYsJV8K8cCcuT19FzuLoSeY83v5bsU8BXN&amp;#43;TS4JiAXMuYmnzW&amp;#43;2ix6YswC5JCMWMOcGdruX77doZxmY8ztyKdvTCeb81FQs300V9RTM&amp;#43;Q14JsJNMOeGrXgil6R9LGDObcEzbQfZv3p63ZF6RMGzHLFUtQZzJpCvDG5WffT7HjDnWnJJSSwfeFr10a/rwJwrL3231KNC/J/Vu&amp;#43;rxBz6pIuf8y6HdMefns6uutCSzq/qfTNaL7EJmdtXszLm3mY3DD14XftxKaGbj3Lb5rOLfTgk//ly5798oTmlW8cxUIAvM6C&amp;#43;TqHetzMWPExBvSb68zLnDbBqROvX12Sda2TTyMifNTDbK/nV/Xljctnq2AP8UMtlkZc7yWaSun3NeDCR9/0SbpLJIZWXO8hncvr1KPU6LQyyDW1Yrnz3xa8bQ98De08qemJU5y2cuTUCId1GLWObSg&amp;#43;dbT8H3MbAj3/re1IsPHfKt7029&amp;#43;MqHfOv7Uk/fTSh2pnzrB1DvgdUPq96eI6e2f8c/14Xb9cNGTpLUsqKvJb4fr/WFtHoHZ87PPY36wnTNLmdRjx1Nvaq&amp;#43;XIird3Dm/NzTSb2&amp;#43;v5BX73Ia9T4dW69eKQ7mpK1eaHv&amp;#43;Fp2fJnLyA0XO8Radn4ZaDsSc0y06mHNn6pnrXv9&amp;#43;NG2VerqqqjMwZ8snk00zMMbk9pHz78IDsCvU053zh4UnZRirjsqcMlYveL01tcRDCgkipxacd8z40pkPsZDHZM5WcPdABeNCtoNrhFuqtxxtP1dP8M52nVaCD1fj0n/tndmWoyAURauVpiuoZND//9YWcJ4SEeRizn1Ip2rVyuq4w2EDBtKqfkvphZ2zoSf1P6UzekkQejnLzJOybnySVfpZemHnbNueLDTD/Fxr2Sa&amp;#43;m56sm1y3jpHoZigp0ksc01PdYClZZnFfWt291P&amp;#43;bZPzIZr&amp;#43;xeLSgN0aVqrdUXdM5J/TqDp9l/wIm54&amp;#43;DtpdOukHWZuk15zl7eoWyliSgtSQO6VWVGfuVNtIZzzxnQ8986y9nMmrnTNp&amp;#43;L62bnPnaX6oHD9d2zsJkZuGMXhjnLNteLmFJZTKzckePrnNm2jYTZ/TCOGc73tOjvEzHaEKRnuvkVJJXC1rQEYODmbKUqbmWWlZKxc28pfQLnDNp5ztjds5unjM18dk9vfzaepFbfoWMkHM2awzV/CnW1iOY58TaesTOibX1qJ0Ta&amp;#43;sxOyfu54zaOXE/Z9zOifs54ZxwTjgnnBPOCeeEc8I54ZxwTqJ7Jbnuy79qr6Tg&amp;#43;5S5dk5i&amp;#43;5R5dc7wewS6dk5iewRefH9O1&amp;#43;/0m/bnJLU3rpt3yr9GOWntS&amp;#43;0mT2jtS&amp;#43;3VOYNk59Et/d&amp;#43;k7RftCU/pPAZXZ19SOo/B&amp;#43;zlEZM5CcXb2JaGzUEieQ1S2FeAcos/M81vOIbKo56utp&amp;#43;9&amp;#43;GeWeHpHzur&amp;#43;JeHJBeuxrrjkjTi&amp;#43;5ID32NfQsnfP4t6U9PmZfk5zU2xGsBQYSHz3LWcDUccE5rejxx90GHhdOi0eNL5y13Dl/7P90peLmtATo2fV7d/7BJ5&amp;#43;BHlHn/BU3wSvQi9Q5qxqF2D6ZHMlJd8Sg8N3EnkVo0CM0Wjcwdugn6FGaKTM0xKp&amp;#43;Ijkp0/t5GBxr&amp;#43;glrIZycPb4V/QQ9utYywreon0hO4vR&amp;#43;eiDv9RP0XCbnq7&amp;#43;bpafX//KzF&amp;#43;H91Xynn6Dn0FruA1IdvQHR&amp;#43;258E/1Ecvp0zr99k5vX8&amp;#43;&amp;#43;nL8OHF3Son7AWr845aHPT&amp;#43;jQ4VRvmo0va6yfo&amp;#43;a1VfDvgTfH1&amp;#43;onkPE02J7m561V&amp;#43;&amp;#43;eSyLusn6LkerT8dwNPrReNa1E/Qcz1TtmgunxtLW9UUjNJPJKf3ec6Fru9l8WXKGb6aXwZ63uc5Z/h2GcsWmunsJ&amp;#43;j5MJfXsU5vg8149hP0/Iun9f24jyU4Q/0EPffJqabMhvDuP07xDfQT9Jxby0Q89&amp;#43;vmW3zd7CfoeaHXm4udsXS1gqeZ/QQ9H8nZ4zsIbzxjPdNP0PNrLse/QcRXLzX/BT2v&amp;#43;Fx8/YuvX2wOen6SU5vLIWPpBJbfzipYy6Dre76cvM55&amp;#43;C5Kb/9uO5a1uNvOLwc9&amp;#43;&amp;#43;QMvtPVrwA928rD7zJXCdCLBF6NLw&amp;#43;D73rJSWR31VSAnoW1UNnZ&amp;#43;Ax8l6NHZ1fxhwC9vclJaEd///guZy2UTtPwju9y9EidZAN6O5OT1ilSHPR2WQuxE9xc4RNCgN75pye&amp;#43;wZexptQPkmXmt5KJm2h/UHfG6D/hSM6z6b1ZcGBDeh0hWf87oCcZk7zmnF3fOamdfbmNL2Ni1MLkAj3B9B&amp;#43;JeesDPe9nX26uF5lG15LkzY9TerKhy5Gcp59curVelPX0FK7MAJq1PQ7nDHZq8MaCQ92ZSVXCNC1ukE36PaU2GeegF&amp;#43;bE7nV8rXPyJkRNPzihd&amp;#43;PmzyScM8h566sLDrWQ6NLOIrk0ITmlp8Z7iiCsJcx562v4&amp;#43;n5vOPIb0&amp;#43;PNjYR8NmQAvZPOW1&amp;#43;Zse6cUw8L6kaovWVMr1GZSWtEcp5IbwVf1/Z4NyyQs7ZnxnuXa3ssmuRU&amp;#43;DbbXjts123Q0GtKqFDVXSIToBfCWlYXHNq2N85JM8/Z0VNTZWrQIOCcs3XVbqqR5X7pHVlwuOIagwtryT3SSzwv94Gebn8ZK3xby&amp;#43;awD2vrR/q9hl4u81JmsgC9qKyloVc2EVp4Sk7Q80yv/FdImw7wE2sBPa/JWbKkewS9aGbKOnq5ttAEyRktvcIZPVjLucnptu2B3rnW4rbtITnPp5fDWiJOzqIeNoAeVmeRnDHTg7Wckpygh9VZJOel6MFaYk5O0INzgh6sBckJenBO0INzIjlBD9aC5HRWpPZKgrXsTU5C&amp;#43;5SB3l5rIbRHIJJzNz06&amp;#43;3PCWvYnJ5m9cUHPpojsS43ktKsA2bmcm7CW/ckZAN&amp;#43;fD&amp;#43;GB3jtr0eEZ&amp;#43;iwUJOcBeqHPIYK1HEhOup8u0Iv50wV6MRfoxZScoGdlLUhO0IO1wDmH9LhwW7CWMz9dqePCJUaF&amp;#43;mwzltB&amp;#43;RC3Vf0JS/0ulA6hDAAAAAElFTkSuQmCC"
loading="lazy"
alt="Saga模式示意图"
&gt;&lt;/p&gt;
&lt;p&gt;适用于：流程很长的事务，无锁，且一般无法进行资源占用的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：无法保证隔离性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过状态图来定义服务调用的流程并生成 json 状态语言定义文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态图中一个节点可以是调用一个服务，节点可以配置它的补偿节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态图 json 由状态机引擎驱动执行，当出现异常时状态引擎反向执行已成功节点对应的补偿节点将事务回滚&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意: 异常发生时是否进行补偿也可由用户自定义决定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://seata.apache.org/zh-cn/assets/images/demo_statelang-90f1fc01bfaf3a795c3b3357e1046f16.png"
loading="lazy"
alt="示例状态图"
&gt;&lt;/p&gt;
&lt;p&gt;状态的的运行和流转是根据json文件来执行的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;span class="lnt"&gt;43
&lt;/span&gt;&lt;span class="lnt"&gt;44
&lt;/span&gt;&lt;span class="lnt"&gt;45
&lt;/span&gt;&lt;span class="lnt"&gt;46
&lt;/span&gt;&lt;span class="lnt"&gt;47
&lt;/span&gt;&lt;span class="lnt"&gt;48
&lt;/span&gt;&lt;span class="lnt"&gt;49
&lt;/span&gt;&lt;span class="lnt"&gt;50
&lt;/span&gt;&lt;span class="lnt"&gt;51
&lt;/span&gt;&lt;span class="lnt"&gt;52
&lt;/span&gt;&lt;span class="lnt"&gt;53
&lt;/span&gt;&lt;span class="lnt"&gt;54
&lt;/span&gt;&lt;span class="lnt"&gt;55
&lt;/span&gt;&lt;span class="lnt"&gt;56
&lt;/span&gt;&lt;span class="lnt"&gt;57
&lt;/span&gt;&lt;span class="lnt"&gt;58
&lt;/span&gt;&lt;span class="lnt"&gt;59
&lt;/span&gt;&lt;span class="lnt"&gt;60
&lt;/span&gt;&lt;span class="lnt"&gt;61
&lt;/span&gt;&lt;span class="lnt"&gt;62
&lt;/span&gt;&lt;span class="lnt"&gt;63
&lt;/span&gt;&lt;span class="lnt"&gt;64
&lt;/span&gt;&lt;span class="lnt"&gt;65
&lt;/span&gt;&lt;span class="lnt"&gt;66
&lt;/span&gt;&lt;span class="lnt"&gt;67
&lt;/span&gt;&lt;span class="lnt"&gt;68
&lt;/span&gt;&lt;span class="lnt"&gt;69
&lt;/span&gt;&lt;span class="lnt"&gt;70
&lt;/span&gt;&lt;span class="lnt"&gt;71
&lt;/span&gt;&lt;span class="lnt"&gt;72
&lt;/span&gt;&lt;span class="lnt"&gt;73
&lt;/span&gt;&lt;span class="lnt"&gt;74
&lt;/span&gt;&lt;span class="lnt"&gt;75
&lt;/span&gt;&lt;span class="lnt"&gt;76
&lt;/span&gt;&lt;span class="lnt"&gt;77
&lt;/span&gt;&lt;span class="lnt"&gt;78
&lt;/span&gt;&lt;span class="lnt"&gt;79
&lt;/span&gt;&lt;span class="lnt"&gt;80
&lt;/span&gt;&lt;span class="lnt"&gt;81
&lt;/span&gt;&lt;span class="lnt"&gt;82
&lt;/span&gt;&lt;span class="lnt"&gt;83
&lt;/span&gt;&lt;span class="lnt"&gt;84
&lt;/span&gt;&lt;span class="lnt"&gt;85
&lt;/span&gt;&lt;span class="lnt"&gt;86
&lt;/span&gt;&lt;span class="lnt"&gt;87
&lt;/span&gt;&lt;span class="lnt"&gt;88
&lt;/span&gt;&lt;span class="lnt"&gt;89
&lt;/span&gt;&lt;span class="lnt"&gt;90
&lt;/span&gt;&lt;span class="lnt"&gt;91
&lt;/span&gt;&lt;span class="lnt"&gt;92
&lt;/span&gt;&lt;span class="lnt"&gt;93
&lt;/span&gt;&lt;span class="lnt"&gt;94
&lt;/span&gt;&lt;span class="lnt"&gt;95
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Name&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;reduceInventoryAndBalance&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Comment&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;reduce inventory then reduce balance in a transaction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;StartState&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ReduceInventory&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Version&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;0.0.1&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;States&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ReduceInventory&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ServiceTask&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceName&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;inventoryAction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceMethod&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;reduce&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CompensateState&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;CompensateReduceInventory&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Next&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ChoiceState&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Input&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;$.[businessKey]&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;$.[count]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Output&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;reduceInventoryResult&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;$.#root&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Status&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;#root == true&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;SU&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;#root == false&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;FA&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;$Exception{java.lang.Throwable}&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;UN&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ChoiceState&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Choice&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Choices&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Expression&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;[reduceInventoryResult] == true&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Next&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ReduceBalance&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Default&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Fail&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ReduceBalance&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ServiceTask&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceName&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;balanceAction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceMethod&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;reduce&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CompensateState&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;CompensateReduceBalance&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Input&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;$.[businessKey]&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;$.[amount]&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;throwException&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;$.[mockReduceBalanceFail]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Output&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;compensateReduceBalanceResult&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;$.#root&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Status&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;#root == true&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;SU&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;#root == false&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;FA&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;$Exception{java.lang.Throwable}&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;UN&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Catch&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Exceptions&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;java.lang.Throwable&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Next&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;CompensationTrigger&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Next&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Succeed&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CompensateReduceInventory&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ServiceTask&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceName&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;inventoryAction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceMethod&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;compensateReduce&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Input&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;$.[businessKey]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CompensateReduceBalance&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ServiceTask&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceName&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;balanceAction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceMethod&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;compensateReduce&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Input&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;$.[businessKey]&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CompensationTrigger&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;CompensationTrigger&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Next&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Fail&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Succeed&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Succeed&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Fail&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;Fail&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ErrorCode&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;PURCHASE_FAILED&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Message&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;purchase failed&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;整体流程&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;开始 -&amp;gt; 扣减库存 -&amp;gt; 判断库存是否成功
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ├── 是 -&amp;gt; 扣减余额 -&amp;gt; 成功结束
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; └── 否 -&amp;gt; 失败结束
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;异常情况 -&amp;gt; 触发补偿 -&amp;gt; 执行补偿操作 -&amp;gt; 失败结束
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-json" data-lang="json"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt;&amp;#34;ReduceInventory&amp;#34;&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ServiceTask&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceName&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;inventoryAction&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;ServiceMethod&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;reduce&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;CompensateState&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;CompensateReduceInventory&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nt"&gt;&amp;#34;Next&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;ChoiceState&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;类型: 服务任务 (ServiceTask)
调用服务: inventoryAction 的 reduce 方法
补偿状态: CompensateReduceInventory
执行成功后进入: ChoiceState&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Seata通过读取上面json文件中的属性，来对目前的调用进行流转。每种状态保证都有自己的执行逻辑。（是否补偿，或者分支选择由用户自己决定）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于补偿为用户自己编写，所以需要考虑：&lt;strong&gt;允许空补偿、防悬挂控制、幂等控制&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;官方给出的缺乏隔离的应对方案，只能说乏善可陈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;由于 Saga 事务不保证隔离性, 在极端情况下可能由于脏写无法完成回滚操作, 比如举一个极端的例子, 分布式事务内先给用户 A 充值, 然后给用户 B 扣减余额, 如果在给 A 用户充值成功, 在事务提交以前, A 用户把余额消费掉了, 如果事务发生回滚, 这时则没有办法进行补偿了。这就是缺乏隔离性造成的典型的问题, 实践中一般的应对方法是：
&lt;ul&gt;
&lt;li&gt;业务流程设计时遵循“宁可长款, 不可短款”的原则, 长款意思是客户少了钱机构多了钱, 以机构信誉可以给客户退款, 反之则是短款, 少的钱可能追不回来了。所以在业务流程设计上一定是先扣款。&lt;/li&gt;
&lt;li&gt;有些业务场景可以允许让业务最终成功, 在回滚不了的情况下可以继续重试完成后面的流程, 所以状态机引擎除了提供“回滚”能力还需要提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="状态机引擎"&gt;状态机引擎
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;项目启动时：先自动装配SeataSagaAutoConfiguration配置类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会在此配置类中初始化Bean：stateMachineEngine，此bean通过StateMachineConfig初始化时会扫描statelang目录（视配置情况）下的json文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;flowchart TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;初始化
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; A[Seata Saga模式初始化] --&amp;gt; B[StateMachineConfig配置]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; B --&amp;gt; C[初始化核心组件]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; C --&amp;gt; D[StateLogStore初始化]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; C --&amp;gt; E[StateMachineRepository初始化]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; C --&amp;gt; F[ExpressionFactory初始化]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; C --&amp;gt; G[ScriptEngineManager初始化]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-10/1760496856514_1760496856527.png"
loading="lazy"
alt="1760496856514.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;StateLogStore&lt;/strong&gt;：用来持久化状态机，对状态机的状态，解析后的状态机id，本地线程清理等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有了持久化后，如果事务运行过程中宕机，可以保证续跑，也不会出现事务编号错乱的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;StateMachineRepository&lt;/strong&gt;：用来管理状态机的注册，注销，状态机版本控制等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;统一状态机获取的如何，让状态机引擎和状态机本身解耦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ExpressionFactory&lt;/strong&gt;：解析XML文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ScriptEngineManager&lt;/strong&gt;：初始化脚本管理器，用来管理和执行json中配置的脚本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;创建状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;flowchart TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; H[状态机创建] --&amp;gt; I[StateMachineParser解析JSON]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; I --&amp;gt; J[解析States节点]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; J --&amp;gt; K{状态类型判断}
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K --&amp;gt;|ServiceTask| L[创建ServiceTaskState]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K --&amp;gt;|Choice| M[创建ChoiceState]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K --&amp;gt;|Succeed| N[创建SucceedState]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K --&amp;gt;|Fail| O[创建FailState]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K --&amp;gt;|CompensationTrigger| P[创建CompensationTriggerState]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; K --&amp;gt;|SubStateMachine| Q[创建SubStateMachineState]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-10/1760496927120_1760496955622.png"
loading="lazy"
alt="1760496927120.png"
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L27-L27" &gt;SERVICE_TASK&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;服务任务状态&lt;/td&gt;
&lt;td&gt;执行具体的业务逻辑，对应实际的服务调用，是状态机中最常用的状态类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L32-L32" &gt;CHOICE&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;选择状态&lt;/td&gt;
&lt;td&gt;用于条件分支判断，根据条件表达式的结果决定下一步执行哪个状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L37-L37" &gt;FAIL&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;失败状态&lt;/td&gt;
&lt;td&gt;表示状态机执行失败，终止状态机执行并标记为失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L42-L42" &gt;SUCCEED&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;成功状态&lt;/td&gt;
&lt;td&gt;表示状态机执行成功，终止状态机执行并标记为成功&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L47-L47" &gt;COMPENSATION_TRIGGER&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;补偿触发状态&lt;/td&gt;
&lt;td&gt;用于触发补偿流程，当状态机需要回滚时触发已执行状态的补偿操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L52-L52" &gt;SUB_STATE_MACHINE&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;子状态机状态&lt;/td&gt;
&lt;td&gt;调用另一个状态机作为子流程，支持状态机的嵌套调用和组合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L57-L57" &gt;SUB_MACHINE_COMPENSATION&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;子状态机补偿状态&lt;/td&gt;
&lt;td&gt;专门用于补偿子状态机的执行结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L62-L62" &gt;SCRIPT_TASK&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;脚本任务状态&lt;/td&gt;
&lt;td&gt;执行脚本代码，支持通过脚本引擎执行动态逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class="link" href="file:///Users/tom/IdeaProjects/incubator-seata-2.5.0/compatible/src/main/java/io/seata/saga/statelang/domain/StateType.java#L67-L67" &gt;LOOP_START&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;循环开始状态&lt;/td&gt;
&lt;td&gt;支持循环执行某些状态逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;事务执行&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;flowchart TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; R[事务执行流程] --&amp;gt; S[start方法调用]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; S --&amp;gt; T[获取状态机定义]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; T --&amp;gt; U[创建状态机实例]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; U --&amp;gt; V[持久化状态机实例]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; V --&amp;gt; W[执行起始状态]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; W --&amp;gt; X[ServiceTask执行]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; X --&amp;gt; Y[构建服务调用参数]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Y --&amp;gt; Z[执行前置拦截器]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Z --&amp;gt; AA{是否持久化执行}
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AA --&amp;gt;|是| AB[executeServiceTaskWithPersist]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AA --&amp;gt;|否| AC[executeServiceTaskDirectly]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AB --&amp;gt; AD[创建分支事务]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AD --&amp;gt; AE[执行业务逻辑]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AE --&amp;gt; AF{执行结果}
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AF --&amp;gt;|成功| AG[提交分支事务]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AF --&amp;gt;|失败| AH[回滚分支事务]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AC --&amp;gt; AI[直接执行业务逻辑]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; X --&amp;gt; AJ[执行后置拦截器]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AJ --&amp;gt; AK[更新状态机实例状态]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;![mermaid-diagram (1).png](&lt;a class="link" href="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-10/mermaid-diagram" target="_blank" rel="noopener"
&gt;https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-10/mermaid-diagram&lt;/a&gt; (1)_1760497128502.png)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务补偿&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; flowchart TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AL[补偿机制] --&amp;gt; AM[CompensationTrigger触发]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AM --&amp;gt; AN[获取需补偿状态列表]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AN --&amp;gt; AO[逆序执行补偿]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AO --&amp;gt; AP[查找补偿处理器]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AP --&amp;gt; AQ[执行补偿逻辑]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-10/1760497180682_1760497180697.png"
loading="lazy"
alt="1760497180682.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子事务嵌套&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;flowchart TD
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AR[子状态机支持] --&amp;gt; AS[SubStateMachine执行]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AS --&amp;gt; AT[获取子状态机定义]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AT --&amp;gt; AU[创建子状态机实例]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AU --&amp;gt; AV[关联父子实例]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; AV --&amp;gt; AW[启动子状态机执行]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-10/1760497211127_1760497211137.png"
loading="lazy"
alt="1760497211127.png"
&gt;&lt;/p&gt;
&lt;h2 id="xa模式"&gt;XA模式
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以 XA 协议的机制来管理分支事务的一种事务模式。&lt;font color='red'&gt;对业务无侵入，但性能差，属于悲观锁&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://seata.apache.org/img/doc/TB1hSpccIVl614jSZKPXXaGjpXa-1330-924.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;也是一种2PC分布式提交方式，利用数据库等可以手动控制事务提交，回滚，来统一管控整体事务的提交回滚等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于不同事务执行顺序不固定，可能出现死锁，需考虑事务超时场景。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>读《凤凰架构》有感--分布式基石</title><link>https://thecoolboyhan.github.io/p/icyfenix-hoeksteen/</link><pubDate>Thu, 21 Aug 2025 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/icyfenix-hoeksteen/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/icyfenix-hoeksteen/1.png" alt="Featured image of post 读《凤凰架构》有感--分布式基石" /&gt;&lt;h1 id="分布式的基石"&gt;分布式的基石
&lt;/h1&gt;&lt;h2 id="分布式共识算法"&gt;分布式共识算法
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前文书说过，分布式场景中，强一致性是最先被放弃的。但事务的主要目的就是要达到一致性。放弃强一致性，为了达到最终一致性，于是有了分布式共识算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;少数服从多数，不强求所有节点都同意，少数默认按照多数的结果来统一结果。来达到所谓的最终一致性。&lt;/p&gt;
&lt;h3 id="状态机"&gt;状态机
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;并不是共识算法，这也是一种达到一致性的方式，但是需要等消费完所有命令后才可以。依靠这种方式获得状态，有可能不是最终状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="link" href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener"
&gt;状态机&lt;/a&gt;有一个特性：任何初始状态一样的状态机，如果执行的命令序列一样，则最终达到的状态也一样。如果将此特性应用在多参与者进行协商共识上，可以理解为系统中存在多个具有完全相同的状态机（参与者），这些状态机能最终保持一致的关键就是起始状态完全一致和执行命令序列完全一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据状态机的特性，要让多台机器的最终状态一致，只要确保它们的初始状态是一致的，并且接收到的操作指令序列也是一致的即可，无论这个操作指令是新增、修改、删除抑或是其他任何可能的程序行为，都可以理解为要将一连串的操作日志正确地广播给各个分布式节点。&lt;/p&gt;
&lt;p&gt;广播指令与指令执行期间，允许系统内部状态存在不一致的情况，即并不要求所有节点的每一条指令都是同时开始、同步完成的，只要求在此期间的内部状态不能被外部观察到，且当操作指令序列执行完毕时，所有节点的最终的状态是一致的，这种模型就被称为&lt;strong&gt;状态机复制&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="basic-paxos基础版paxos"&gt;Basic Paxos（基础版Paxos）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;存在活锁问题&lt;/p&gt;
&lt;p&gt;世界上只有一种共识协议，就是Paxos，其他所有共识算法都是Paxos的退化版本。&lt;/p&gt;
&lt;p&gt;Paxos没有考虑拜占&lt;a class="link" href="https://en.wikipedia.org/wiki/Byzantine_fault" target="_blank" rel="noopener"
&gt;拜占庭将军&lt;/a&gt;问题。
假设信息可能丢失也可能延迟，但不会被错误传递。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;角色介绍&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提案节点（Proposer）：提出对某个值设置操作的节点，对值的操作被称提案，一旦设置成功，就不会丢失也不可改变。这里的设置值是一个日志记录操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Paxos是基于操作转移模型而非状态转移模型来设计的算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;决策节点（Acceptor）：应答提案的节点，决定该节点是否被投票、是否可被接接受。提案一旦有过半数决策节点的接受，即称该提案被批准Accept，被批准的提案意味着该值不能再被更改，也不会丢失，最终所有节点都会接收该操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录节点（leaner）：不参与提案，不参与决策，只是单纯的从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将进入这种状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;每个节点都可能成为上面三种角色中的一种或多种，但为了明确多数派，决策节点的数量应该被设置成奇数，系统初始化时，每个节点都知道整个网络所有决策节点的数量、地址等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;可能出现的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统内部各个节点通信是不可靠的，上面的所有角色，发出或收到信息，都可能延迟送达、也可能丢失，但不会出现信息传递错误的情况。&lt;/li&gt;
&lt;li&gt;系统外部各个用户访问可能是并发的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;并发访问可能产生的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;由于多个用户可能同时操作同一变量，请求到达的先后顺序可能会直接影响到值的结果。因此应当通过上锁，来使对于同一值的操作为串行化的。这样所有用户都能提前预判到自己本次操作会带来的结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但由于分布式系统中，每个节点都是不可靠的，所以传统的互斥锁很有可能会产生死锁。（如：某个节点取得锁后，与其他节点永久失联，此锁无法自动释放）&lt;/p&gt;
&lt;p&gt;因此，必须提供一个其他节点能抢占锁的机制，避免因通信问题而出现死锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式环境中的锁必须是可抢占的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Paxos的操作步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;准备（Prepare）：抢占锁的过程，如果某个提案节点准备发起提案，必须先向所有的决策节点广播一个许可申请（Prepare请求）。提案节点会在请求中附带一个全局唯一的数字n作为提案ID，决策节点收到请求后，会给提案节点两个承诺与一个应答：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;承诺1：承诺不再接收提案ID小于或等于n的Prepare请求（抢锁请求）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;承诺2：对于冲突的数据，承诺不再接收提案ID小于n的Accept请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应答：&lt;font color='red'&gt;在两个承诺的基础上，回复已经批准过的提案中ID最大的那个提案所设定的值和提案ID，如果该值没有被任何提案设定过，就返回空值。（对于来抢锁的节点，返回当前节点的最新值。）&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果收到的提案请求的Id值小于当前值最新通过的id，就直接忽略本次抢锁请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;批准（Accept）：尝试设置值.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;没有冲突的情况，如果提案者发现所有响应的决策节点此前都没有批准过该值（最新值为空），说明本次是第一个设置值的节点，可以随意决定要设置的值，将自己选定的值与提案ID，构成二源数组[id,value]，再次广播给所有决策节点（Accept请求）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果提案者发现收到的影响中，已经有一个或多个节点的应答中含有值了，他就不能随意取值，必须无条件的接受从应答中找出的最大ID的值，构成二元数组，再次广播给所有决策节点（Accept请求）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;提案者虽然发起了抢锁请求，如果抢到锁，尝试按照自己的值来设置值。&lt;/p&gt;
&lt;p&gt;如果没有抢到锁，就按照抢锁请求中返回的结果来共同执行广播抢锁返回的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当提案节点收到多数决策节点应答后，协商结束，共识形成，将形成的决策发送给所有记录节点进行学习。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755247330909_1755247330927.png"
loading="lazy"
alt="1755247330909.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S5初始想设置值为Y，接收到S1已经通过Promise发起的提案值为X。S5放弃自己原来的Y，改为一起通过X值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755505029862_1755505029928.png"
loading="lazy"
alt="1755505029862.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;X被选定为最终值，并不是必定需要多数派的共同批准，只要S5提案时Promise应答结果中已经包含了批准过X的决策节点，导致S5发起提案的准备阶段，X未获得多数派批准，但由于S3已经批准，最终共识的结果仍为X。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;未获得多数批准时仍可以赋值成功&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755505246414_1755505246436.png"
loading="lazy"
alt="1755505246414.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个提案是否通过，不取决于那边获得的Promise（承诺）更多，只取决于哪个提案先通过了Accept。只要有值先通过了Accept，后续再来promise时，天然让新提案结果也共识为之前Accept的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;X已经提案，但并为立刻给出应答，此时Y值的提案到达多数节点，此时达成的共识为Y&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755505945073_1755505945101.png"
loading="lazy"
alt="1755505945073.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;s3接收到X值提案后，又接收了新的Y提案（且Y提案版本号领先X），此时X的通过请求被放弃，集群达成的共识为Y。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;活锁&lt;/strong&gt;极端情况导致的活锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755506052152_1755506052168.png"
loading="lazy"
alt="1755506052152.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不断使用新的版本号来提案，导致准备阶段无限成功，之前通过他的提案全部作废。形成活锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方案：可以加入随机超时时间，来避免活锁产生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Basic Paxos的缺点&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;只能对单个值形成决议&lt;/li&gt;
&lt;li&gt;决议的形成至少需要两次网络请求和应答（准备和批准）高并发情况下将产生较大的网络开销&lt;/li&gt;
&lt;li&gt;极端情况下甚至可能形成活锁&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="multi-paxos"&gt;Multi Paxos
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;选主的Paxos，在Basic Paxos的基础上增加了“选主” 的过程。&lt;/p&gt;
&lt;p&gt;zookeeper的ZAB算法，Raft算法都属于本共识算法的派生&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过Basic Paxos选出主节点，后续所有操作都路由给主节点决策，相当于只有主节点有决策权，所有的提案节点接收到请求后，都要把请求路由给主节点，主节点通过接收到请求的先后顺序来决策发起Accepted请求。&lt;/p&gt;
&lt;p&gt;如果主节点宕机后（心跳检测发现与主节点失联），则每个节点都会发起提案，尝试让自己为主。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755507359476_1755507359521.png"
loading="lazy"
alt="1755507359476.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;节点只有主（Leader）和从（Follower）的区别，没有提案者、决策者和记录者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755507461220_1755507461257.png"
loading="lazy"
alt="1755507461220.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分布式场景下，当以下三个问题全部解决时，就相当于达成了分布式的共识。&lt;/p&gt;
&lt;p&gt;证明论文：这篇以《&lt;a class="link" href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14" target="_blank" rel="noopener"
&gt;一种可以让人理解的共识算法&lt;/a&gt;》（In Search of an Understandable Consensus Algorithm）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如何选主&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有节点通过心跳检测来判断主节点是否失效&lt;/p&gt;
&lt;p&gt;如果失效，开始通过基础Paxos来让自己成为主节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何把数据复制到各个节点上&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主节点接收变更，并记录日志&lt;/strong&gt;。提出将某个值设置为X，此时主节点将X写入到自己的变更日志，先不提交，然后将变更成X的信息在下一次心跳广播中广播给所有的从节点，并要求从节点恢复确认收到的消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主节点发起变更，给从节点记录日志&lt;/strong&gt;。从节点收到消息后，将操作写入自己的变更日志中，然后给主节点发送确认签收的消息。主节点收到过半的签收消息后，提交自己的变更、应答客户端并给从节点广播可以提交的消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主节点收到半数日志记录完成，提交变更并广播从节点确认日志&lt;/strong&gt;。从节点收到提交消息，变更自己记录的日志，数据复制完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;网络产生分区的异常情况&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2和S3、S4、S5之间彼此无法通信，形成网络分区。&lt;/li&gt;
&lt;li&gt;一段时间后，S3、S4、S5中某个节点达到心跳检测阈值，得知当前分区中没有主节点存在，开始发起竞选自己为新主节点。S3、S4、S5选择S3为新主节点。此时分区中存在三个节点，超过半数（5/2=2）。S3成功当选。S1、S2不知道有S3新主的存在。此时集群中出现了两个主节点，S1和S3。&lt;/li&gt;
&lt;li&gt;此时客户端发起操作请求：
&lt;ol&gt;
&lt;li&gt;S1、S2分区接收到请求：请求由S1处理，但S1只能收到两个节点的响应，无法超过半数。&lt;strong&gt;S1、S2分区的所有请求都无法成功提交&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果客户端连接到了S3、S4、S5分区，请求由S3处理，S3最多可以收到3个响应，超过半数，修改有效。集群可以正常提供服务。&lt;/li&gt;
&lt;li&gt;只要系统中仍有半数以上的节点在线，系统就可以正常提供服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;假设网络阻塞被打通，两个分区重新恢复了通信
&lt;ol&gt;
&lt;li&gt;S1和S3都向所有节点发送心跳包，S3中的任期编号更大，此时5个节点都只承认S3是唯一的主节点。&lt;/li&gt;
&lt;li&gt;S1、S2回滚它们所有未提交的变更。&lt;/li&gt;
&lt;li&gt;S1、S2从主节点（S3）发送的心跳包中获得它们失联期间发生的所有变更，将变更提交写入到本地。&lt;/li&gt;
&lt;li&gt;此时分布式系统各节点状态达成最终一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何保证过程的安全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;协定性（Safety）：所有的坏事都不会发生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选主的结果一定是有且只有唯一的一个主节点，不可能同时出现两个主节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;终止性（Liveness）：所有的好事都终将发生，但不知道啥时候。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选主过程是一定可以在某个时刻能够结束的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="gossip-协议"&gt;Gossip 协议
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Paxos、Raft、ZAB为强一致性的分布式共识协议，虽然系统内部可能会出现不同值，但在外部只能观察到一致的值。&lt;/p&gt;
&lt;p&gt;Gossip为最终一致性的分布式共识协议，系统中不一致的状态可能被外部观察到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;病毒式传播。&lt;/p&gt;
&lt;p&gt;某个信息需要传播，从信息源开始，按照固定周期（1秒），随机选择它相连接的K个节点来传播消息。&lt;/p&gt;
&lt;p&gt;每个节点收到消息后，将在下一个周期内，选择给其他相邻的k个节点发送相同的消息，直到最终网络中的所有节点有收到消息为止。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/gossip.0eb19e80.gif"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;Gossip 传播示意图(&lt;a class="link" href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/" target="_blank" rel="noopener"
&gt;图片来源&lt;/a&gt;)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;能够容忍网络上节点的随意增加或者减少，随意宕机或者重启，新增加的节点状态最终都会和其他同步达成一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完全去中心化，没有主节点的概念&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;消息要通过多个轮次才能到达全网&lt;/li&gt;
&lt;li&gt;全网的各个节点必定存在不一致的情况&lt;/li&gt;
&lt;li&gt;对于个体，无法准确的预测消息传播到全网的时间&lt;/li&gt;
&lt;li&gt;消息冗余，同样的消息重复发送给同一个节点，增加了网络压力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="从类库到服务"&gt;从类库到服务
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;将构成软件服务的组件，拆分成一个个服务。&lt;/p&gt;
&lt;p&gt;采用服务来当组件，而不是类库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类库在程序编译期间静态链接到程序中的，通过调用本地方法来使用其中的功能。&lt;/p&gt;
&lt;p&gt;服务是进程外组件，通过远程调用方法来使用其中的功能。&lt;/p&gt;
&lt;h3 id="服务发现"&gt;服务发现
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何确定目标方法的确切位置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有远程服务调用都是使用全限定名、端口号与服务标识所构成的三元组来确定一个远程服务的精确坐标。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现三个必须的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;服务的注册：当服务启动时，将自己的坐标信息通知到服务注册中心
&lt;ol&gt;
&lt;li&gt;自注册模式： Spring Cloud 的@EnableEurekaClient 注解，程序主动来完成&lt;/li&gt;
&lt;li&gt;第三方注册： Kubernetes 和 Registrator，由容器编排框架或第三方注册工具来完成&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;服务的维护（心跳检测）：服务是不可靠的，随时可能因为各种意外而被迫下线。服务发现框架必须要自己区保证所维护的服务列表的正确性。
&lt;ol&gt;
&lt;li&gt;维护方式：长连接、心跳、探针、进程状态等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;服务的发现：消费者从服务发现框架中，把一个服务转换为服务实际坐标的过程。
&lt;ol&gt;
&lt;li&gt;Eureka 中的 ServiceID、Nacos 中的服务名、或者通用的 FQDN&lt;/li&gt;
&lt;li&gt;Kubernetes 也支持注入环境变量来做服务发现。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注册中心的地位是特殊的，注册中心不依赖其他服务，但被所有其他服务共同依赖，是系统中最基础的服务，几乎没有可能在业务层面进行容错。注册中心一旦崩溃，整个系统都不再可用。&lt;strong&gt;必须尽最大努力保证服务发现的可用性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755573399747_1755573399784.png"
loading="lazy"
alt="1755573399747.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eureka（AP）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;优先保证高可用性，牺牲了系统中服务状态的一致性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注册&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Eureka的各个节点采用异步复制来交换服务注册信息，当有新服务注册进来时，并不需要等待信息在其他节点注册复制完成，而是马上在该节点宣布服务可见，只是不保证在其他节点上多长时间后才会可见。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;维护&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;当旧服务下线或者断网，只由超时机制来控制从哪个服务注册表中移除，变动信息不会实时的同步给所有服务端和客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端或服务端都维护着一份服务注册表缓存，并以TTL（Time to Live）机制来进行更新。哪怕注册中心崩溃，客户端依然可以维持有限的可用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Eureka更适合节点关系相对固定，服务不会频繁的上下线，以较小的代价换取最高的可用性。&lt;/p&gt;
&lt;p&gt;万一客户端拿到了已经发生变动的错误地址，也能够通过Ribbon和Hystrix模块配合来兜底，实现故障转移或者快速失败。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consul（CP）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;采用Raft算法，要求多数派写入成功后，服务的注册或变动才算成功。严格保证集群外读取到的结果必定是一致的。同时采用Gossip协议，支持多数据中心之间更大规模的服务同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果从注册中心中取到了错误的地址，就没有其他兜底方案了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CP模型：ZooKeeper、Doozerd、Etcd&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Etcd采用Raft算法，ZooKeeper采用ZAB算法，都是主从 Multi Paxos的派生算法。他们都是CP的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只提供CRUD和Watch等少量API，完整的服务发现，健康检查等，都必须自己手动实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用基础设施（主要指DNS服务器）实现的服务发现，SkyDNS，CoreDNS&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;K8S的服务注册发现机制，是 CP 还是 AP 就取决于后端采用何种存储，如果是基于 Etcd 实现的，那自然是 CP 的，如果是基于内存异步复制的方案实现的，那就是 AP 的（仅针对 DNS 服务器本身，不考虑本地 DNS 缓存的 TTL 刷新）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：对应用透明，任何语言、框架、工具肯定都支持HTTP、DNS的，完全不受程序技术选型的约束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：必须自己考虑如何做负载均衡、如何调用远程方法等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;专门用于服务发现的框架和工具，代表是 Eureka、Consul 和 Nacos。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;CP 的 Consul、AP 的 Eureka，还有同时支持 CP 和 AP 的 Nacos（Nacos 采用类 Raft 协议做的 CP，采用自研的 Distro 协议做的 AP，这里“同时”是“都支持”的意思，它们必须二取其一，不是说 CAP 全能满足）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="网关路由gateway"&gt;网关路由（Gateway）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;微服务中网关的首要职责就是作为统一的出口对外提供服务，将外部访问网关地址的流量，根据适当的规则路由到内部集群中正确的服务节点之上。&lt;/p&gt;
&lt;p&gt;关还可以根据需要作为流量过滤器来使用，提供某些额外的可选的功能，譬如安全、认证、授权、限流、监控、缓存，等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网关 = 路由器（基础职能） + 过滤器（可选职能）&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;五种网络IO模型&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;异步IO（Asynchronous I/O）：异步IO中数据到达缓冲区后，不需要调用进程主动进行从缓冲区复制数据的操作，而是复制完成后，由操作系统向线程发送信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞IO（Blocking I/O）：由调用进程执行操作，如果遇到阻塞，调用进程被阻塞。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;节省CPU资源。缺点是线程休眠所带来的上下文切换，需要从用户态切换到内核态的重负载操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞IO（Non-Blocking I/O）：调用线程执行，如果发现资源没有就绪，就等待固定时间轮询，直到操作结束。可以避免CPU休眠，节省切换上下文的消耗，但如果需要等待时间较长的返回，非阻塞IO浪费了CPU资源。非常不推荐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多路复用IO（Multiplexing IO）：可以在同一条阻塞线程上处理多个不同端口的监听。哪个端口资源准备好，就先去处理哪个端口的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前最主流的网络IO应用，有select、epoll、kqueue 等不同实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号驱动IO（Signal-Driven I/O）：有固定线程监听缓冲区，当资源准备完成，此线程把数据复制结束后，通知其他线程执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="客户端负载均衡"&gt;客户端负载均衡
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;客户端负载均衡（Ribbon、Spring Cloud Load Balancer）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755667983405_1755667983454.png"
loading="lazy"
alt="1755667983405.png"
&gt;客户端负载均衡&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在服务内部实现的负载均衡，每个服务都有自己对应的负载均衡器，负载均衡器和服务在同一个进程内，互相调用不会出现网络开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于请求的来源可能是来自集群中任意一个服务节点，而不再是统一来自集中式均衡器，这就使得内部网络安全和信任关系变得复杂，当攻破任何一个服务时，更容易通过该服务突破集群中的其他部分。&lt;/p&gt;
&lt;p&gt;服务集群的拓扑关系是动态的，每一个客户端均衡器必须持续跟踪其他服务的健康状况，以实现上线新服务、下线旧服务、自动剔除失败的服务、自动重连恢复的服务等均衡器必须具备的功能。由于这些操作都需要通过访问服务注册中心来完成，数量庞大的客户端均衡器一直持续轮询服务注册中心，也会为它带来不小的负担。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;服务网格（Service Mesh）基于代理，类似VPN实现的负载均衡器。&lt;/p&gt;
&lt;p&gt;原本嵌入服务进程中的均衡器提取出来，同一个Pod之内的一个特殊服务。（边车代理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755679263950_1755679263998.png"
loading="lazy"
alt="1755679263950.png"
&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes 严格保证了同一个 Pod 中的容器不会跨越不同的节点，这些容器共享着同一个网络名称空间，因此代理均衡器与服务实例的交互，实质上是对本机回环设备的访问，仍然要比真正的网络交互高效且稳定得多。代理均衡器付出的代价较小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代理均衡器不受编程语言限制&lt;/li&gt;
&lt;li&gt;服务拓扑感知方面更有优势，控制平台K8S会同一管控服务上下线状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;地域或区域的负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;云计算领域常用的负载均衡，基于地理位置把请求全部分发给不同的机房去处理。尽量保证一个地方的请求，全部都只会在同一个区域的机房内部处理完成，不要出现跨区域调用的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="流量治理"&gt;流量治理
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;容错性设计：失败检查，自动恢复&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="服务容错"&gt;服务容错
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在分布式场景中，错误是必然存在的，当服务出现错误时，与其有关联的服务应当如何处理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;常见的容错策略&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;故障转移：多数服务均部署了多个副本，每个副本可能在不同的机器上，当某台机器宕机时，故障转移只如果调用的服务出现故障，系统不会立刻向调用者返回失败，而是自动切换到其他服务副本。（Feign的原理）从而保证服务的高可用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;故障转移存在调用次数的限制，如果服务调用超时时间为100毫秒，但失败的请求就花费了60毫秒返回数据，就算转移调用可以正常返回结果，但也会超时，这样的调用也就没意义了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速失败：有些业务不允许做故障转移，&lt;strong&gt;故障转移策略可以实施的前提是必须要保证接口的幂等性&lt;/strong&gt;，对于非幂等的接口，重复调用就可能会产生脏数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果服务出现异常。就尽快抛出异常，由调用者处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全失败：服务调用过程中，有主路和旁路之分，(旁路调用不重要，主路调用重要)，只要主路调用正确，有部分服务失败了也不影响核心业务的正确性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;沉默失败：当请求失败后，就默认服务提供者一定时间内无法再对外提供服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障恢复：通常以快速失败+故障恢复的策略同时出现，服务调用出错之后，将该调用的失败信息存入一个消息队列，然后由系统自动开始异步重试调用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，核心放款Confirm阶段，调用支付放款失败后，记录流水，等待流水同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并行调用：在调用开始之前，就想尽最大可能拿到返回值。一开始就同时向多个服务发起调用，只要其中任何一个返回成功，调用就悬挂成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;广播调用：调用所有的副本，要求所有请求都返回成功后，才算成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如刷新分布式缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;表 8-1 常见容错策略优缺点及应用场景对比&lt;/center&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容错策略&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;th&gt;应用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统自动处理，调用者对失败的信息不可见&lt;/td&gt;
&lt;td&gt;增加调用时间，额外的资源开销&lt;/td&gt;
&lt;td&gt;调用幂等服务 对调用时间不敏感的场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;快速失败&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;调用者有对失败的处理完全控制权 不依赖服务的幂等性&lt;/td&gt;
&lt;td&gt;调用者必须正确处理失败逻辑，如果一味只是对外抛异常，容易引起雪崩&lt;/td&gt;
&lt;td&gt;调用非幂等的服务 超时阈值较低的场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;安全失败&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;不影响主路逻辑&lt;/td&gt;
&lt;td&gt;只适用于旁路调用&lt;/td&gt;
&lt;td&gt;调用链中的旁路服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;沉默失败&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;控制错误不影响全局&lt;/td&gt;
&lt;td&gt;出错的地方将在一段时间内不可用&lt;/td&gt;
&lt;td&gt;频繁超时的服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;故障恢复&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;调用失败后自动重试，也不影响主路逻辑&lt;/td&gt;
&lt;td&gt;重试任务可能产生堆积，重试仍然可能失败&lt;/td&gt;
&lt;td&gt;调用链中的旁路服务 对实时性要求不高的主路逻辑也可以使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;并行调用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;尽可能在最短时间内获得最高的成功率&lt;/td&gt;
&lt;td&gt;额外消耗机器资源，大部分调用可能都是无用功&lt;/td&gt;
&lt;td&gt;资源充足且对失败容忍度低的场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;广播调用&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;支持同时对批量的服务提供者发起调用&lt;/td&gt;
&lt;td&gt;资源消耗大，失败概率高&lt;/td&gt;
&lt;td&gt;只适用于批量操作的场景&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;center&gt;容错设计模式&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;断路器模式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通过代理（断路器对象），来一对一的接管服务调用者的远程请求。&lt;/p&gt;
&lt;p&gt;熔断：&lt;/p&gt;
&lt;p&gt;断路器来统计调用返回的各种结果，当出现故障的次数达到断路器的阈值，断路器open，窗口内，断路器不再进行远程访问。等待后续恢复。&lt;/p&gt;
&lt;p&gt;这样可以避免因持续的失败导致的资源堆积和消耗，避免了雪崩效应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755740769572_1755740785018.png"
loading="lazy"
alt="1755740769572.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755745519077_1755745519113.png"
loading="lazy"
alt="1755745519077.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务熔断和服务降级的区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务熔断：当服务不可用时，通过上面提到的短路器方式，不再访问出错的服务。调用者来直接处理此异常。不再被调用的服务相当于被熔断了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务降级：调用者调用下游，当下游无法工作，或负载太高，需要调用者想其他方式来处理的过程，为服务降级。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务降级不一定必须是服务熔断时出现，也可能是负载均衡，或流量控制的一种手段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;舱壁隔离模式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;调用外部服务的故障大致可以分为“失败”（如 400 Bad Request、500 Internal Server Error 等错误）、“拒绝”（如 401 Unauthorized、403 Forbidden 等错误）以及“超时”（如 408 Request Timeout、504 Gateway Timeout 等错误）三大类。&lt;/p&gt;
&lt;p&gt;超时场景中，只要请求一直不结束，就会一直占用着某个线程不能释放，如果某个请求大量超时，导致tomcat的全部线程都被占用，导致整个机器上所有的java服务全部瘫痪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755754097338_1755754097385.png"
loading="lazy"
alt="1755754097338.png"
&gt;&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;为每个服务单独设置线程池，每个服务接收到的任务，只会在本服务中独有的线程池中运行，如果发生大量超时，也只会导致单个服务崩溃，不会对其他服务造成影响。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755754265018_1755754265039.png"
loading="lazy"
alt="1755754265018.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据 Netflix 官方给出的数据，一旦启用 Hystrix 线程池来进行服务隔离，大概会为每次服务调用增加约 3 毫秒至 10 毫秒的延时，如果调用链中有 20 次远程服务调用，那每次请求就要多付出 60 毫秒至 200 毫秒的代价来换取服务隔离的安全保障。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说，我们会选择将服务层面的隔离实现在服务调用端或者边车代理上，将系统层面的隔离实现在 DNS 或者网关处。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重试模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对失败的服务进行重试。&lt;/p&gt;
&lt;h3 id="流量控制"&gt;流量控制
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;场景应用题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;已知条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统中一个业务操作需要调用 10 个服务协作来完成&lt;/li&gt;
&lt;li&gt;该业务操作的总超时时间是 10 秒&lt;/li&gt;
&lt;li&gt;每个服务的处理时间平均是 0.5 秒&lt;/li&gt;
&lt;li&gt;集群中每个服务均部署了 20 个实例 副本&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;求解以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个用户访问，完成一次业务操作，需要耗费系统多少处理器时间？
答：0.5 × 10 = 5 Sec &lt;a class="link" href="https://en.wikipedia.org/wiki/CPU_time" target="_blank" rel="noopener"
&gt;CPU Time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;集群中每个服务每秒最大能处理多少个请求？
答：(1 ÷ 0.5) × 20 = 40 &lt;a class="link" href="https://en.wikipedia.org/wiki/Queries_per_second" target="_blank" rel="noopener"
&gt;QPS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;假设不考虑顺序且请求分发是均衡的，在保证不超时的前提下，整个集群能持续承受最多每秒多少笔业务操作？
答：40 × 10 ÷ 5 = 80 &lt;a class="link" href="https://en.wikipedia.org/wiki/Transactions_per_second" target="_blank" rel="noopener"
&gt;TPS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;如果集群在一段时间内持续收到 100 TPS 的业务请求，会出现什么情况？
答：这就超纲了小学水平，得看你们家架构师的本事了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;流量统计指标&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通过哪些数据来反应系统的流量压力大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;每秒事务数（TPS）：衡量系统吞吐量的最终标准。&lt;/li&gt;
&lt;li&gt;每秒请求数（HPS）：每秒从客户端发向服务端的请求数，一次业务可能需要多次请求才能完成。&lt;/li&gt;
&lt;li&gt;每秒查询数（QPS）：一台服务器能够响应的查询次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;限流设计模式&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;流量计数器模式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不严谨&lt;/strong&gt;，设置一个计算器，统计一段时间内的总流量，然后除以时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能出现前面几秒流量极大，后面流量极小。流量统计不严谨。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;滑动窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;利用双指针，统计一段时间内的流量数，可以平滑的计算一段时间内的流量数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以保证流量不会超过系统设定的最大值。但不能填谷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;漏桶模式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通过缓存区来缓冲流量，然后把缓冲区中的流量，较为平稳的发送给服务。&lt;/p&gt;
&lt;p&gt;比如搞一个FIFO队列，然后让服务消费队列 中的请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以填谷，且保证流量平稳。但无法动态调整流出速度，流出速度一般是固定值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;令牌桶模式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;假设x秒内最大请求数不超过Y，则每隔X/Y时间就向桶中添加一个令牌（记得给桶中加入令牌数量的上限，到达上限不再添加令牌）。请求进来时，需先从桶中取到令牌，才能进入系统。一旦桶中没有令牌可取，就尝试让调用服务执行降级逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;让系统以一个由限流目标决定的速率向桶中注入令牌，譬如要控制系统的访问不超过 100 次每秒，速率即设定为 100 个令牌每秒，每个令牌注入间隔为 1/100=10 毫秒。&lt;/li&gt;
&lt;li&gt;桶中最多可以存放 N 个令牌，N 的具体数量是由超时时间和服务处理能力共同决定的。如果桶已满，第 N+1 个进入的令牌会被丢弃掉。&lt;/li&gt;
&lt;li&gt;请求到时先从桶中取走 1 个令牌，如果桶已空就进入降级逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;分布式限流&lt;/center&gt;
&lt;ul&gt;
&lt;li&gt;通过集中缓存还限流（非常不推荐）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过redis等集中缓存，在缓存中统计每个接口的流量使用情况，然后根据缓存中统计的数量+分布式锁来实现限流。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;限流往往只有在高流量的情况下才会使用，但修改redis数量，获取分布式锁等为了限流准备的操作。需要增加至少两次网络IO，反而大大消耗了资源，可能进一步拖累了系统的处理速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在令牌桶基础上增加货币属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不把令牌看作简单的准入通行证，同时也给令牌添加货币额度。不同等级的用户，添加不同的额度，每次服务调用，都给令牌消耗一定额度。当额度归零时，让用户重新获取令牌。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只有在获取令牌时需要网络请求，其他情况下都不在需要额外的网络请求。&lt;/p&gt;
&lt;p&gt;但可能会导致用户额度归零后，无法获取令牌而使业务中断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="ddd领域驱动设计"&gt;DDD领域驱动设计
&lt;/h2&gt;&lt;h3 id="传统mvc架构"&gt;传统MVC架构
&lt;/h3&gt;&lt;p&gt;主要包括M-mode对象层，封装到domain里。V-view展示层，前后端分离，几乎没有JSP文件了。C-Controller控制层，对外提供接口实现类。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://bugstack.cn/images/roadmap/tutorial/road-map-230623-02.png?raw=true"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://bugstack.cn/images/roadmap/tutorial/road-map-230623-03.png?raw=true"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;h3 id="ddd"&gt;DDD
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;DDD是一种软件设计方法。DDD是指导我们做软件工程设计的一种手段，主要用来切割工程模型：领域、界限上下文、实体、值对象、聚合、工厂、仓储等。通过DDD的指导思想，我们可以在前期投入更多的时间，更加合理的规划出可持续迭代的工程设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DDD用来解决什么问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;战略设计&lt;/p&gt;
&lt;p&gt;主要以应对复杂的业务需求，通过抽象、分治的过程，合理的拆分出多个微服务，分而治之。少数几个中等规模的单体应用，周围环绕着一个服务生态系统，这更有意义。&lt;a class="link" href="https://www.simplethread.com/youre-not-actually-building-microservices/" target="_blank" rel="noopener"
&gt;你实际上并没有构建微服务 @贾斯汀·埃瑟里奇&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;战术设计&lt;/p&gt;
&lt;p&gt;如何基于面向对象思维，运用领域模型来表达业务概念。传统MVC三层架构，会让Service扁平的、大量的，平铺出非常复杂的业务逻辑代码。系统会不断的增加复杂度，直到难以维护的程度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>读《凤凰架构》有感--架构篇</title><link>https://thecoolboyhan.github.io/p/icyfenix-argitektuur/</link><pubDate>Thu, 07 Aug 2025 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/icyfenix-argitektuur/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/icyfenix-argitektuur/1.png" alt="Featured image of post 读《凤凰架构》有感--架构篇" /&gt;&lt;p&gt;凤凰架构&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文中大部分资料摘抄自周志明老师的&lt;a class="link" href="https://icyfenix.cn/" target="_blank" rel="noopener"
&gt;凤凰架构&lt;/a&gt;开源网站&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="架构"&gt;架构
&lt;/h1&gt;&lt;h2 id="访问远程服务"&gt;访问远程服务
&lt;/h2&gt;&lt;h3 id="远程服务调用rpc"&gt;远程服务调用（RPC）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;RPC出现的目的是为了让计算机能够跟调用本地方法一样去调用远程方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="进程间通讯ipc"&gt;&lt;strong&gt;进程间通讯（IPC）&lt;/strong&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;管道（pipe）&lt;/p&gt;
&lt;p&gt;管道类似于两个进程间的桥梁，可以通过管道在进程间传递少量的字符流或字节流。&lt;/p&gt;
&lt;p&gt;管道命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ps -ef &lt;span class="p"&gt;|&lt;/span&gt; grep java
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号（Signal）&lt;/p&gt;
&lt;p&gt;用于通知目标某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程自身。&lt;/p&gt;
&lt;p&gt;信号命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sh" data-lang="sh"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;kill&lt;/span&gt; -9 pid
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量（Semaphore)&lt;/p&gt;
&lt;p&gt;两个进程之间同步协作的手段，相同于操作系统提供的一个特殊变量，程序可以在上面进行wait（）和notify（）操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列（Message Queue）：上面的三个方式只适合传递少量信息，消息队列用于进程间数据量较多的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享内存（Shared Memory）：允许多个进程访问同一块公共的内存空间，这是效率最高的进程间通信方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套接字接口（Socket）：可用于不同机器之间的进程通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/rpc.38c28315.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;h4 id="rpc的三个基本问题"&gt;RPC的三个基本问题
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如何表示数据（序列化与反序列化）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将交互双方锁涉及的数据转换为某种事先约定好的中立数据流格式来进行传输，将输数据流转换回不同语言中对应的数据类型来进行使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何传递数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个服务的Endpoint之间交互操作、交换数据。一般是基于标准的TCP、UDP等标准的传输层协议来完成的。（也有可能直接使用HTTP协议来实现）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何确定方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译器或者解释器回根据语言规范，将调用的方法签名传唤为进程空间中子过程入口位置的指针。&lt;/p&gt;
&lt;h3 id="rest设计风格表征状态转移"&gt;REST设计风格（表征状态转移）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;并非协议，只是一种风格&lt;/p&gt;
&lt;p&gt;RPC：面向过程编程
REST：面向资源编程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;资源（Resource）：内容本身，如信息、数据等。远程调用等都是为了提供资源。&lt;/li&gt;
&lt;li&gt;表征（Representation）：信息与用户交互时的表示形式，这与软件分层架构中常说的表示层的语义一致。&lt;/li&gt;
&lt;li&gt;状态（State）：分成有状态与无状态，由服务端保存用户目前所处的阶段或状态为有状态，由用户自己保存自己目前所处的状态，服务端只负责提供资源的为无状态。&lt;/li&gt;
&lt;li&gt;转移（Transfer）：服务端通过某种方式让用户的状态发生改变，如获取了新资源等。这个操作被称为：表征状态转移&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="rest风格的六大原则"&gt;REST风格的六大原则
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务端与客户端分离（Client-Server）前后端分离&lt;/p&gt;
&lt;p&gt;将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来，有助于提高用户界面的跨平台的可移植性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无状态（Stateless）去除session&lt;/p&gt;
&lt;p&gt;REST希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前大部分系统达不到这个要求，服务端无状态可以在分布式计算中获得非常高的价值，但即希望于用户每次传输大量的上下文有点不切实际。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可缓存（Cacheability）分布式缓存&lt;/p&gt;
&lt;p&gt;无状态服务器虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。REST希望分布式系统有一个可以暂时缓存数据的分布式缓存（Redis），这样服务器直接交互，可以进一步提高性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分层系统（Layered System）（负载均衡）&lt;/p&gt;
&lt;p&gt;客户端不需要直到是否直接连接到了最终的服务器，中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样便于缓存、伸缩和安全策略的部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一接口（Uniform Interface）（面向资源）&lt;/p&gt;
&lt;p&gt;REST希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为（服务）上。&lt;/p&gt;
&lt;p&gt;用一个登录场景来举例子：&lt;/p&gt;
&lt;p&gt;传统思维：登录login()服务，注销logout（）服务。&lt;/p&gt;
&lt;p&gt;REST思维：登录，PUT Session，注销DELETE Session。查询登录信息，GET Session&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有的资源最好应该是自描述信息的，或都是通过资源id来进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按需代码（Code-On-Demand）（可选项）&lt;/p&gt;
&lt;p&gt;客户端无需直到服务端如何运行，服务端会按需把需要的可执行程序发送给客户端执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="rmm成熟度"&gt;RMM成熟度
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;如何衡量一个服务有多么REST，下面直接引入书中的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="0"&gt;
&lt;li&gt;
&lt;p&gt;完全不REST&lt;/p&gt;
&lt;p&gt;医院开放了一个&lt;code&gt;/appointmentService&lt;/code&gt;的 Web API，传入日期、医生姓名作为参数，可以得到该时间段该名医生的空闲时间，该 API 的一次 HTTP 调用如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;POST&lt;/span&gt; &lt;span class="nn"&gt;/appointmentService?action=query&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{date: &amp;#34;2020-03-04&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后服务器会传回一个包含了所需信息的回应：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="ne"&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;得到了医生空闲的结果后，我觉得 14:00 的时间比较合适，于是进行预约确认，并提交了我的基本信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;POST&lt;/span&gt; &lt;span class="nn"&gt;/appointmentService?action=confirm&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; appointment: {date: &amp;#34;2020-03-04&amp;#34;, start:&amp;#34;14:00&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; patient: {name: icyfenix, age: 30, ……}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果预约成功，那我能够收到一个预约成功的响应：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="ne"&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; code: 0,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; message: &amp;#34;Successful confirmation of appointment&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果发生了问题，譬如有人在我前面抢先预约了，那么我会在响应中收到某种错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="ne"&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; code: 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; message: &amp;#34;doctor not available&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;到此，整个预约服务宣告完成，直接明了，我们采用的是非常直观的基于 RPC 风格的服务设计似乎很容易就解决了所有问题……了吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Resource：开始引入资源的概念&lt;/p&gt;
&lt;p&gt;第 0 级是 RPC 的风格，如果需求永远不会变化，也不会增加，那它完全可以良好地工作下去。但是，如果你不想为预约医生之外的其他操作、为获取空闲时间之外的其他信息去编写额外的方法，或者改动现有方法的接口，那还是应该考虑一下如何使用 REST 来抽象资源。&lt;/p&gt;
&lt;p&gt;通往 REST 的第一步是引入资源的概念，在 API 中基本的体现是围绕着资源而不是过程来设计服务，说的直白一点，可以理解为服务的 Endpoint 应该是一个名词而不是动词。此外，每次请求中都应包含资源的 ID，所有操作均通过资源 ID 来进行，譬如，获取医生指定时间的空闲档期：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;POST&lt;/span&gt; &lt;span class="nn"&gt;/doctors/mjones&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{date: &amp;#34;2020-03-04&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后服务器传回一组包含了 ID 信息的档期清单，注意，ID 是资源的唯一编号，有 ID 即代表“医生的档期”被视为一种资源：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="ne"&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {id: 1234, start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {id: 5678, start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我还是觉得 14:00 的时间比较合适，于是又进行预约确认，并提交了我的基本信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;POST&lt;/span&gt; &lt;span class="nn"&gt;/schedules/1234&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{name: icyfenix, age: 30, ……}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;后面预约成功或者失败的响应消息在这个级别里面与之前一致，就不重复了。比起第 0 级，第 1 级的特征是引入了资源，通过资源 ID 作为主要线索与服务交互，但第 1 级至少还有三个问题并没有解决：一是只处理了查询和预约，如果我临时想换个时间，要调整预约，或者我的病忽然好了，想删除预约，这都需要提供新的服务接口。二是处理结果响应时，只能靠着结果中的&lt;code&gt;code&lt;/code&gt;、&lt;code&gt;message&lt;/code&gt;这些字段做分支判断，每一套服务都要设计可能发生错误的 code，这很难考虑全面，而且也不利于对某些通用的错误做统一处理；三是并没有考虑认证授权等安全方面的内容，譬如要求只有登陆用户才允许查询医生档期时间，某些医生可能只对 VIP 开放，需要特定级别的病人才能预约，等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP Verbs：引入统一接口，映射到HTTP协议&lt;/p&gt;
&lt;p&gt;第 1 级遗留三个问题都可以靠引入统一接口来解决。HTTP 协议的七个标准方法是经过精心设计的，只要架构师的抽象能力够用，它们几乎能涵盖资源可能遇到的所有操作场景。REST 的做法是把不同业务需求抽象为对资源的增加、修改、删除等操作来解决第一个问题；使用 HTTP 协议的 Status Code，可以涵盖大多数资源操作可能出现的异常，而且 Status Code 可以自定义扩展，以此解决第二个问题；依靠 HTTP Header 中携带的额外认证、授权信息来解决第三个问题，这个在实战中并没有体现，请参考安全架构中的“&lt;a class="link" href="https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials" target="_blank" rel="noopener"
&gt;凭证&lt;/a&gt;”相关内容。&lt;/p&gt;
&lt;p&gt;按这个思路，获取医生档期，应采用具有查询语义的 GET 操作进行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;GET&lt;/span&gt; &lt;span class="nn"&gt;/doctors/mjones/schedule?date=2020-03-04&amp;amp;status=open&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后服务器会传回一个包含了所需信息的回应：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="ne"&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {id: 1234, start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {id: 5678, start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我仍然觉得 14:00 的时间比较合适，于是又进行预约确认，并提交了我的基本信息，用以创建预约，这是符合 POST 的语义的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;POST&lt;/span&gt; &lt;span class="nn"&gt;/schedules/1234&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{name: icyfenix, age: 30, ……}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果预约成功，那我能够收到一个预约成功的响应：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;201&lt;/span&gt; &lt;span class="ne"&gt;Created&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;Successful confirmation of appointment
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果发生了问题，譬如有人在我前面抢先预约了，那么我会在响应中收到某种错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;409&lt;/span&gt; &lt;span class="ne"&gt;Conflict&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;doctor not available
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超文本驱动的REST接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第 2 级是目前绝大多数系统所到达的 REST 级别，但仍不是完美的，至少还存在一个问题：你是如何知道预约 mjones 医生的档期是需要访问&lt;code&gt;/schedules/1234&lt;/code&gt;这个服务 Endpoint 的？也许你甚至第一时间无法理解为何我会有这样的疑问，这当然是程序代码写的呀！但 REST 并不认同这种已烙在程序员脑海中许久的想法。RMM 中的 Hypermedia Controls、Fielding 论文中的 HATEOAS 和现在提的比较多的“超文本驱动”，所希望的是除了第一个请求是由你在浏览器地址栏输入所驱动之外，其他的请求都应该能够自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。所以，当你输入了查询的指令之后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;GET&lt;/span&gt; &lt;span class="nn"&gt;/doctors/mjones/schedule?date=2020-03-04&amp;amp;status=open&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;服务器传回的响应信息应该包括诸如如何预约档期、如何了解医生信息等可能的后续操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-http" data-lang="http"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt; &lt;span class="m"&gt;200&lt;/span&gt; &lt;span class="ne"&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; schedules：[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; id: 1234, start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; links: [
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {rel: &amp;#34;comfirm schedule&amp;#34;, href: &amp;#34;/schedules/1234&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; },
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; id: 5678, start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; links: [
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {rel: &amp;#34;comfirm schedule&amp;#34;, href: &amp;#34;/schedules/5678&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; ],
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; links: [
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; {rel: &amp;#34;doctor info&amp;#34;, href: &amp;#34;/doctors/mjones/info&amp;#34;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt; ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="g"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果做到了第 3 级 REST，那服务端的 API 和客户端也是完全解耦的，你要调整服务数量，或者同一个服务做 API 升级将会变得非常简单。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：个人认为这样开发过于夸张，但不可否认，通过动态的返回可选的url，可以强大的实现权限控制，功能扩展等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="rest的不足"&gt;REST的不足
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;面向资源编程只适合CRUD，面向过程、面向对象编程才能处理真正复杂的业务&lt;/li&gt;
&lt;li&gt;REST和HTTP完全绑定，不适合应用于要求高性能传输的场景&lt;/li&gt;
&lt;li&gt;REST不利于事务支持&lt;/li&gt;
&lt;li&gt;REST没有传输可靠性支持&lt;/li&gt;
&lt;li&gt;REST缺乏对资源进行“部分”和“批量”的处理能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="事务处理"&gt;事务处理
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;事务的ACID&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C：一致性，一致性不是维持事务的手段，而是我们需要达到的目的。如果保证事务的一致性，只有完成了其他三种手段，才能保证事务的一致性。&lt;/p&gt;
&lt;p&gt;下面是源文的原话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A、I、D 是手段，C 是目的，前者是因，后者是果，弄到一块去完全是为了拼凑个单词缩写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A原子性：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。&lt;/p&gt;
&lt;p&gt;I隔离性：在不同的业务处理过程中，事务保证了各自业务正在读写的数据互相独立，不会彼此影响。&lt;/p&gt;
&lt;p&gt;D持久性：事务应当保证所有成功被提交的数据修改都能正确地被持久化，不丢数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个服务只使用了一个数据源时，通过AID来保证一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个服务使用多个不同的数据源，甚至多个服务同时涉及多个不同的数据源。&lt;/p&gt;
&lt;h3 id="本地事务局部事务"&gt;本地事务（局部事务）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;仅操作单一事务资源的、不需要全局事务管理器进行协调的事务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原子性和持久性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;原子性：要么都生效，要么都不生效，不存在中间状态。&lt;/p&gt;
&lt;p&gt;持久性：一旦事务生效，就不会再因为任务原因而导致其修改的内容被撤销或丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;原子性：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;未提交事务，写入后崩溃&lt;/strong&gt;：如果修改进行了一部分，但事务没有提交程序就崩溃了。程序一旦重启，数据库必须要有办法得知崩溃前发生过一次不完整的购物操作，将已经修改过的数据从磁盘中恢复成没有修改过的样子。保证原子性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql的做法：通过MVCC，事务在修改时，会先生成对应的undolog版本链，达到记录每次状态的目的。如果遇到上述情况，可以通过版本链来选择需要恢复的版本。（实现事务的回滚操作）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;持久性：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;已提交事务，写入前崩溃&lt;/strong&gt;：程序已经完成了修改，提交了事务，但还没有把修改后的结果都写入到磁盘中，此时出现了崩溃。程序一旦重启后，数据库必须要有办法得知崩溃前发生过一次完整的操作，将没来得及写入磁盘的部分重新写入磁盘，保证持久性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql的做法：通过redo log，事务提交前必须保证redo log已写入完毕，就算事务提交但数据没有落盘。也可以保证在重启时通过redo log来加载到修改的变量。
同时redolog也缩小了刷盘的次数和每次需要修改更新的数据量，不需要一次性读取更新整页的数据。减少了成本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中。只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化，这种事务实现方法被称为“Commit Logging”（提交日志）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;另一种保证持久性和原子性的方式&lt;strong&gt;Shadow Paging&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对数据的变动会写到硬盘的数据中，但并不是直接就地修改原先的数据，而是先将数据复制一份副本，保留原数据，修改副本数据。&lt;/p&gt;
&lt;p&gt;当事务成功提交，所有数据的修改都成功持久化之后，最后一步是去修改数据的引用指针，将引用从原数据改为新复制出来修改后的副本，最后的“修改指针”这个操作将被认为是原子操作，现代磁盘的写操作可以认为在硬件上保证了不会出现“改了半个值”的现象。所以 Shadow Paging 也可以保证原子性和持久性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上方式和copyonwritelist的实现非常像。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;FORCE：当事务提交后，要求变动数据必须同时完成写入则称为FORCE，不强制要求同时写入为NO-FORCE。&lt;/li&gt;
&lt;li&gt;STEAL：事务提交前，允许变动数据提前写入则称为STEAL，不允许则称为NO-STEAL。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;下图中，左边为磁盘IO性能考虑，右边为想要达到效果需要用到的日志。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754632791295_1754632791314.png"
loading="lazy"
alt="1754632791295.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离性&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;保证每个事务各自读、写的数据相互独立，不会彼此影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里只突出讲解不同隔离级别下是否需要锁和对应的上锁范围，并不突出mysql的锁。如果想详细了解mysql的锁，可以看我的&lt;a class="link" href="https://thecoolboyhan.github.io/p/mysql-lock/" target="_blank" rel="noopener"
&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现代数据库提供的三种锁：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写锁（X锁）：只有持有写锁的数据才能对数据进行写入操作，数据被加写锁时，其他事务不能写入数据，也不能施加读锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读锁（S锁）：多个事务对同一个数据加多个读锁，只要数据上还有读锁，就不能再加写锁，其他事务也不能对该数据进行写入，但仍然可以读取。如果数据只有当前事务自己添加了读锁，可以把读锁升级成写锁，然后写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;范围锁：对与某个范围上锁，实现多种多样。在这个范围内的数据不能被写入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;books&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHERE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;price&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FOR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;UPDATE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;隔离性的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;串行化：同一时间只能存在一个事务，其他事务需要等待当前事务执行后才能开启。&lt;/p&gt;
&lt;p&gt;天生具有隔离性，不需对数据加任何锁。但性能极差，没有并发能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读（RR）：只对事务所涉及到的数据加读锁或者写锁，且一直持有锁到事务结束。但任可能产生&lt;a class="link" href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Phantom_reads" target="_blank" rel="noopener"
&gt;幻读问题&lt;/a&gt;。事务在执行过程中，两个完全相同的范围查询得到的结果集不一致。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-mysql" data-lang="mysql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;books&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHERE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;price&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* 时间顺序：1，事务： T1 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;books&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;VALUES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;深入理解Java虚拟机&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* 时间顺序：2，事务： T2 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;books&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WHERE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;price&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* 时间顺序：3，事务： T1 */&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可重复读没有范围锁来禁止对该范围内插入新的数据，导致隔离性被破坏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql在可重复读级别下，只读事务完全可以避免幻读问题。但在读写事务下，依然可能出现幻读问题。（MVCC并不能完美解决幻读）&lt;/p&gt;
&lt;p&gt;如：事务 T1 如果在其他事务插入新书后，不是重新查询一次数量，而是要将所有小于 100 元的书改名，那就依然会受到新插入书籍的影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读已提交（RC）：写锁会一直持续到事务结束，但读锁会在每次查询操作结束后就会立刻释放。会产生&lt;a class="link" href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Non-repeatable_reads" target="_blank" rel="noopener"
&gt;不可重复读问题&lt;/a&gt;。同一行数据的两次查询得到了不同的结果。&lt;/p&gt;
&lt;p&gt;读已提交缺乏整个周期性的读锁，无法禁止读取过的数据发生变化。隔离性被破坏的表现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读未提交（RU）：对事务涉及的数据只加写锁一直持续到事务结束，但完全不加读锁。会产生&lt;a class="link" href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29#Dirty_reads" target="_blank" rel="noopener"
&gt;脏读问题&lt;/a&gt;。一个事务读取到另一个事务未提交的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;理论还存在更低的隔离性，就是事务既不加读锁，也不加写锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color='red'&gt;&lt;strong&gt;不同隔离级别产生的问题只是表面现象，是各种锁在不同加锁时间上组合而产生的结果，以锁为手段来实现隔离性才是数据库表现出不同隔离级别的根本原因。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MVCC（只针对读+写场景）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离级别是&lt;code&gt;可重复读&lt;/code&gt;：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。&lt;/li&gt;
&lt;li&gt;隔离级别是&lt;code&gt;读已提交&lt;/code&gt;：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外两个隔离级别都没有必要用到 MVCC，因为&lt;code&gt;读未提交&lt;/code&gt;直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。&lt;code&gt;可串行化&lt;/code&gt;本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql利用undolog和锁来实现MVCC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="全局事务外部事务"&gt;全局事务（外部事务）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;单个服务使用多个数据源场景的事务解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局事务和本地事务代码表现得不同：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;public&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;buyBook&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PaymentBill&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;userTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;warehouseTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;businessTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;userAccountService&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bill&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMoney&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;warehouseService&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;deliver&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bill&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getItems&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;businessAccountService&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;receipt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bill&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMoney&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;userTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;warehouseTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;businessTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;userTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;warehouseTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;businessTransaction&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;开启三个事务，提交三个事务，或回滚三个事务。保证多个事务要么全部成功，要么全部失败。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2PC协议&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;准备阶段：投票阶段，协调者询问事务的所有参与者是否准备好提交。&lt;/li&gt;
&lt;li&gt;提交阶段：执行阶段，协调者如果在上一个阶段收到所有事务参与者回复的可提交消息，则先自己在本地持久化事务为commit状态，然后给所有参与者发送commit指令。所有参与者立刻执行提交操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;mermaid style="margin-bottom: 0px"&gt;
&lt;p&gt;sequenceDiagram
协调者 -&amp;raquo;+ 参与者: 要求所有参与者进入准备阶段
参与者 &amp;ndash;&amp;raquo;- 协调者: 已进入准备阶段
协调者 -&amp;raquo;+ 参与者: 要求所有参与者进入提交阶段
参与者 &amp;ndash;&amp;raquo;- 协调者: 已进入提交阶段
opt 失败或超时
协调者 -&amp;raquo;+ 参与者: 要求所有参与者回滚事务
参与者 &amp;ndash;&amp;raquo;- 协调者: 已回滚事务
end
&lt;/mermaid&gt;&lt;/p&gt;
&lt;p&gt;:::center
图 3-1 两段式提交的交互时序示意图
:::&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754644931270_1754644931355.png"
loading="lazy"
alt="1754644931270.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2PC能够保证一致性的前提条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络在提交阶段必须是可靠的，不能在提交阶段丢失消息。如果投票阶段失败还可以执行回滚操作，但如果提交阶段失败就无法补救。&lt;/li&gt;
&lt;li&gt;必须假设在网络分区、机器崩溃或者其他原因导致的节点失联最终能够回复，不会永久性地失联。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;2PC的缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单点问题：协调者在两阶段提交中具有举足轻重的作用，协调者在等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理。&lt;/p&gt;
&lt;p&gt;如果协调者宕机，就没法正常发送Commit或者RollBack指令，所有参与者都必须一直等待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能问题：所有参与者都相当于绑定成一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record）。必须等待执行最慢的参与者执行完毕后，才算事务提交，所以性能较差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性风险：尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事务状态，并提交自己的事务，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一部分提交了事务，一部分未提交，导致事务无法回滚。产生数据不一致问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3PC协议&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754645818202_1754645818239.png"
loading="lazy"
alt="1754645818202.png"
&gt;&lt;/p&gt;
&lt;p&gt;三段式提交对单点问题和回滚时的性能问题有所改善，但是它对一致性风险问题并未有任何改进，在这方面它面临的风险甚至反而是略有增加了的。譬如，进入 PreCommit 阶段之后，协调者发出的指令不是 Ack 而是 Abort，而此时因网络问题，有部分参与者直至超时都未能收到协调者的 Abort 指令的话，这些参与者将会错误地提交事务，这就产生了不同参与者之间数据不一致的问题。&lt;/p&gt;
&lt;h3 id="共享事务"&gt;共享事务
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;多个服务共用同一个数据源。伪需求，不应当存在的场景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用一个公共的交易服务器来与数据库连接，无论上游有多少个不同的服务器，都需要请求交易服务器来实现数据库操作。从而达到共享事务的效果。（但使原本分散的负载又重新聚合了）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754882685058_1754882685070.png"
loading="lazy"
alt="1754882685058.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将多个服务的事务，通过聚合到一个服务代理，转换成一个本地事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用消息队列让多个服务来处理任务也算是共享事务的一个变种&lt;/p&gt;
&lt;h3 id="分布式事务"&gt;分布式事务
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;多个服务同时访问多个数据源的事务处理机制，在分布式创建下的事务处理机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CAP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/cap.290d0a22.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一致性（C）：数据在任何时刻、任何分布式节点中所看到的都是符合逾期的。&lt;/li&gt;
&lt;li&gt;可用性（A）：系统不间断地提供服务的能力。
&lt;ol&gt;
&lt;li&gt;可靠性：根据平均无故障时间来度量&lt;/li&gt;
&lt;li&gt;可维护性：平均可修复时间来度量&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分区容错性（P）：分布式环境中，部分节点因网络原因而彼此失联后，与其他节点形成网络分区，系统仍能正确地提供服务的能力。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如何取舍CAP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如果放弃分区容错性（CA）&lt;/strong&gt;：所有节点之间的通讯永远都是可靠的。（永远可靠的通讯在分布式场景下必定不存在）不可能的选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如果放弃可用性（CP）&lt;/strong&gt;：一旦网络发生了分区，节点之间的信息同步可以无限制的延长。类似于前面的全局事务一致性问题，可以通过2PC/3PC手段，来获得分区容错性和一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CP下系统一般用于对数据质量要求很高的场景中。如果发生错误，服务就下线，不再提供服务，等待恢复后才提供服务。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如果放弃一致性（AP）&lt;/strong&gt;：一旦发生分区，节点之间提供的数据可能不一致。（目前分布式系统的主流选择）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高可用一般是一个分布式系统建立的主要目的，如果为了保证一致性而放弃高可用，那不如不做分布式&lt;/strong&gt;（银行类的金融系统除外）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;事务出现的初衷就是为了保证一致性，在AP分布式场景下，一致性反而无法得到保证。于是为了回到初衷，又提出了最终一致性的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;最终一致性：如果数据在一段时间之内没有被另外的操作所更改，那它最终将会达到与强一致性过程相同的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="可靠事件队列最大努力交付"&gt;可靠事件队列（最大努力交付）
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754891613491_1754891613521.png"
loading="lazy"
alt="1754891613491.png"
&gt;&lt;/p&gt;
&lt;p&gt;目前需要做三个操作，账号扣款、商家账号收款、库存商品出库。&lt;/p&gt;
&lt;p&gt;三个操作中账号扣款最容易出现问题，其次扣库存容易出错，收款环节最不容易出现问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般设计时把最容易出现问题的操作放在最前面，这样出现问题回滚的代价最小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;扣款：先开启一个本地事务，进行扣款和写入消息操作。如果扣款成功，就在自己本地的数据库中建立一张消息表，存入一条消息，状态为：扣款已完成，出库进行中、收款进行中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果扣款过程出现错误，就不需要进行写入消息等操作。利用一个本地事务完成最大规模的筛选。&lt;/p&gt;
&lt;p&gt;扣款成功后，后面的扣减库存和收款操作没有先后顺序，可以同时进行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;收款成功、扣减库存成功：把两个消息状态都修改成已完成，整个事务结束，达到最终一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扣减库存或收款出现网络问题：账号服务一直没有收到消息。账号服务一直重复向未响应的服务重复发送消息。（扣减库存和收款服务一定要实现幂等性）可以同每个事务唯一的事务ID来实现幂等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;库存服务或收款服务无法完成工作：没有库存或者无法收款。账号服务会不断重复发送消息直到成功为止。或者人工介入处理。&lt;strong&gt;通过事件队列来处理的分布式事务没有失败回滚的概念，只许成功，不许失败。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;收款和库存服务都成功后，由于网络原因导致回复给账号服务的消息丢失：账号服务会不断地重复给收款和库存服务发送消息，由于已做幂等操作，收到重复消息后，收款和库存服务会再次给账号服务发送成功消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP协议中，如果未收到ACK应答自动重新发送包的可靠性保障就属于最大努力交付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;可靠消息会不断的重试操作，会造成大量无畏消耗。&lt;/li&gt;
&lt;li&gt;所有操作只许成功，如果必定会失败，就会无限重试。死循环。&lt;/li&gt;
&lt;li&gt;没有任何隔离性可言，可能会出现“超售”情况。每个人购买的数量都没有超过最大数量，但加起来超过了最大数量。（会导致一个事务无限重试）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="tcc事务"&gt;TCC事务
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Try-Confirm-Cancel，如果事务需要隔离性，应重点考虑TCC。但对业务入侵性较强。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Try：尝试执行阶段，完成所有业务可执行性的检查（保证一致性），并且预留好全部需要用到的业务资源（保证隔离性）。&lt;/li&gt;
&lt;li&gt;Confirm：确认执行阶段，不进行任何业务检查，直接使用Try阶段准备的资源来完成业务处理。Confirm阶段可能会重复执行，此阶段需要做幂等性校验。&lt;/li&gt;
&lt;li&gt;Cancel：取消执行阶段，释放Try阶段预留的业务资源。Cancel阶段可能会重复执行，需要幂等性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754900636872_1754900636908.png"
loading="lazy"
alt="1754900636872.png"
&gt;&lt;/p&gt;
&lt;p&gt;业务场景与上方相同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建事务，生成事务ID，记录到日志表中，进入Try阶段（一下所有服务调用没有先后顺序）：
&lt;ol&gt;
&lt;li&gt;用户服务：检查业务可行性，可行，将用户100元设置为冻结状态，（占用额度），通知下一步进入Confirm阶段；不可行，通知下一步进入Cancel阶段。&lt;/li&gt;
&lt;li&gt;仓库服务：检查可行性，可行，冻结库存1（占用），通知下一步进入Confirm阶段；不可行，通知下一步进入Cancel阶段&lt;/li&gt;
&lt;li&gt;商家服务：检查业务可行性，不需要冻结资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果所有业务都可行，进入Confirm阶段：
&lt;ol&gt;
&lt;li&gt;用户服务：完成操作。进行扣款。&lt;/li&gt;
&lt;li&gt;仓库服务：按冻结数量扣减库存。&lt;/li&gt;
&lt;li&gt;商家服务：收款。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;全部完成后，事务正式结束，如果2中任意步骤出现异常，都需要重新执行Confirm操作，进行最大努力交付。&lt;/li&gt;
&lt;li&gt;如果1中业务任意不可行，或任意一个服务超时，则将活动日志置为Cancel，进入Cancel阶段：
&lt;ol&gt;
&lt;li&gt;用户服务：取消业务，释放冻结的100元&lt;/li&gt;
&lt;li&gt;仓库服务：取消业务，释放冻结的库存&lt;/li&gt;
&lt;li&gt;商家服务：取消业务，（大哭一场，然后安慰商家谋生不易:-)）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果4全部成功，事务最终置为失败，如果4中任意操作出现异常，就重复发送Concel操作，进行最大努力交付。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;优点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TCC与2PC逻辑类似，但TCC所有的操作都只操作预留的资源（预冻结或占用的资源），天生具有隔离性，几乎不涉及锁和资源的争用，拥有更好的性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;缺点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发成本高，对业务的侵入性较大，更大的更换成本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐使用阿里开源的&lt;a class="link" href="https://seata.io/zh-cn/" target="_blank" rel="noopener"
&gt;Seata&lt;/a&gt;来减少TCC代码开发的编码工作量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="saga事务一长串事件长篇故事"&gt;SAGA事务（一长串事件、长篇故事）
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;用来提升长时间事务运作效率的方法。避免大事务长时间锁定数据库的资源，将大事务分解成一系列本地事务的设计模式。&lt;/p&gt;
&lt;p&gt;性能最好，适用于无法使用Try阶段的事务，如目前盛行的网络支付，直接从银行转账等类似场景。（无法进行冻结、占用等操作）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大事务拆分成若干小事务，将整个分布式事务T分解成为n个子事务，命名为 T1，T2，…，Ti，…，Tn。每个子事务都应该是或者能被视为是原子行为。&lt;/li&gt;
&lt;li&gt;为每个子事务设计对应的补偿动作，命名为 C1，C2，…，Ci，…，Cn。Ti与 Ci必须满足以下条件：
&lt;ul&gt;
&lt;li&gt;Ti和Ci都具备幂等性&lt;/li&gt;
&lt;li&gt;Ti和Ci满足交换律，先执行Ti还是先执行Ci，效果都是一样的&lt;/li&gt;
&lt;li&gt;Ci必须能成功提交，不能存在Ci本身提交失败回滚的情况，如果出现就必须持续重试直到成功，或者直接人工介入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果所有的Ti都成功提交，那事务顺利完成，否则执行恢复策略&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;正向恢复&lt;/strong&gt;：如果Ti事务提交失败，则一直对Ti进行重试，直到成功为止（最大努力交付）。不需要补偿，适用于事务最终都要成功的场景。&lt;/p&gt;
&lt;p&gt;正向恢复的执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;反向恢复&lt;/strong&gt;：如果Ti事务提交失败，则一直执行Ci对Ti进行补偿，直到成功为止（最大努力交付）。Ci必须执行成功。&lt;/p&gt;
&lt;p&gt;反向恢复的执行模式为：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;与TCC对比，SAGA不需要为资源设计冻结状态和撤销冻结的操作，补偿要比冻结操作容易得多。&lt;/p&gt;
&lt;p&gt;譬如，前面提到的账号余额直接在银行维护的场景，从银行划转货款到 Fenix&amp;rsquo;s Bookstore 系统中，这步是经由用户支付操作（扫码或 U 盾）来促使银行提供服务；如果后续业务操作失败，尽管我们无法要求银行撤销掉之前的用户转账操作，但是由 Fenix&amp;rsquo;s Bookstore 系统将货款转回到用户账上作为补偿措施却是完全可行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="透明多级分流系统"&gt;透明多级分流系统
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如何分配流量，均衡负载等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="客户端缓存"&gt;客户端缓存
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;分为强制缓存和协商缓存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;强制缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;浏览器本地设置的缓存，不用与服务器交互就可以得知什么时候需要失效&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max-age&lt;/code&gt; / &lt;code&gt;s-maxage&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;相对时间控制缓存有效期，避免客户端时间误差&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;public&lt;/code&gt; / &lt;code&gt;private&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否允许代理或 CDN 缓存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;no-cache&lt;/code&gt; / &lt;code&gt;no-store&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;禁止缓存或禁止保存资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;no-transform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;禁止 CDN 等修改资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;min-fresh&lt;/code&gt; / &lt;code&gt;only-if-cached&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;控制客户端请求行为&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;must-revalidate&lt;/code&gt; / &lt;code&gt;proxy-revalidate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;资源过期后必须重新验证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;协商缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;资源过期之后，通过与服务器交互来判断是否重新获取资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两种机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Last-Modified / If-Modified-Since&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;通过资源最后修改时间判断是否更新。&lt;/li&gt;
&lt;li&gt;精度有限，可能误判。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ETag / If-None-Match&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;通过资源唯一标识判断是否更新。&lt;/li&gt;
&lt;li&gt;一致性强，但服务器计算开销大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;两者可同时使用，优先验证 ETag，再比对 Last-Modified。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="域名解析"&gt;域名解析
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过DNS来进行网络分流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DNS解析的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端先检查本地的DNS缓存，查看是否存在并且是存活着的该域名的地址记录。&lt;/li&gt;
&lt;li&gt;客户端把地址发送给操作系统中配置的本地DNS（Local DNS），这个本地DNS地址可以由用户手工设置，也可以在DNCP分配时或者在拨号时从PPP服务器中自动获取。&lt;/li&gt;
&lt;li&gt;本地DNS收到查询请求后，会按照“是否有&lt;code&gt;www.icyfenix.com.cn&lt;/code&gt;的权威服务器”→“是否有&lt;code&gt;icyfenix.com.cn&lt;/code&gt;的权威服务器”→“是否有&lt;code&gt;com.cn&lt;/code&gt;的权威服务器”→“是否有&lt;code&gt;cn&lt;/code&gt;的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。&lt;/li&gt;
&lt;li&gt;假设本地DNS是全新的，按照步骤3的顺序查询到根服务器后，它将会得到“&lt;code&gt;cn&lt;/code&gt;的权威服务器”的地址记录，然后通过“&lt;code&gt;cn&lt;/code&gt;的权威服务器”，得到“&lt;code&gt;com.cn&lt;/code&gt;的权威服务器”的地址记录，以此类推，最后找到能够解释&lt;code&gt;www.icyfenix.com.cn&lt;/code&gt;的权威服务器地址。&lt;/li&gt;
&lt;li&gt;通过“&lt;code&gt;www.icyfenix.com.cn&lt;/code&gt;的权威服务器”，查询&lt;code&gt;www.icyfenix.com.cn&lt;/code&gt;的地址记录，地址记录并不一定就是指 IP 地址，在 RFC 规范中有定义的地址记录类型已经&lt;a class="link" href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" target="_blank" rel="noopener"
&gt;多达数十种&lt;/a&gt;，譬如 IPv4 下的 IP 地址为 A 记录，IPv6 下的 AAAA 记录、主机别名 CNAME 记录，等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;权威域名服务器：负责翻译特定域名的DNS服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根域名服务器：固定的、无需查询的顶级域名服务器，全世界一共13组根域名服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过NDS进行分流：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;智能线路：根据访问者所处的不同地区（譬如华北、华南、东北）、不同服务商（譬如电信、联通、移动）等因素来确定返回最合适的 A 记录，将访问者路由到最合适的数据中心，达到智能加速的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="传输链路"&gt;传输链路
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;优化流量传输的链路，从而达到减少请求的效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前端优化方式（只是看看）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class="link" href="https://developer.yahoo.com/performance/rules.html" target="_blank" rel="noopener"
&gt;雅虎 YSlow-23 条规则&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接数优化（优化TCP）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP3.0之前的网络都是基于TCP实现的，3.0基于UDP实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前大部分流量的特征如下：&lt;/p&gt;
&lt;p&gt;数量多，时间短，资源小，切换快。&lt;/p&gt;
&lt;p&gt;TCP协议必须在三次握手完成之后才能开始数据传输，可能会带来百毫秒的开销。&lt;/p&gt;
&lt;p&gt;TCP还有慢启动的特性，使得刚刚建立连接时传输速度是最低的，后面在逐步加速直到稳定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP慢启动：避免发送过多数据到网络中而导致网络阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;长期持有连接（已过时）：&lt;/p&gt;
&lt;p&gt;持久连接的原理是让客户端对同一个域名长期持有一个或多个不会用完即断的 TCP 连接。典型做法是在客户端维护一个 FIFO 队列，每次取完数据（如何在不断开连接下判断取完数据将会放到稍后&lt;a class="link" href="https://icyfenix.cn/architect-perspective/general-architecture/diversion-system/transmission-optimization.html#%e4%bc%a0%e8%be%93%e5%8e%8b%e7%bc%a9" target="_blank" rel="noopener"
&gt;传输压缩&lt;/a&gt;部分去讨论）之后一段时间内不自动断开连接，以便获取下一个资源时直接复用，避免创建 TCP 连接的成本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;可能会出现队首阻塞问题，如果队首的TCP连接需要传输的数据一直处于阻塞，导致后面的操作即使可以进行，也会被阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决队首阻塞问题：让客户端一次将所有需要请求的资源全部发送给服务器，由服务器安排返回的顺序，管理传输队列。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;HTTP/2多路复用：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过一个TCP连接，让所有的数据以帧的形式传递，通过每个帧附带的流id，把多个流的数据按照各自流组装区分开。这样可以做到只使用同一个TCP连接来传输多个不同的HTTP请求和响应报文。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/http2-con.f8b394df.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;有了HTTP2的多路复用后，客户端和每个域名只需要建立一个TCP连接，减轻了服务器的连接压力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可靠传输机制：如果TCP传输过程中，如果有一个包出现错误，那所有的流都需要等待这个包重传成功后，才能组装。（为了避免因为少包导致组装出错误的数据）
&lt;strong&gt;上述情况在基于UDP的HTTP3中给出了解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP2和HTTP1对比，由于TCP自身的可靠传输机制，导致2并不是在所有方面的优于1。&lt;/p&gt;
&lt;p&gt;HTTP1：每个TCP请求都是独立的连接，一个TCP同时只能处理一个请求，这样更适合传输大文件。（不需要在本地进行组装。）
HTTP2：一个客户端与一个域名通常只有一个连接，由于多个请求共用同一个TCP连接，导致传输数据量变大，而且需要进行本地组合，如果中间某个包出现错误，那所有的请求都不能被处理。&lt;strong&gt;所以HTTP2更适合处理小文件传输&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;传输压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通过压缩传输的数据大小实现连接优化的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体有&lt;a class="link" href="http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html" target="_blank" rel="noopener"
&gt;静态预压缩&lt;/a&gt;和“&lt;a class="link" href="https://www.usenix.org/legacy/publications/library/proceedings/jvm01/full_papers/hovemeyer/hovemeyer_html/node7.html" target="_blank" rel="noopener"
&gt;即时压缩&lt;/a&gt;两种实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基于UDP的HTTP3.0&lt;/strong&gt;（快速UDP网络连接）&lt;strong&gt;QUIC&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;QUIC：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754981650147_1754981650200.png"
loading="lazy"
alt="1754981650147.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;QUIC与TLS1.2的TCP握手比较&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当一个请求中某个包丢失了数据，由于UDP没有可靠传输机制，此连接依然可以给其他请求做处理，只有丢失包的请求有问题。即使一个请求发生了错误也不会影响到其他的请求。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754981623098_1754981623113.png"
loading="lazy"
alt="1754981623098.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;三种HTTP协议的对比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;QUIC在应用程序空间中实现的，而不在操作系统内核中实现。当数据在应用程序之间移动时，会存在上下文切换而带来额外开销。&lt;/p&gt;
&lt;h3 id="内容分发网络cdn"&gt;内容分发网络（CDN）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;更适合用来分发静态资源，动态资源反而不会有好效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;一个互联网系统的速度取决于4点因素&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;网站服务器接入网络运营商的链路所能提供的出口带宽&lt;/li&gt;
&lt;li&gt;客户端接入网络运营商的入口带宽。&lt;/li&gt;
&lt;li&gt;从网站到用户之间经过不同运营商之间互联网节点的带宽。&lt;/li&gt;
&lt;li&gt;从网站到用户之间的物理链路传输延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;路由解析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754984068873_1754984068982.png"
loading="lazy"
alt="1754984068873.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754984194582_1754984194618.png"
loading="lazy"
alt="1754984194582.png"
&gt;&lt;/p&gt;
&lt;p&gt;DNS服务器给浏览器返回的ip为CDN服务器，CDN代理请求源服务器起到加速的效果。&lt;/p&gt;
&lt;p&gt;如果CDN服务中直接有用户想要的资源，就直接返回。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内容分发（CDN服务器中的资源同步问题）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;资源同步主要有两种方式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;主动分发（push）：源网站主动发起分发，把内容从源网站或者其他资源库推送到用户边缘的各个CDN缓存节点上。&lt;strong&gt;甚至可以直接主动推送到浏览器本地的localStorage中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;被动回源&lt;/strong&gt;（Pull）：当某个资源首次被用户请求时，CDN服务器发现自己没有资源，就会实时从源网站中获取，然后缓存到CDN服务器本地。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如何判断CDN中缓存的内容是否失效&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;现在，最常见的做法是超时被动失效与手工主动失效相结合。超时失效是指给予缓存资源一定的生存期，超过了生存期就在下次请求时重新被动回源一次。而手工失效是指 CDN 服务商一般会提供给程序调用来失效缓存的接口，在网站更新时，由持续集成的流水线自动调用该接口来实现缓存更新，譬如“&lt;code&gt;icyfenix.cn&lt;/code&gt;”就是依靠&lt;a class="link" href="https://travis-ci.com/" target="_blank" rel="noopener"
&gt;Travis-CI&lt;/a&gt;的持续集成服务来触发 CDN 失效和重新预热的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="负载均衡"&gt;负载均衡
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;以统一的接口对外提供服务，调度后方的多台机器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OSI七层模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表 4-1 OSI 七层模型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;层&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;数据单元&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;应用层 Application Layer&lt;/td&gt;
&lt;td&gt;数据 Data&lt;/td&gt;
&lt;td&gt;提供为应用软件提供服务的接口，用于与其他应用软件之间的通信。典型协议：HTTP、HTTPS、FTP、Telnet、SSH、SMTP、POP3 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;表达层 Presentation Layer&lt;/td&gt;
&lt;td&gt;数据 Data&lt;/td&gt;
&lt;td&gt;把数据转换为能与接收者的系统格式兼容并适合传输的格式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;会话层 Session Layer&lt;/td&gt;
&lt;td&gt;数据 Data&lt;/td&gt;
&lt;td&gt;负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;传输层 Transport Layer&lt;/td&gt;
&lt;td&gt;数据段 Segments&lt;/td&gt;
&lt;td&gt;把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。典型协议：TCP、UDP、RDP、SCTP、FCP 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;网络层 Network Layer&lt;/td&gt;
&lt;td&gt;数据包 Packets&lt;/td&gt;
&lt;td&gt;决定数据的传输路径选择和转发，将网络表头附加至数据段后以形成报文（即数据包）。典型协议：IPv4/IPv6、IGMP、ICMP、EGP、RIP 等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;数据链路层 Data Link Layer&lt;/td&gt;
&lt;td&gt;数据帧 Frame&lt;/td&gt;
&lt;td&gt;负责点对点的网络寻址、错误侦测和纠错。当表头和表尾被附加至数据包后，就形成数据帧（Frame）。典型协议：WiFi（802.11）、Ethernet（802.3）、PPP 等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;物理层 Physical Layer&lt;/td&gt;
&lt;td&gt;比特流 Bit&lt;/td&gt;
&lt;td&gt;在物理网络上传送数据帧，它负责管理电脑通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;数据链路层负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/l2-lb.42b825ec.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过修改目标服务器的mac地址来实现负载均衡，无法跨子网，只能在有限的空间下做负载均衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;网络层负载均衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754985460755_1754985460951.png"
loading="lazy"
alt="1754985460755.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层实现的负载均衡（最常用的负载均衡手段之一）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/l4l7.5410d0a6.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡策略和实现&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轮循均衡&lt;/strong&gt;（Round Robin）：每一次来自网络的请求轮流分配给内部中的服务器，从 1 至 N 然后重新开始。此种均衡算法适合于集群中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权重轮循均衡&lt;/strong&gt;（Weighted Round Robin）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。譬如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接收到 10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;随机均衡&lt;/strong&gt;（Random）：把来自客户端的请求随机分配给内部中的多个服务器，在数据足够大的场景下能达到相对均衡的分布。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权重随机均衡&lt;/strong&gt;（Weighted Random）：此种均衡算法类似于权重轮循算法，不过在分配处理请求时是个随机选择的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性哈希均衡&lt;/strong&gt;（Consistency Hash）：根据请求中某一些数据（可以是 MAC、IP 地址，也可以是更上层协议中的某些参数信息）作为特征值来计算需要落在的节点上，算法一般会保证同一个特征值每次都一定落在相同的服务器上。一致性的意思是保证当服务集群某个真实服务器出现故障，只影响该服务器的哈希，而不会导致整个服务集群的哈希键值重新分布。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应速度均衡&lt;/strong&gt;（Response Time）：负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最少连接数均衡&lt;/strong&gt;（Least Connection）：客户端的每一次请求服务在服务器停留的时间可能会有较大的差异，随着工作时间加长，如果采用简单的轮循或随机均衡算法，每一台服务器上的连接进程可能会产生极大的不平衡，并没有达到真正的负载均衡。最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡策略适合长时处理的请求服务，如 FTP 传输。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="服务器缓存重点"&gt;服务器缓存（重点）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;用空间换时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;缓存用来做什么？&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;缓解CPU压力做缓存：（记忆化搜索）&lt;/p&gt;
&lt;p&gt;把方法运行的结果存储起来、把原本要实时计算的内容提前算好、让一些公共资源可以复用，这样可以节省CPU算力，顺带提升响应性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓解IO压力而做缓存：&lt;/p&gt;
&lt;p&gt;把对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写变为到可伸缩部件（如缓存中间件）的访问，顺便提升响应性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="缓存属性"&gt;缓存属性
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;缓存主要分四个维度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：缓存的吞吐量使用OPS值（每秒操作数）来衡量，反映了对缓存进行并发读写操作的效率，即缓存本身的工作效率高低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的进程内缓存吞吐量&lt;/p&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/readwrite.a9f305af.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环形缓存&lt;/strong&gt;（直接内存等）&lt;/p&gt;
&lt;p&gt;它是一种拥有读、写两个指针的数据复用结构。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/Circular_Buffer_Animation.c3d3d834.gif"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;命中率与淘汰策略&lt;/strong&gt;：成功从缓存中返回结果次数与总请求次数的比值，反映了引入缓存的价值高低，命中率越低，收益越小，价值越低。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;任何缓存的容量都不可能是无限的，命中率是为了考虑空间消耗和节约时间之间取平衡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本的三种淘汰策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FIFO（First In First Out）：先入先出，最先入缓的数据最先被淘汰，可以通过一个固定容量限制的队列来实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常被用到数据，越是有可能最早的进入缓存，如果使用特别频繁，可能会大幅度降低缓存的命中率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LRU（Least Recent Used）：优先淘汰最久未被访问过的数据。LRU通常采用HashMap 加 LinkedList 双重结构（如 LinkedHashMap）来实现，HashMap提供数据访问，LinkedList实现动态修改节点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果某个热点数据，由于一些特殊原因一段时间内没有被访问，可能会导致热点数据被错误的淘汰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LFU（Least Frequently Used）：优先淘汰最不经常被使用的数据。LFU给每个数据添加一个访问计数器，每访问一次就加1，需要淘汰时就清理计数器数值最小的那批数据。（有点类似于JVM的分代升级机制）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以解决上面提到的特殊原因热点数据没有被访问问题，但同时也引入了新的问题：1、每个缓存的数据都需要维护一个计数器。2、如果某个极其经常被访问的数据失效了。通过LFU也无法被清理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TinyLFU&lt;/strong&gt;（Tiny Least Frequently Used）：使用少量的样本数据来评估整体的情况，将缓存的数据分类，通过维护某类数据的访问次数，来评估这些数据的淘汰与否。（常见的是可以用布隆过滤器来实现等价的分类）&lt;/p&gt;
&lt;p&gt;为了解决极其热点数据过期的问题，采用滑动窗口来统计一部分数据的使用计数情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但如果访问热点数据非常稀疏，也就是说分类无效的时候，反而不知道该如何清理了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a class="link" href="https://arxiv.org/pdf/1512.00727.pdf" target="_blank" rel="noopener"
&gt;W-TinyLFU&lt;/a&gt;&lt;/strong&gt;（Windows-TinyLFU）：同样采用TinyLFU的缓存机制，但是分类后，局部采用LRU的形式来淘汰数据，通过LFU来确定哪些块需要被淘汰，然后通过LRU只淘汰需要被淘汰的数据的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几种缓存命中率的情况&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754989995230_1754989995250.png"
loading="lazy"
alt="1754989995230.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;扩展功能&lt;/strong&gt;：除了基本的读写功能外，还提供了哪些额外的管理功能，如最大容量、失效时间、失效事件、命中率统计等。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;加载器&lt;/strong&gt;：许多缓存都有“CacheLoader”之类的设计，加载器可以让缓存从只能被动存储外部放入的数据，变为能够主动通过加载器去加载指定 Key 值的数据，加载器也是实现自动刷新功能的基础前提。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;淘汰策略&lt;/strong&gt;：有的缓存淘汰策略是固定的，也有一些缓存能够支持用户自己根据需要选择不同的淘汰策略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;失效策略&lt;/strong&gt;：要求缓存的数据在一定时间后自动失效（移除出缓存）或者自动刷新（使用加载器重新加载）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件通知&lt;/strong&gt;：缓存可能会提供一些事件监听器，让你在数据状态变动（如失效、刷新、移除）时进行一些额外操作。有的缓存还提供了对缓存数据本身的监视能力（Watch 功能）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发级别&lt;/strong&gt;：对于通过分段加锁来实现的缓存（以 Guava Cache 为代表），往往会提供并发级别的设置。可以简单将其理解为缓存内部是使用多个 Map 来分段存储数据的，并发级别就用于计算出使用 Map 的数量。如果将这个参数设置过大，会引入更多的 Map，需要额外维护这些 Map 而导致更大的时间和空间上的开销；如果设置过小，又会导致在访问时产生线程阻塞，因为多个线程更新同一个 ConcurrentMap 的同一个值时会产生锁竞争。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容量控制&lt;/strong&gt;：缓存通常都支持指定初始容量和最大容量，初始容量目的是减少扩容频率，这与 Map 接口本身的初始容量含义是一致的。最大容量类似于控制 Java 堆的-Xmx 参数，当缓存接近最大容量时，会自动清理掉低价值的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用方式&lt;/strong&gt;：支持将数据设置为软引用或者弱引用，提供引用方式的设置是为了将缓存与 Java 虚拟机的垃圾收集机制联系起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计信息&lt;/strong&gt;：提供诸如缓存命中率、平均加载时间、自动回收计数等统计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久化&lt;/strong&gt;：支持将缓存的内容存储到数据库或者磁盘中，进程内缓存提供持久化功能的作用不是太大，但分布式缓存大多都会考虑提供持久化功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分布式支持&lt;/strong&gt;：缓存由外部提供，访问缓存需要通过网络，缓存中的数据可以在各个服务节点中共享。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="分布式缓存"&gt;分布式缓存
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;缓存的读取&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;复制式缓存：能够支持分布式的进程内缓存，（如tomcat的全量复制模式，将tomcat中的Session信息全部复制一遍，从而达到session共享的目的）。读取数据时无需网络访问，直接从进程内存中返回，性能极高。当数据发生变化时，必须遵守复制协议，将变更同步给集群内的每个节点中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;读取性能极高，但修改代价过于高昂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中式缓存：（redis），读写都需要网络访问，不会随着集群节点的增加而产生额外的负担，但读写的性能无法到达进程内部缓存的高性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;数据一致性&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;这部分其实就是之前事务中提到的CAP理论，都只能尽量的达到最终一致性，不能做到单机ACID的强一致性。&lt;/p&gt;
&lt;p&gt;redis集群就是典型的AP式，性能高，但不保证强一致性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以保证强一致性的有：ZooKeeper、Doozerd、Etcd等框架。
虽然可以保证强一致性，但吞吐量等和redis根本不是一个量级。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Q：既然有了分布式缓存，为什么还要引入二级缓存？&lt;/p&gt;
&lt;p&gt;A：分布式缓存每次访问都需要网络通讯，引入分布式加本地的二级缓存机制，只要缓存不失效，从第二次其的所有读取都不再需要网络请求，大大的提高了读取性能。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1754995844029_1754995844070.png"
loading="lazy"
alt="1754995844029.png"
&gt;&lt;/p&gt;
&lt;p&gt;Q：如何保证二级缓存的一致性？&lt;/p&gt;
&lt;p&gt;A：必须实现缓存透明，变更以分布式缓存中的数据为准，访问（读取）以进程内的数据优先。如果数据发生变动时，在集群内发生通知（通知的方式：redis的PUB/SUB&lt;/p&gt;
&lt;p&gt;,或者Zookeeper或Etcd来处理），让各个节点的一级缓存中对应的数据自动失效。当访问缓存时，统一查询一、二级缓存联合查询，自动更新一级缓存。接口外部是只查询一次，接口内部自动实现优先查询一级缓存，未获取到数据再自动查询二级缓存的逻辑。&lt;/p&gt;
&lt;h4 id="缓存风险"&gt;缓存风险
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;缓存穿透&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;总是查询缓存中没有数据，达到跳过缓存访问数据库的情况。（如查数据库中根本不存在的数据）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;业务逻辑根本就不能避免的缓存穿透，可以约定一定时间内对返回为空的Key值依然进行缓存，使得一段时间内缓存不会被一个key而多次穿透。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;效果并不好，给缓存带来了更大的压力，且对恶意攻击的防御效果并不好。（我可以随机生成key来恶意访问，或查询一些根本不存的日期的数据，如1800年的数据）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;防止恶意攻击，可以使用布隆过滤器来解决。如果布隆过滤器中不存在的key，就直接返回结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;成本为需要在本地维护一个布隆过滤器，布隆过滤器对有效值的一致性不需要特别的实时，但对于空值需要较高的一致性，不能出现缓存中有，布隆过滤器中没有的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;缓存击穿&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;某个热key突然失效了，导致大量的请求被打到数据库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加锁同步，对请求该数据的key值加锁，使只有第一个请求会进入数据库，其他线程阻塞或者重试。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现复杂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;热点数据由代码来手动管理，对于热点数据，有代码来有计划的完成更新、失效，避免由同步策略来管理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有个思路，感觉可以模仿mysql的redo来动态实现缓存的更新和失效。修改的数据先不同步数据库，通过日志来定期刷库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;缓存雪崩&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;大量的热点数据短时间内一起失效。（热点数据同时创建，且超时时间一样。）短时间给数据库带来了极大的压力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出现上面情况的原因为大量的热点数据被同时加载预热：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提升缓存系统的可用性，建立分布式缓存的集群。如主节点数据失效，去从节点看看是否还在。&lt;/li&gt;
&lt;li&gt;透明的多级缓存，每个服务的一级缓存中的数据都有不一样的加载时间，分散了过期时间。&lt;/li&gt;
&lt;li&gt;同时被预热的缓存数据，把过期时间设置成一段时间内的随机数，负载均衡了过期时间，避免大规模同时失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;缓存污染&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;缓存中的数据与数据库中的数据不一致。（最终一直性没有得到保证）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;产生原因：&lt;/p&gt;
&lt;p&gt;数据库中的数据发生回滚（缓存中存放了回滚前的数据）&lt;/p&gt;
&lt;p&gt;写入缓存失败（缓存中为旧数据）&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方案多种多样，这里只列出redis常用的Cache Aside 方式，后续讨论分布式一致性时详细介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求。&lt;/li&gt;
&lt;li&gt;写数据时，先写数据源，然后失效（而不是更新）掉缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么不使用延时双删？&lt;/p&gt;
&lt;p&gt;延时双删逻辑为过一段时候后再删除一次数据，时间在分布式系统中并不可靠，先发未必先至，后发未必后至。不如直接让缓存失效，把数据一致性问题交给缓存和数据库同步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;依然有问题：如果写操作在查询操作之后，查询到的数据可能为过期的数据。&lt;/p&gt;
&lt;h2 id="架构安全性"&gt;架构安全性
&lt;/h2&gt;&lt;h3 id="认证"&gt;认证
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何正确的分辨出操作用户的真实身份&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实登录就是一个简单的认证操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP认证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有支持HTTP协议的服务器，在未授权的用户意图访问服务端保护区域资源时，应返回 401 Unauthorized 的状态码。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755002396893_1755002396907.png"
loading="lazy"
alt="1755002396893.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只面向传输的协议进行认证，与内容无关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Web认证（表单认证）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;身份认证由应用程序本身的功能完成，而不是由HTTP服务器来负责认证。依靠内容而不是传输协议来实现的认证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;WebAuthn 规范涵盖了“注册”与“认证”两大流程，先来介绍注册流程，它大致可以分为以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebAuthn的注册：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;用户进入系统的注册页面，这个页面的格式、内容和用户注册时需要填写的信息均不包含在 WebAuthn 标准的定义范围内。&lt;/li&gt;
&lt;li&gt;当用户填写完信息，点击“提交注册信息”的按钮后，服务端先暂存用户提交的数据，生成一个随机字符串（规范中称为 Challenge）和用户的 UserID（在规范中称作凭证 ID），返回给客户端。&lt;/li&gt;
&lt;li&gt;客户端的 WebAuthn API 接收到 Challenge 和 UserID，把这些信息发送给验证器（Authenticator），验证器可理解为用户设备上 TouchID、FaceID、实体密钥等认证设备的统一接口。&lt;/li&gt;
&lt;li&gt;验证器提示用户进行验证，如果支持多种认证设备，还会提示用户选择一个想要使用的设备。验证的结果是生成一个密钥对（公钥和私钥），由验证器存储私钥、用户信息以及当前的域名。然后使用私钥对 Challenge 进行签名，并将签名结果、UserID 和公钥一起返回客户端。&lt;/li&gt;
&lt;li&gt;浏览器将验证器返回的结果转发给服务器。&lt;/li&gt;
&lt;li&gt;服务器核验信息，检查 UserID 与之前发送的是否一致，并用公钥解密后得到的结果与之前发送的 Challenge 相比较，一致即表明注册通过，由服务端存储该 UserID 对应的公钥。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755002701944_1755002701958.png"
loading="lazy"
alt="1755002701944.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WebAuthn的认证&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;用户访问登录页面，填入用户名后即可点击登录按钮。&lt;/li&gt;
&lt;li&gt;服务器返回随机字符串 Challenge、用户 UserID。&lt;/li&gt;
&lt;li&gt;浏览器将 Challenge 和 UserID 转发给验证器。&lt;/li&gt;
&lt;li&gt;验证器提示用户进行认证操作。由于在注册阶段验证器已经存储了该域名的私钥和用户信息，所以如果域名和用户都相同的话，就不需要生成密钥对了，直接以存储的私钥加密 Challenge，然后返回给浏览器。&lt;/li&gt;
&lt;li&gt;服务端接收到浏览器转发来的被私钥加密的 Challenge，以此前注册时存储的公钥进行解密，如果解密成功则宣告登录成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="授权"&gt;授权
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何控制一个用户该看到哪些数据、能操作哪些数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;授权主要包括两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确保授权过程可靠：让第三方系统能够访问的所需的资源，又能保证其不泄露用户敏感数据。（OAuth2和SAML2.0）&lt;/li&gt;
&lt;li&gt;确保授权的结果可控：对应用程序功能或者资源的访问控制，具体分几种：自主访问控制，强制访问控制，基于属性的访问控制，基于角色访问控制（常用）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RBAC（基于角色的权限控制）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;所有的访问控制模型，实质上都是在解决同一个问题：“&lt;strong&gt;谁&lt;/strong&gt;（User）拥有什么&lt;strong&gt;权限&lt;/strong&gt;（Authority）去&lt;strong&gt;操作&lt;/strong&gt;（Operation）哪些&lt;strong&gt;资源&lt;/strong&gt;（Resource）”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755052415482_1755052415497.png"
loading="lazy"
alt="1755052415482.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755052991246_1755052991275.png"
loading="lazy"
alt="1755052991246.png"
&gt;&lt;/p&gt;
&lt;p&gt;为了避免给每个用户设定权限，将权限从用户身上剥离，改为绑定到角色上。&lt;/p&gt;
&lt;p&gt;将权限控制变为对“&lt;strong&gt;角色&lt;/strong&gt;拥有操作哪些&lt;strong&gt;资源&lt;/strong&gt;的&lt;strong&gt;许可&lt;/strong&gt;”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAuth2&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;国际标准，面向于解决第三方应用的认证授权协议。授权以令牌的形式实现，令牌难以主动失效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接把账号和密码交给第三方会导致如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;密码泄露，如果第三方被攻击，用户的密码就会泄露。&lt;/li&gt;
&lt;li&gt;访问范围：第三方有能力访问所有的用户数据，等同于拥有用户相同的权限。&lt;/li&gt;
&lt;li&gt;授权回收：只能通过用户自己修改密码来收回授权，同时如果用户修改了密码，那之前所有的授权都会失效。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755054244022_1755054244050.png"
loading="lazy"
alt="1755054244022.png"
&gt;&lt;/p&gt;
&lt;p&gt;OAuth2主要通过令牌的方式来给第三方授权。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OAuth2的四种授权方式，安全等级逐级下降&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;授权码模式（最严谨）：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755054423220_1755054461719.png"
loading="lazy"
alt="1755054423220.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;会不会有其他应用冒充第三方应用骗取授权？
ClientID 代表一个第三方应用的“用户名”，这项信息是可以完全公开的。但 ClientSecret 应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第 5 步发放令牌时，调用者必须能够提供 ClientSecret 才能成功完成。只要第三方应用妥善保管好 ClientSecret，就没有人能够冒充它。&lt;/li&gt;
&lt;li&gt;为什么要先发放授权码，再用授权码换令牌？
这是因为客户端转向（通常就是一次 HTTP 302 重定向）对于用户是可见的，换而言之，授权码可能会暴露给用户以及用户机器上的其他程序，但由于用户并没有 ClientSecret，光有授权码也是无法换取到令牌的，所以避免了令牌在传输转向过程中被泄漏的风险。&lt;/li&gt;
&lt;li&gt;为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？
这是为了缓解 OAuth2 在实际应用中的一个主要缺陷，通常访问令牌一旦发放，除非超过了令牌中的有效期，否则很难（需要付出较大代价）有其他方式让它失效，所以访问令牌的时效性一般设计的比较短，譬如几个小时，如果还需要继续用，那就定期用刷新令牌去更新，授权服务器就可以在更新过程中决定是否还要继续给予授权。至于为什么说很难让它失效，我们将放到下一节“&lt;a class="link" href="https://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials.html" target="_blank" rel="noopener"
&gt;凭证&lt;/a&gt;”中去解释。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐式授权：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755054655827_1755054655845.png"
loading="lazy"
alt="1755054655827.png"
&gt;&lt;/p&gt;
&lt;p&gt;授权服务器不验证第三方应用的身份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;密码凭证：类似于之前的直接提供密码&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755054833748_1755054833765.png"
loading="lazy"
alt="1755054833748.png"
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端模式：直接由“第三方”和授权服务器交互，中间没有资源所有者参与。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755054963728_1755054963740.png"
loading="lazy"
alt="1755054963728.png"
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="凭证"&gt;凭证
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;用户和系统之间确定操作的意图都是真实的，准确的、完整且不可抵赖的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单机应用时代，凭证主要由Cookie-Session实现，Session的服务器内部单机维护保证本次授权或状态可以得以正确的保持和销毁。&lt;/p&gt;
&lt;p&gt;分布式时代由于有CAP不可兼容原理的限制，导致不方便在单机上来维护状态和让状态销毁，于是采用JWT令牌的方式来实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cookie-Session&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP协议是无状态的协议，每次对事务处理没有上下文的记忆能力，每个请求都是相互独立的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session的实现&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Session是在Http协议中增加了Set-Cookie 指令，用户在收到Cookie后，后面一段时间内的每次 HTTP 请求中，以名为 Cookie 的 Header 附带着重新发回给服务端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务器根据Header中的cookie分辨出请求来自哪个用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安全&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;状态信息都存储于服务器，只要依靠客户端的&lt;a class="link" href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank" rel="noopener"
&gt;同源策略&lt;/a&gt;和 HTTPS 的传输层安全，保证 Cookie 中的键值不被窃取而出现被冒认身份的情况，就能完全规避掉上下文信息在传输过程中被泄漏和篡改的风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动下线&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Cookie-Session 方案的另一大优点是服务端有主动的状态管理能力，可根据自己的意愿随时修改、清除任意上下文信息，譬如很轻易就能实现强制某用户下线的这样功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Session共享&lt;/strong&gt;（CAP不可兼得）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;牺牲一致性：利用负载均衡算法，让固定用户的请求只会访问到固定的服务器&lt;/li&gt;
&lt;li&gt;牺牲可用性：每个节点都复制一份相同的Session，如果一个节点发生变动，通知所有服务都修改。&lt;/li&gt;
&lt;li&gt;牺牲分区容错性：把Session集中保存在一个所有节点都可以访问的集中存储（Redis），一旦存取Session的节点损坏或出现网络分区，整个集群就不能提供服务了。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;JWT&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;把状态信息存储在客户端，每次请求都携带回服务器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://icyfenix.cn/assets/img/jwt.b07b0d79.png"
loading="lazy"
alt="img"
&gt;&lt;/p&gt;
&lt;p&gt;JWT大致分三部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;令牌头：描述令牌的类型和使用的签名算法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;负载：令牌真正向服务器传输的消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;签名（一种哈希算法）：对象头中公开的签名算法，通过服务器特定的秘钥对前面两个部分加密，而来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;签名为了确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失任何信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;JWT的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何主动让令牌失效&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;JWT令牌一旦签发，理论上就和认证服务没有瓜葛了，到期之前始终有效。如果想要实现主动令牌失效，需服务端对需要失效的令牌加入到黑名单中，统一存到redis中。如果检测到黑名单令牌，就让他逻辑失效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容易遭受重放攻击&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;一旦请求被劫持，虽然因为签名无法修改内容，但是可以一直主动攻击服务器。&lt;/p&gt;
&lt;p&gt;真要处理重放攻击，建议的解决方案是在信道层次（譬如启用 HTTPS）上解决，而不提倡在服务层次（譬如在令牌或接口其他参数上增加额外逻辑）上解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只能携带有限的数据&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;由于请求在头中，HTTP本身没有约束header 的最大长度，但tomcat默认最大8kb，Nginx默认4kb。都决定了JWT令牌无法携带大量数据。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;&lt;strong&gt;必须考虑令牌在客户端如何存储&lt;/strong&gt;&amp;rdquo;:&lt;/p&gt;
&lt;p&gt;一旦JWT被泄露，就可以做任何事情。必须要保存的客户端考虑安全问题。&lt;/p&gt;
&lt;h3 id="保密"&gt;保密
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何保证数据无法被内外人员窃取、滥用。通过加密改变原有数据，即使未授权的用户获取了已加密的信息，因不知道如何解密，而无法了解真实内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="传输"&gt;传输
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;保证网络中额信息王法被窃听、篡改和冒充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;公钥加密，私钥解密：加密，用来给数据加密。&lt;/li&gt;
&lt;li&gt;私钥加密，公钥解密：签名，用来让公钥所有者验证私钥所有者的身份，防止私钥所有者发布的内容被篡改。（但内容可能会被获取）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表 5-1 三种密码学算法的对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;常见实现&lt;/th&gt;
&lt;th&gt;主要用途&lt;/th&gt;
&lt;th&gt;主要局限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;哈希摘要&lt;/td&gt;
&lt;td&gt;不可逆，即不能解密，所以并不是加密算法，只是一些场景把它当作加密算法使用。 易变性，输入发生 1 Bit 变动，就可能导致输出结果 50%的内容发生改变。 无论输入长度多少，输出长度固定（2 的 N 次幂）。&lt;/td&gt;
&lt;td&gt;MD2/4/5/6、SHA0/1/256/512&lt;/td&gt;
&lt;td&gt;摘要&lt;/td&gt;
&lt;td&gt;无法解密&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;对称加密&lt;/td&gt;
&lt;td&gt;加密是指加密和解密是一样的密钥。 设计难度相对较小，执行速度相对较块。 加密明文长度不受限制。&lt;/td&gt;
&lt;td&gt;DES、AES、RC4、IDEA&lt;/td&gt;
&lt;td&gt;加密&lt;/td&gt;
&lt;td&gt;要解决如何把密钥安全地传递给解密者。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;非对称加密&lt;/td&gt;
&lt;td&gt;加密和解密使用的是不同的密钥。 明文长度不能超过公钥长度。&lt;/td&gt;
&lt;td&gt;RSA、BCDSA、ElGamal&lt;/td&gt;
&lt;td&gt;签名、传递密钥&lt;/td&gt;
&lt;td&gt;性能与加密明文长度受限。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;传输安全层TlS协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755067065735_1755067273106.png"
loading="lazy"
alt="1755067065735.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端请求：&lt;/p&gt;
&lt;p&gt;客户端向服务器请求进行加密通讯，本次请求是明文的。并携带加密，混淆机制，协议版本等信息。和一个随机数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器回应：&lt;/p&gt;
&lt;p&gt;服务器收到请求后，回复客户端。并携带随机数，协议版本，加密信息等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端确认：&lt;/p&gt;
&lt;p&gt;客户端利用RSA等算法，生成一个新的随机数。通过三个随机数一起组成对称加密的私钥，后续对称加密都采用此秘钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端确认：&lt;/p&gt;
&lt;p&gt;服务器握手结束通知&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;TLS握手结束后，双方只使用随机生成的秘钥对称加密来处理请求。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>RPC和分布式一致性协议</title><link>https://thecoolboyhan.github.io/p/rpc%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/rpc%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/rpc%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/1.png" alt="Featured image of post RPC和分布式一致性协议" /&gt;&lt;blockquote&gt;
&lt;p&gt;高内据，低耦合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="eureka注册中心"&gt;Eureka注册中心
&lt;/h1&gt;&lt;h2 id="服务调用出现的问题"&gt;服务调用出现的问题
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;服务消费者如何获取服务提供者的地址信息？&lt;/li&gt;
&lt;li&gt;如果有多个提供者，消费者该如何选择？&lt;/li&gt;
&lt;li&gt;消费者如何得知服务提供者的健康状态？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://files.catbox.moe/6u23v0.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/13/HxGozhLEkCmOIdR.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h2 id="eureka步骤"&gt;Eureka步骤
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Eureka的搭建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/13/lEWqJ3bXQMoe6Ot.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务注册&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/13/NqiCh978pdXIkQU.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h1 id="ribbon负载均衡"&gt;Ribbon负载均衡
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;整体流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/13/dUHt74hZoxCBKvq.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h2 id="irule接口的策略"&gt;IRule接口的策略
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;RoundRobinRule：简单轮询列表来选择服务器，它是Rinbon默认的负载均衡规则。&lt;/li&gt;
&lt;li&gt;AvailabilityFilteringRule：对以下两种服务器进行忽略：（1）. 在默认情况下，这台服务器如果三次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级的增加。（2）.并发数过高的服务器，如果如果一个服务器的并发连接数过高，配置了AVailabilityFilteringRule的客户端也会将其忽略。并发连接数的上限可以由客户端的&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit属性进行配置。&lt;/li&gt;
&lt;li&gt;WeightedResponseTimeRule：为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。&lt;/li&gt;
&lt;li&gt;&lt;font color="red"&gt; ZoneAvoidanceRule&lt;/font&gt;：以区域可用的服务器进行服务器的选择。使用zone对服务器进行分类，这个zone可以理解为一个机房，一个机架等。而后再对 zone里的多个服务进行轮询。&lt;/li&gt;
&lt;li&gt;BestAvailableRule：忽略哪些短路的服务器，并选择并发数较低的服务器。&lt;/li&gt;
&lt;li&gt;RandomRule：随机选择一个可用的服务器。&lt;/li&gt;
&lt;li&gt;RetryRule：重试机制的选择逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;配置负载均衡的方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/14/DfgvCZ2GWR4Eqpc.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ribbon饥饿加载&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Rinbbon默认为懒加载，当需要时才会创建信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/14/l5UMncZFiQvVJw4.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/14/h5XeUkC3EStzTuj.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h1 id="nacos注册中心"&gt;Nacos注册中心
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Nacos是阿里巴巴的产品，现在是springcloud中的一个组件。相比Eureka功能更加丰富，在国内更受欢迎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="nacos服务多级概念"&gt;Nacos服务多级概念
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Nacos将相同的地区的机房的多个服务统一在一起作为一个集群，一个中心服务下有多个集群，一个集群对应一个地区的多个服务。相同集群的服务尽量调用相同集群的其他服务，本集群这样在地理上尽可能的减少了延迟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nacos默认不会采用集群就近调用，需要配置开启。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/XxZbBQhEesg7CmJ.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;优先访问本地集群，在本地集群内随机访问服务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;权重&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;权重设置在0~1之间。当权重设置为0时，不会去访问0权重的服务。&lt;/p&gt;
&lt;h2 id="环境隔离"&gt;环境隔离
&lt;/h2&gt;&lt;p&gt;Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层的隔离。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个命名隔间之间的服务无法互相访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="nacos和eureka的区别"&gt;Nacos和Eureka的区别
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;生产者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Eureka每30秒都会对每个服务进行健康检测。&lt;/p&gt;
&lt;p&gt;此心跳检测是由服务向Eureka发送请求。&lt;/p&gt;
&lt;p&gt;Nacos会把服务分为临时实例和非临时实例。&lt;/p&gt;
&lt;p&gt;临时实例Nacos会进行心跳检测，如果检测到心跳不跳动，就会直接清除掉此服务。&lt;/p&gt;
&lt;p&gt;非临时实例不会进行心跳检测，而是由Nacos主动发送请求来确认服务是否存活。如果检测不存活，Nacos也不会把此服务从列表中清除。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/L3HnvsjkaQN1B4g.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Eureka如果发现生产者服务有所改变，需要消费者主动去向Eureka去拉去服务信息。&lt;/p&gt;
&lt;p&gt;Nacos采用pull和push两种，既可以消费者主动去拉取服务信息，也可以由Nacos主动去通知消费者服务变动信息。&lt;/p&gt;
&lt;h2 id="统一配置管理"&gt;统一配置管理
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/uyS1gYtj2dQELxP.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;统一配置文件的读取和修改，需要修改appliocation.yml中的配置，spring启动过程中会在读取application.yml之前先读取bootstrap.yml文件，所以把统一的模板配置配置到bootstrap.yml中就可以了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/JudWmk1LNevFlT7.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置热更新&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在对应服务的controller上加@RefreshScope注解&lt;/li&gt;
&lt;li&gt;加入configurationProperties（prefix=&amp;ldquo;变量&amp;rdquo;），约定大于配置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="多环境配置共享"&gt;多环境配置共享
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;配置文件的优先级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/4OHEAXzUaItn6ZR.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h1 id="feign"&gt;Feign
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Feign客户端的配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/qEaPB1U49p6msbr.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;feign的自定义配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/Omjlzwx4SHQGYef.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/15/ucfMK5LeNJ2rOIj.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Feign的日志配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/16/NTJZeR8tp7Ek9qs.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h1 id="统一网关gateway"&gt;统一网关Gateway
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;zuul是基于servlet的实现，属于阻塞式编程。而springCloudGateway则是基于spring5中提供的webFlux，属于响应式编程的实现，具备更好的性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;统一网关的搭建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/16/LSucfhNUkx12wgM.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;断言工厂&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/16/RSOzkCm3QUlJYZq.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h1 id="docker"&gt;Docker
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;docker是一个快速交付应用，运行应用的技术：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以将程序，运行环境和依赖一起打包为一个镜像，可以迁移到任意Linux操作系统。&lt;/li&gt;
&lt;li&gt;运行时利用沙箱机制形成隔离容器，各个应用互不干扰。&lt;/li&gt;
&lt;li&gt;启动，移除都可以通过一行命令完成，方便快捷。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Docker如何解决依赖的兼容性问题的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将应用的Libs（函数库），Deps（依赖）、配置与应用一起打包。&lt;/li&gt;
&lt;li&gt;将每一个应用放到一个隔离容器中去运行，避免互相干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同环境的操作系统不同，Docker如何解决？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker和虚拟机的差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker是一个系统进程：虚拟机是在操作系统中的操作系统。&lt;/li&gt;
&lt;li&gt;docker体积小，启动速度快，性能好；虚拟机体积大，启动速度慢，性能一般。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/22/krGsg3iZOzYepWt.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker镜像都是只读的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;docker的架构&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/22/ZsbzvwWAVJyigmu.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h2 id="docker命令"&gt;docker命令
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;拉取镜像：docker pull redis:{版本}，不填版本默认下载最新版（latest）&lt;/li&gt;
&lt;li&gt;查看docker已安装镜像： docker images&lt;/li&gt;
&lt;li&gt;把docker安装的镜像保存到本地：docker save -o {本地存放镜像文件的目录，文件名以.tar结尾} 需要备份的镜像名：版本号。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;docker save -o /home/rose/work/docker_redis.tar redis:latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;删除docker中的镜像：docker rmi redis：latest&lt;/li&gt;
&lt;li&gt;把本地的镜像读取到doker中：docker load -i /home/rose/work/docker-redis.tar&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="docker-创建运行一个容器"&gt;docker 创建运行一个容器
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;docker run &amp;ndash;name containerName -p 80:80 -d nginx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;docker run：创建并运行一个容器&lt;/li&gt;
&lt;li&gt;&amp;ndash;name：给容器起一个名字&lt;/li&gt;
&lt;li&gt;-p：将宿主机端口号与容器端口号映射，冒号左侧宿主机端口，右侧是容器端口&lt;/li&gt;
&lt;li&gt;-d：后台运行容器&lt;/li&gt;
&lt;li&gt;nginx：镜像名字，不加版本默认latest&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/23/mYHlORLFtZfgz8k.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;docker容器挂在&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/26/41VTnoJwKuyteIk.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h2 id="dockerfile自定义镜像"&gt;Dockerfile自定义镜像
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://i.loli.net/2021/09/26/OqxoAg74fmUpY1M.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h1 id="rpc设计"&gt;RPC设计
&lt;/h1&gt;&lt;h2 id="几种io"&gt;几种IO
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;同步阻塞BIO&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;socket是典型的同步阻塞io模型，一个客户端和服务端建立一个线程连接，如果有一端没有发送数据，就一直处于阻塞IO状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;同步非阻塞NIO&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;服务端有一个线程，还要维护一个选择器，这个选择器在所有建立连接的客户端之间轮询。如果有一个客户的发送了一个IO请求，就交给服务端的线程去执行这个请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;异步非阻塞AIO&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个中间应用，此应用要先根据客户端发送来的请求，处理完成之后再告诉对应的下游应用需要执行什么操作。就是说响应不是立即完成的，需要有一定的时间来返回响应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="nio"&gt;NIO
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NIO和BIO的比较&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;BIO是用流的方式来处理数据，而NIO以缓冲区的方式处理数据，缓冲区IO的效率比流IO的效率高很多。&lt;/li&gt;
&lt;li&gt;BIO是阻塞的，NIO则是非阻塞的&lt;/li&gt;
&lt;li&gt;BIO基于字节流和字符流进行操作，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作，数据总是从通道读取到缓冲区中。Selector（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="netty"&gt;Netty
&lt;/h2&gt;&lt;h3 id="netty介绍"&gt;Netty介绍
&lt;/h3&gt;&lt;h4 id="原生nio存在的问题"&gt;原生NIO存在的问题
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;NIO的类库和API复杂，使用麻烦。&lt;/li&gt;
&lt;li&gt;需要具备其他额外技能：要熟悉java多线程，因为NIO编程涉及到Reactor模式，必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序。&lt;/li&gt;
&lt;li&gt;开发工作量和难度都非常大：例如客户端面临断连重连，网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。&lt;/li&gt;
&lt;li&gt;JDKNIO的Bug：臭名昭著的Epoll Bug，它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7该问题仍旧存在，没有被根本解决。（在LINUX环境下选择器可能直接返回。）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;NIO是基于NIO的网络编程框架，是当前最流行的NIO框架，知名的Elasticsearch，Dubbo框架内部都采用了Netty。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="优点"&gt;优点
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;设计优雅，提供阻塞和非阻塞的Socket，提供了灵活可拓展的事件模型，提供高度可定制的线程模型。&lt;/li&gt;
&lt;li&gt;具备更高的性能和更大的吞吐量，使用零拷贝技术最小化不必要的内存复制，减少资源的消耗。&lt;/li&gt;
&lt;li&gt;提供安全传输特性。&lt;/li&gt;
&lt;li&gt;支持多种主流协议，预置多种编解码功能，支持用户开发私有协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="线程模型"&gt;线程模型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;传统阻塞I/O模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMpOxm.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当并发数很大，就会创建大量的线程，占用很大系统资源。&lt;/li&gt;
&lt;li&gt;连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read操作，造成线程资源浪费。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Reactor模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reactor模型，通过一个活多个输入同时传递给服务处理器的模式，服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此Reactor模式也叫Dispatcher模式。Reactor模式使用IO复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单Reactor单线程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMpwaq.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;Selector是可以实现应用程序通过一个阻塞对象监听多路连接请求&lt;/p&gt;
&lt;p&gt;Reactor对象通过Selector监控客户端请求事件，收到事件后通过Dispatch进行分发&lt;/p&gt;
&lt;p&gt;是建立请求事件，则由Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模型简单。没有多线程，进程通信，竞争的问题，全部都在一个线程中完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;性能问题，只有一个线程，无法完全发挥多核CPU的性能，Handler在处理某个连接的业务时，整个线程无法处理其他连接事件，很容易导致性能瓶颈。&lt;/li&gt;
&lt;li&gt;可靠性问题：线程意外终止或者进入死循环，会导致整个系统通讯模块不可用，不能接收和处理外部消息，造成节点故障。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单Reactor多线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMp0Hr.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;Reactor对象通过Selector监控客户端请求事件，收到事件后，通过dispatch进行分发&lt;/p&gt;
&lt;p&gt;如果建立连接请求，则右Acceptor通过accept处理连接请求&lt;/p&gt;
&lt;p&gt;如果不是连接请求，则由reactor分发调用连接对应的handler来处理&lt;/p&gt;
&lt;p&gt;handler只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务&lt;/p&gt;
&lt;p&gt;worker线程池会分配独立的线程完成真正的业务，并将结果返回给handler&lt;/p&gt;
&lt;p&gt;Handler收到相应后，通过send将结果返回给client&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以充分的利用CPU的多核处理能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多线程数据共享和访问比较复杂，reactor处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从Reactor多线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMpNDT.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;Reactor主线程MainReactor对象通过select监听客户端连接事件，收到事件后，通过Acceptor处理客户端连接事件&lt;/p&gt;
&lt;p&gt;当Acceptor处理完客户端连接事件之后（与客户端建立好Socket连接），MainReactor将连接分配给SubReactor（即：MainReactor只负责监听客户端连接请求，和客户端建立连接之后将连接交有SubReactor监听后面的IO事件）&lt;/p&gt;
&lt;p&gt;SubReactor将连接加入到自己的连接队列进行监听，并创建Handler对各种事件进行处理&lt;/p&gt;
&lt;p&gt;当连接上有新事件发生的时候，SubReactor就会调用对应的Handler处理&lt;/p&gt;
&lt;p&gt;Handler通过read从连接上读取请求数据，将请求数据分发给Worker线程池进行业务处理&lt;/p&gt;
&lt;p&gt;Worker线程池会分配独立线程来完成真正的业务处理，并将处理结果返回给Handler，Handler通过send想客户端发送响应数据&lt;/p&gt;
&lt;p&gt;一个MainReactor可以对应多个SubReactor，即一个MainReactor线程可以响应多个SubReactor线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;MainReactor线程与SubReactor线程的数据交互简单职责明确。MainReactor线程只需要接受新连接，SubReactor负责完成后续的业务处理&lt;/li&gt;
&lt;li&gt;MainReactor线程只需要把新连接传给SubReactor线程，SUbReactor线程无需返回数据&lt;/li&gt;
&lt;li&gt;多个SubReactor线程可以应对更高的并发请求&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种模式的缺点是编程复杂度较高，但是由于其优点明显，在许多项目中被广泛使用，包括Nginx、Memcached、Netty等。这种模式也被叫做服务器的1+M+N模式。即使用该模式开发的服务器包含一个（或多个，一个表示相对较少）连接建立线程+M个IO线程+N个业务处理线程，这是业界成熟的服务器设计模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="netty线程模式"&gt;Netty线程模式
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Netty的设计主要基于主从Reactor多线程模式，并做了一定的改进。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;简单的Netty模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMp70b.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BossGroup线程维护Selector、ServerSocketChannel注册到这个Selector上，主关注连接建立请求事件（主Reactor）&lt;/li&gt;
&lt;li&gt;当接收的来自客户端的连接建立请求事件时。通过ServerSocketChannel.accept方法获得对应的SocketChannel，并封装成NioSocketChannel注册到WorkerGroup线程中的Selector，每个Selector运行在一个线程中（从Reactor）&lt;/li&gt;
&lt;li&gt;当WorkerGroup线程中的Selector监听到自己感兴趣的IO事件后，就调用Handler进行处理&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;进阶Netty模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMpDjo.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;有两组线程池：BossGroup专门负责和客户端建立连接，WorkerGroup中的线程专门负责处理连接上的读写&lt;/p&gt;
&lt;p&gt;两个线程池含有多个不断循环的执行事件处理的线程，每个线程都包含一个Selector，用于监听注册在其上的Channel&lt;/p&gt;
&lt;p&gt;BossGroup：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;轮询注册在其上的通道中的accept事件（OP_ACCEPT事件）&lt;/li&gt;
&lt;li&gt;处理accept事件，对客户端建立连接，生成一个NioSocketChannel，并将其注册的WorkerGroup中的某个线程上的Selector上&lt;/li&gt;
&lt;li&gt;再去以此循环处理任务队列中的下一个事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;WorkerGroup：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;轮询注册在其上的NioSocketChannel的read/write事件（OP_READ/OPWRITE事件）&lt;/li&gt;
&lt;li&gt;在对应的NioSocketChannel上处理对应的read/write事件&lt;/li&gt;
&lt;li&gt;再去以此循环处理任务队列中的下一个事件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;详细版Netty模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMp6xD.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;Netty抽象出两组线程池，每个线程池中都有NioEventLoopGroup线程池。&lt;/p&gt;
&lt;p&gt;NioEventLoopGroup相当于一个事件循环组，这个组中含有多个事件循环，每个事件循环就是一个NioEventLoop&lt;/p&gt;
&lt;p&gt;NioEventLoop：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select：轮询注册在其上的通道中的accept事件（OP_ACCEPT事件）&lt;/li&gt;
&lt;li&gt;processSelectedKeys：处理accept事件，与客户端建立连接，生成一个NioSocketChannel，并将其注册的WorkerGroup中的某个线程上的Selector上&lt;/li&gt;
&lt;li&gt;RunAllTasks：再去以此循环处理任务队列中的其他任务&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;WorkerNioEventLoop：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;select：轮询注册在其上的NioSocketChannel的read/write事件（OP_READ/OPWRITE事件）&lt;/li&gt;
&lt;li&gt;processSelectedKeys：在对应的NioSocketChannel上处理对应的read/write事件&lt;/li&gt;
&lt;li&gt;RunAllTasks：再去以此循环处理任务队列中的其他任务&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在以上两个ProcessSekectedKeys步骤中，会使用PipeLine（管道），PipeLine中引用了Channel，即通过PipeLine可以获取到对应的Channel，PipeLine中维护了很多的处理器（拦截处理器，过滤处理器，自定义处理等）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="netty高级运用"&gt;Netty高级运用
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;java的编解码&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;编码：序列化，将对象序列化成字节数组，用于网络传输，数据持久化或者其他用途&lt;/li&gt;
&lt;li&gt;解码：反序列化，他是从网络、磁盘等读取字节数组还原成原始对象（通常是原始对象的拷贝），以方便后续的业务逻辑操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;java序列化对象只需要实现java.io.Serializable;接口，并生产序列化ID，这个类就可以通过java.io.ObjectInput和java.io.ObjectOutput序列化和饭序列化。&lt;/p&gt;
&lt;p&gt;缺点：无法跨语言，序列化后码流太大，序列化性能太低&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty编解码器&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty编解码器是由两部分组成的：编码器和解码器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解码器：负责将消息从字节或其他序列形式转换成指定的消息对象&lt;/li&gt;
&lt;li&gt;编码器：负责将消息对象转换为字节或其他序列形式在网络传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Netty的编解码器是一种特殊的ChannelHandler（通道），所以依赖于ChannelPipline（管道），可以将多个编解码器连接在一起，以实现复杂的转换逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="websocket"&gt;WebSocket
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;WebSocket是一种在单个TCP连接上进行全双工通讯的协议，WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，客户端和服务端只需要完成一次握手，两者之间就可以直接创建持久性的连接，并进行双向数据传输。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="websocket和http的区别"&gt;WebSocket和HTTP的区别
&lt;/h4&gt;&lt;p&gt;http协议是用在应用层的协议，他是基于tcp协议的。http协议建立连接也必须要有三次握手才能发送信息。http协议分为短连接，长连接，短连接是每次请求都要三次握手才能发送自己的信息。即每一个request对应一个response，长连接实在一定的期限内保持连接，保持TCP连接不断开。客户端与服务器通信，必须要由客户端先发起，然后服务端返回结果。客户端是主动的，服务器是被动的。客户端要想实时获取服务端消息就得不断发送长连接到服务端。&lt;/p&gt;
&lt;p&gt;WebSocket实现了多路复用，他是全双工通道。在WebSocket协议下服务端和客户端可以同时发送信息。建立了WebSocket连接之后，服务端可以主动发送信息到客户端。而且信息当中不必再带有head的部分信息了与http的长连接通信来说，这种方式，不仅能降低服务器的压力。而且信息当中也减少了部分多余的信息。&lt;/p&gt;
&lt;h3 id="netty中粘包和拆包的解决方案"&gt;Netty中粘包和拆包的解决方案
&lt;/h3&gt;&lt;h4 id="粘包和拆包的简介"&gt;粘包和拆包的简介
&lt;/h4&gt;&lt;p&gt;粘包和拆包是TCP网络中不可避免的，无论是服务端还是客户端。当我们读取或者发送消息的时候，都需要考虑TCP底层粘包/拆包机制。&lt;/p&gt;
&lt;p&gt;TCP是个流协议，所谓流，就是没有界限的一串数据。TCP底层并不了解上次业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题。&lt;/p&gt;
&lt;h4 id="粘包和拆包的解决方案"&gt;粘包和拆包的解决方案
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;业内解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于底层的TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的业务协议栈设计来解决，根据业务的主流协议的解决方案，可以归纳如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息长度固定，累计读取长度和为定长的LEN的报文后，就认为读到了一个完整的信息&lt;/li&gt;
&lt;li&gt;将换行符作为消息结束符&lt;/li&gt;
&lt;li&gt;将特殊的分隔符作为消息结束的标志，回车换行符就是一种特殊的结束分隔符&lt;/li&gt;
&lt;li&gt;通过在消息头中定义长度字段来标识消息的总长度&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Netty中的粘包和拆包解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty提供了4种解码器来解决，分别如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;固定长度的拆包器，每个应用层的数据包都拆分成固定长度的大小&lt;/li&gt;
&lt;li&gt;行拆包器，每个应用层的数据包，都以换行符作为分隔符，进行分割拆分&lt;/li&gt;
&lt;li&gt;分隔符拆包器，每个应用层数据包，都通过自定义的分隔符，进行分割拆分&lt;/li&gt;
&lt;li&gt;基于数据包长度的拆包器，将应用层数据包的长度，作为接收端应用层数据包的拆分依据，按照应用层数据包的大小，拆包。这个拆包器有一个要求，就是应用层协议中包含应用层的长度&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="netty源码"&gt;Netty源码
&lt;/h3&gt;&lt;h4 id="线程组源码"&gt;线程组源码
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;EventLoopGroup是一组EventLoop的抽象，Netty为了方便的利用多核CPU资源，一般会有多个EventLoop同时工作，每个EventLoop维护着一个Selector实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;线程组源码流程图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMpKkC.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;创建NioEventLoopGroup线程组，首先判断有没有传线程数量，如果没有就取默认值（CPU核心数*2），利用for循环创建线程数量的NioEventLoop，每个NioEventLoop对应一个任务队列和选择器，创建任务队列和选择器，生成EventBootStrap对象。设置启动参数，绑定端口。&lt;/p&gt;
&lt;h2 id="什么是rpc"&gt;什么是RPC
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;远程过程调用，借助RPC可以想本地调用一样调用远程服务，是一种进程间的通讯方式，&lt;/p&gt;
&lt;p&gt;比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和表达调用的数据，需要主意嗯是RPC并不是一个具体的技术，而是指整个网络调用过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="rpc架构"&gt;RPC架构
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;一个完整的RPC架构里面包含了四个核心的组件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;客户端（Client），服务的调用方。&lt;/li&gt;
&lt;li&gt;客户端存根（Client Stub），存放服务端的地址消息，再将客户端的地址参数打包成网络消息，然后通过网络把地址消息远程发送给服务方。&lt;/li&gt;
&lt;li&gt;服务端（Server），真正的服务提供者。&lt;/li&gt;
&lt;li&gt;服务端存根（Server Stub），接收客户端发送过来的消息，将消息解包，并调用本地方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="rmi"&gt;RMI
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;远程方法调用，一种用于实现远程过程调用的java APi，能直接传输序列化厚的java对象，它的实现依赖于java虚拟机，因此它只支持一个JVM到另一个JVM的调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/04/29/RMpgaQ.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端从远程服务器的注册表中查询并获取远程对象引用。&lt;/li&gt;
&lt;li&gt;桩对象于远程对象具有相同的接口和方法列表，当客户端调用远程对象时，实际上是由相应的桩对象代理完成的。&lt;/li&gt;
&lt;li&gt;远程引用层在将桩的本地引用转换为服务器上的远程引用后，再将调用传送给传输层，由传输层发送TCP协议进行调用。&lt;/li&gt;
&lt;li&gt;在服务器端，传输层监听入站连接，它一旦接收到客户端远程调用后，就将这个引用转发给其上层的远程引用层。&lt;/li&gt;
&lt;li&gt;服务器端的远程引用层将客户端发送的远程引用转换成虚拟机的引用后，再将请求传输给骨架&lt;/li&gt;
&lt;li&gt;骨架读取参数，又将请求传送给服务器，最后由服务器进行实际的方法调用。&lt;/li&gt;
&lt;li&gt;如果远程方法调用之后有返回值，则服务器将这些结果又沿用“骨架-&amp;gt;远程引用-&amp;gt;传输层”向下传递。&lt;/li&gt;
&lt;li&gt;客户端的传输层接收到返回值后，又沿用“传输层-&amp;gt;远程引用层-&amp;gt;桩”向上传递，然后由桩来饭序列化这些返回值，并将最后的结果传递给客户端程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="分布式理论与分布式架构设计理论"&gt;分布式理论与分布式架构设计理论
&lt;/h1&gt;&lt;h2 id="一致性协议"&gt;一致性协议
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一致性的分类&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;强一致性&lt;/p&gt;
&lt;p&gt;这种级别是最符合用户直觉的，他要求系统写入什么，读出来的也会是什么，用户体验好，但是实现起来往往对用系统的性能影响大，但是强一致性很难实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;弱一致性&lt;/p&gt;
&lt;p&gt;约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据可以达到一致，但会尽可能的保证到某个时间级别（比如秒级别）后，数据能够达到一直状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终一致性性&lt;/p&gt;
&lt;p&gt;最终一致性也是弱一致性的一种，它无法保证数据更新后，所有后续的访问都能看到最新数值，而是需要一个时间，在这个时间之后可以保证这一点（就是在一段时间后，节点间的数据会最终达到一直状态），而在这个时间内，数据也许是不一致的，这个系统无法保证强一致性的时间片段称为“不一致窗口”。不一致窗口的时间长短取决于很多因素，比如备份数据的个数，网络传输延迟速度，系统负载等。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/15/ZS3YMz.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="两阶段提交协议2pc"&gt;两阶段提交协议2PC
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;所有事务先全部运行但是不提交，当所有的服务都返回成功之后，同一改革提交事务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/16/ZSsdkM.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;优点&lt;/p&gt;
&lt;p&gt;原理简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步阻塞：&lt;/p&gt;
&lt;p&gt;第二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，即当参与者占有公共资源时，其他参与者访问公共资源处于阻塞状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单点问题：&lt;/p&gt;
&lt;p&gt;若协调器出现问题，那么整个二阶段提交流程将无法运转，若协调者在二阶段出现问题时，那么其他参与者将一直处于锁定资源的状态中，而无法继续完成事务操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据不一致&lt;/p&gt;
&lt;p&gt;在阶段二中，执行事务提交的时候，当协调者向所有参与者发送commit请求后，发生了局部网络异常或者是协调者在尚未发送完commit请求之前自身发生了崩溃，导致最终只有部分参与者收到了commit请求，于是会出现数据不一致的现象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;太过保守&lt;/p&gt;
&lt;p&gt;在事务提交询问的过程中，参与者出现了故障，导致协调者始终无法获取所有参与者的响应信息的话，此时协调者只能依靠自生的超时机制来判断是否需要中断事务，这样的策略过于保守，即没有完善的容错机制，任意一个节点的失败都会导致整个事务的失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="三阶段提交协议3pc"&gt;三阶段提交协议3pc
&lt;/h3&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/17/ZSis0u.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;3pc存在的问题&lt;/p&gt;
&lt;p&gt;当处于第三阶段时，如果协调者突然宕机，一部分参与者收到了commit请求，一部分没有；没收到的那部分会在等待超时后提交事务，此时，数据是一致的。但如果协调者发送的是回滚命令，一部分接收到的参与者会回滚事务，但没有接收到的参与者会等待超时后提交事务，还是导致了数据不一致问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="nwr协议"&gt;NWR协议
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;NWR是一种在分布式存储系统中用于控制一致性级别的一种策略，在亚马逊的云存储系统中，就应用NWR来控制一致性。亚马逊用的这种形式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;N: 在分布式存储系统中，有多少份备份数据&lt;/p&gt;
&lt;p&gt;W：代表一次成功的更新操作要求至少有W份数据写入成功&lt;/p&gt;
&lt;p&gt;R：代表一次成功的读取数据操作要求至少有R份数据成功读取&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NWR值的不同组合会产生不同的一致性效果，当W+R&amp;gt;N的时候，整个系统对于客户端来讲能保证强一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以常见的N=3，W=2，R=2为例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;N=3：任何一个对象都必须有3个副本&lt;/p&gt;
&lt;p&gt;W=2: 对数据的修改操作只需要在3个副本中的2个上面完成就返回&lt;/p&gt;
&lt;p&gt;R=2: 从3个对象中要读取到2个数据对象，才能返回&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在分布式系统中，数据的单点是不允许存在的。即线上正常存在的备份数量N设置1的情况是非常危险的，因为一旦这个备份发生了错误，就可能发生数据的永久性错误。假如把N设置成2，只要有一个节点发成损坏，就会有单点的存在。所以N必须大于3。N越高，系统的维护和整体成本就越高，工业界通常把N设置为3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSWBBD.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h3 id="gossip协议病毒式传播"&gt;Gossip协议（病毒式传播）
&lt;/h3&gt;&lt;p&gt;是一种去中心化的分布式协议，数据通过节点像病毒一样传播。因为是指数级传播，所以传播速度特别快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扩容性：允许节点的任意增加和减少，新增节点的状态最终会和其他节点一致&lt;/p&gt;
&lt;p&gt;容错：任意节点的宕机和重启都不会影响Gossip消息的传播，具有天然的分布式系统的容错性。&lt;/p&gt;
&lt;p&gt;去中心化：无需中心节点，所有节点都是对等的，任意节点无需知道整个网络状态，只要网络联通，任意节点可以把消息散播到全网。&lt;/p&gt;
&lt;p&gt;最终一致性：Gossip协议实现信息指数级的快速传播，因此在有新信息需要传播时，消息可以快速的发送到全局节点，在有限的时间内能够做到所有节点都拥有最新的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺点：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息延迟：节点随机向少数几个节点发送信息，消息最终是通过多个伦次的传播才到达全网，不可避免的造成消息延迟。&lt;/p&gt;
&lt;p&gt;消息冗余：节点定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，不可避免的引起同一节点消息多次接收，增加消息处理压力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见应用有：p2p网络通信，redis cluster，Consul。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="paxos协议"&gt;paxos协议
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;就是paxos算法，paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;应用：谷歌的很多大型系统，Zookeeper，Mysql5.7之后的主从复制，都采用paxos来解决分布式一致性问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;角色介绍：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;client客户端：&lt;/p&gt;
&lt;p&gt;客户端向分布式系统发出请求，并等待响应。例如，对分布式文件服务器中文件的写请求。&lt;/p&gt;
&lt;p&gt;prposer提案发起者&lt;/p&gt;
&lt;p&gt;提案者提倡客户端请求，视图说服Acceptor对此达成一致，并在发成冲突是充当协调者，以推动协议向前发展。&lt;/p&gt;
&lt;p&gt;Acceptor决策者，可以批准提案&lt;/p&gt;
&lt;p&gt;Acceptor可以接受提案，并进行投票，投票结果是否通过以多数派为准，以如果某个提案被选定，那么该提案里的value就会被选定。&lt;/p&gt;
&lt;p&gt;learnner：最终决策的学习者：&lt;/p&gt;
&lt;p&gt;学习者充当该决策的复制因素（不参与投票）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;basic paxos流程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;提案者提出一个提案，编号为N，此N大于这个提案者之前提出的所有编号，请求决策者的多数接受这个提案&lt;/li&gt;
&lt;li&gt;如果编号N大于此决策者之前接受的任意提案编号则接受，否则拒绝。&lt;/li&gt;
&lt;li&gt;如果达到多数派，提案者会发出accept请求，此请求包含提案的编号和对应内容。&lt;/li&gt;
&lt;li&gt;如果此提案者在此期间，没有接受到任何大于N的提案，则接受此提案内容，否则忽略。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSWPUv.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSWJhP.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSW4gR.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSWLPz.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;活锁问题的解决方案：只需要在每个提案者再去提案的时候随机加上一个等待时间即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选举-复制模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSWiD5.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;第一次请求需要两次rpc调用，选举出一个决策者的leader，然后用过决策者复制这次请求给其他节点。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://www.helloimg.com/images/2022/06/18/ZSWHC0.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;p&gt;第二次请求直接将编号和值发给，决策者leader，由leader直接决定是否执行。只需要一次RPC调用。&lt;/p&gt;
&lt;h3 id="raft协议"&gt;Raft协议
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;节点状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;leader主节点：接受Client更新请求，写入本地后，然后同步到其他副本中。&lt;/li&gt;
&lt;li&gt;Follower从节点：从leader中接收更新请求，然后写入本地日志文件，对客户端提供读请求。&lt;/li&gt;
&lt;li&gt;Candidate候选节点：如果Follower在一定的时间内，未收到leader心跳。则判断leader可能故障，发起选主提议。节点状态从Follower变成Candidate，直到候选结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;termid：任期号，时间被划分成一个一个任期，每次选举后都会产生一个新的任期，一个任期内只有一个master。&lt;/p&gt;
&lt;p&gt;请求投票：候选者在选举过程中发起，收到多数派响应后成为leader。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lease机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;租约机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;lease是颁发者对一段时间内数据一致性的承诺&lt;/li&gt;
&lt;li&gt;颁发者发出lease后，不管是否被接受，只要lease不过期，颁发者都会按照协议遵守承诺。&lt;/li&gt;
&lt;li&gt;lease的持有者只能在lease的有效期内使用承诺，一旦lease超时，持有者需要放弃执行，重新申请lease。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="分布式系统设计策略"&gt;分布式系统设计策略
&lt;/h2&gt;&lt;h3 id="心跳检测"&gt;心跳检测
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;周期心跳检测机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Server端每隔t秒向Node集群发起检测请求，设定超时时间，如果超过超时时间，则判断死亡。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;累计失效检测机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在周期检测心跳机制的基础上，统计一定周期内节点的返回情况（包括超时和正确返回），以此计算节点的死亡概率。另外，对于宣告斌零死亡的节点可以发起有限次数的重试，以作进一步判断。如果超过次数则可以把该节点踢出集群。&lt;/p&gt;
&lt;h3 id="高可用"&gt;高可用
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过设计减少系统不能对外提供服务的时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主备模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行。&lt;/p&gt;
&lt;p&gt;场景：Mysql。Redis等通过主从复制来保证高可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互备模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两台主机同时运行各自的服务工作且相互检测情况。每个master都有读写能力，会根据时间戳或业务逻辑来合并版本。&lt;/p&gt;
&lt;p&gt;场景：数据库双主模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有多个节点在运行，同时可以通过主控节点分担服务请求。集群模式需要解决主控节点本身的高可用问题，一般采用主从模式。&lt;/p&gt;
&lt;h4 id="脑裂问题"&gt;脑裂问题
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;高可用本身通过心跳检测来检测对方是否正常，当心跳线断开，高可用系统就会分裂成两个群体，由于互相失去了联系，都认为对方出现了故障，就会本能的去争抢公共资源，争起“应用服务”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;导致的问题：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;共享资源被瓜分，两边服务都起不来了。&lt;/li&gt;
&lt;li&gt;两边服务都起来了，但同时读写共享存储，导致数据损坏。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;预防脑裂的方案&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;添加冗余的心跳线（即冗余通讯的方法）&lt;/li&gt;
&lt;li&gt;同时用两条心跳线路（即心跳线也高可用），这样一条线路坏了，另一个还是好的&lt;/li&gt;
&lt;li&gt;仲裁机制：当两个节点出现分歧时，由第三方决定听谁的。这个仲裁者，可以是一个锁服务，一个共享盘或者其他什么东西。&lt;/li&gt;
&lt;li&gt;Lease机制：租约机制，在租期内，即使出现问题也认为要听申请到lease的节点。&lt;/li&gt;
&lt;li&gt;隔离机制：
&lt;ol&gt;
&lt;li&gt;共享存储：确保只有一个master往共享存储中写数据。&lt;/li&gt;
&lt;li&gt;客户端：确保只有一个master可以响应客户端的请求。&lt;/li&gt;
&lt;li&gt;Slave：确保只有一个主节点可以向从节点发送命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="容错性"&gt;容错性
&lt;/h3&gt;&lt;p&gt;系统对于错误包容的能力。非常典型案例就是缓存穿透问题。&lt;/p&gt;
&lt;p&gt;存放null值，布隆过滤器。&lt;/p&gt;
&lt;h3 id="负载均衡"&gt;负载均衡
&lt;/h3&gt;&lt;p&gt;使用多台服务器共同分担计算任务，把网络请求或计算分配到集群可用的不同服务器节点上，从而达到高可用性和较好的用户操作体验。&lt;/p&gt;
&lt;p&gt;应用：硬件有著名的F5。 软件：nginx，LV5，HAProxy。&lt;/p&gt;
&lt;h2 id="分布式架构服务调用"&gt;分布式架构服务调用
&lt;/h2&gt;&lt;h3 id="服务调用"&gt;服务调用
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Http应用协议的通信框架&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;httpURLConnection&lt;/p&gt;
&lt;p&gt;java原生是基于http协议的，支持get，post，put，delete等各种请求方式，最常用的就是get和post&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apache Common HttpClient&lt;/p&gt;
&lt;p&gt;HttpClient是Apache Common下的子项目，可以用来提供高效的，最新的，功能丰富的支持HTTP协议的客户端编程工具包，并且它支持Http协议最新的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OKhttp3&lt;/p&gt;
&lt;p&gt;是当前主流的网络请求的开源框架，用于替代HttpUrlConnection和Apache HttpClient&lt;/p&gt;
&lt;p&gt;支持http2.0，对一台机器的请求共享一个socket。&lt;/p&gt;
&lt;p&gt;采用连接池技术，可以有效的减少http连接数量。&lt;/p&gt;
&lt;p&gt;无缝集成GZIP压缩技术&lt;/p&gt;
&lt;p&gt;支持Response Cache，避免重复请求&lt;/p&gt;
&lt;p&gt;域名多IP支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RestTemplate&lt;/p&gt;
&lt;p&gt;Spring RestTemplate是Spring提供的用于访问Rest服务器客户端，RestTemplate提供了多种便捷访问远程http服务器的方法，能够大大提高客户端的编写效率，所以很多客户端比如安卓或者第三方服务商都使用RestTemplate请求restful服务。&lt;/p&gt;
&lt;p&gt;面向URL组件，必须依赖于主机+端口号+URL&lt;/p&gt;
&lt;p&gt;RestTemplate不依赖与服务接口，仅关注rest响应内容。&lt;/p&gt;
&lt;p&gt;spring Cloud Feign&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RPC框架&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RPC全称为remote procedure call，远程过程调用，借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式。&lt;/p&gt;</description></item></channel></rss>