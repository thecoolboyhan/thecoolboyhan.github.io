<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>垃圾回收器 on 韩永发的博客</title><link>https://thecoolboyhan.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</link><description>Recent content in 垃圾回收器 on 韩永发的博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 10 Jun 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thecoolboyhan.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>备战JDK25--垃圾回收器</title><link>https://thecoolboyhan.github.io/p/jdk25-1/</link><pubDate>Tue, 10 Jun 2025 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/jdk25-1/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/jdk25-1/1.png" alt="Featured image of post 备战JDK25--垃圾回收器" /&gt;&lt;blockquote&gt;
&lt;p&gt;阅读本文前，强烈建议先看看我之前的&lt;a class="link" href="https://thecoolboyhan.github.io/p/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" target="_blank" rel="noopener"
&gt;关于各种垃圾回收的介绍文章&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="垃圾回收部分"&gt;垃圾回收部分
&lt;/h2&gt;&lt;p&gt;由于JDK25会将Shenandoah最为默认垃圾回收器，本次将再次详细研究一下本时代的垃圾回收器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本次只提目前仍可能存活在市场上的三种垃圾回收器（G1，ZGC，Shenandoah GC）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="g1高吞吐量"&gt;G1(高吞吐量)
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现在看来G1已经是老古董了，当初的出现只是为了取代CMS。但后续两种垃圾回收器都是基于G1的思想来做的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="简介"&gt;简介
&lt;/h3&gt;&lt;p&gt;从JDK9开始，成为默认的垃圾回收器，低延迟、高吞吐，适用于10G以上的大内存。只优先回收垃圾最多的区，因此叫做&lt;strong&gt;Garbage-First&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引入了区（Region）的概念，区在创建时没有定义属性。在程序的运行过程中，会被分成不同的类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分类&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;区类型&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Eden Regions&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存放新创建的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Survivor Regions&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存放从 Eden 晋升的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Old Regions&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存放长期存活的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Humongous Regions&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存放大对象（超过 Region 一半大小）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Free Regions&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;未被使用、等待分配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="垃圾回收过程"&gt;垃圾回收过程
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-06/2023-2-2319_13_12-1677150791924_1749448480478.png"
loading="lazy"
alt="2023-2-2319_13_12-1677150791924.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（Short STW）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标记所有可以直接从GC Roots可达的对象。此阶段只对新生代Eden区进行标记。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;（与用户线程并行）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从初始标记的结果出发，遍历整个堆，并标记所有可达对象。&lt;/p&gt;
&lt;p&gt;创建一份全堆的对象存活快照。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;重新标记&lt;/strong&gt;（也叫最终标记，较短的STW）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;纠正并发标记期间因修改产生的不一致。确保垃圾回收器有准确的存活集信息。&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;strong&gt;混合回收&lt;/strong&gt;（并行）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完整的回收（年轻代和老年代都回收）。调度器会选择垃圾最多的区来进行清理。&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重新构建各区块的元素，更新各区的分类，更新记忆集，管理跨区之间的引用。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-06/b47f048fb6844ecc90b80aff88117a04_1749519287352.png"
loading="lazy"
alt="b47f048fb6844ecc90b80aff88117a04.png"
&gt;&lt;/p&gt;
&lt;h3 id="特性"&gt;特性
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;卡表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用来记录哪些区发生了修改。每个区都有对应的卡表，当需要写入对象时，写入屏障会把对应的卡表标记为脏，GC遍历时只需要遍历脏卡表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是会占用额外的空间，而且写操作受到了影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;记忆集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在区之间进行回收时，记忆集用来记录跨区的引用，这样每个区只需要扫描局部被修改的部分。跨区部分信息记录在记忆集中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;也会占用额外的空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;动态调整区类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动态的调整区类型，来避免full GC&lt;/p&gt;
&lt;h3 id="对比"&gt;对比
&lt;/h3&gt;&lt;p&gt;G1是在垃圾回收效率和停顿延迟上取平衡的回收器。&lt;/p&gt;
&lt;h4 id="缺点"&gt;缺点
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;垃圾回收仍然STW&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当堆内存特别大时（上T级别），初始标记和remark阶段的STW会非常明显。&lt;/p&gt;
&lt;p&gt;ZGC和Shenandoah更优&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大内存支持不好（T级别内存）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回收调度和标记开销&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于在写入时会向卡表写入数据，且还维护着记忆集，都会带来大量内存开销和算法开销。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调优难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于可以预先设置区大小等，且区是动态变化的，各方面想找到平衡难。&lt;/p&gt;
&lt;h2 id="zgc低延迟"&gt;ZGC（低延迟）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;又一个CMS，一直在优化，一直很nb，但没有当过真正的默认垃圾回收器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JDK11被引入。主打极低的停顿时间（一般停顿时间都小于10毫米）&lt;/p&gt;
&lt;p&gt;同时支持多TB级别的堆内存&lt;/p&gt;
&lt;p&gt;完全取消了年轻代老年代的划分，直接根据分区来管理内存。&lt;/p&gt;
&lt;h3 id="垃圾回收过程-1"&gt;垃圾回收过程
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-06/c84674f0f2f94702af64b7dd51f99e1d_1749541261705.png"
loading="lazy"
alt="c84674f0f2f94702af64b7dd51f99e1d.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（极短的STW）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;扫描所有GC Roots可达对象&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;只处理直接引用，工作十分轻量，STW时间非常短&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在初始标记的基础上，并发遍历整个堆，从根出发标记所有可达的存活对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;load barrier协议来准确的标记对象状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 load barrier的协议，使得对象状态可以被准确的确定，同时不影响应用程序的执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;并发迁移&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据标记的结果，将存活对象从原区域搬迁到新的区域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通过虚拟内存地址更换迁移&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;利用虚拟内存重映射技术，通过调整对象的虚拟地址完成迁移，不需要做大量的复制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;彩色指针来实现引用升级&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;利用加载屏障和彩色指针，实现用户线程加载对象时，判断彩色指针去迁移后的地址读取对象，同时更新对象的引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;strong&gt;最终更新/修正阶段（Final Update）STW&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;快速修改遗漏或不一致的引用，确保整个堆中所有对象引用都正确的指向了新地址&lt;/p&gt;
&lt;h3 id="特性-1"&gt;特性
&lt;/h3&gt;&lt;h4 id="彩色指针"&gt;彩色指针
&lt;/h4&gt;&lt;p&gt;64位操作系统中的对象空间是64位，但实际对象的有效地址位数远低于64位。ZGC利用未使用的高位，将部分位“涂色”，用来存储额外的元数据信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免额外的数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与G1标记对象是否可以回收（通过卡表）不同，不需要占用额外的空间，且不需要进行多余的随机读写，直接通过对象的地址来判断对象是否有效。&lt;/p&gt;
&lt;h4 id="加载屏障load-barrier"&gt;加载屏障（load barrier）
&lt;/h4&gt;&lt;p&gt;在对象引用加载时，自动插入一段代码（有点类似于AOP的概念）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态的检测颜色&lt;/p&gt;
&lt;p&gt;判断上面的彩色指针位的颜色，来判断对象是否被移动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;透明指针重定向&lt;/p&gt;
&lt;p&gt;检测到对象已迁移，主动修改元数据中的新地址（新地址通过内部的转发表或基于虚拟内存映射的信息来确认）。并加载重定位的新地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发容忍性&lt;/p&gt;
&lt;p&gt;通过上面两项，可以保证用户线程看到的总是最新且正确的对象引用。从而实现了无暂停的迁移与回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="虚拟内存重映射同时也是cpu零拷贝的重要手段之一"&gt;虚拟内存重映射（同时也是CPU零拷贝的重要手段之一）
&lt;/h4&gt;&lt;p&gt;ZGC降低复制开销的主要手段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过修改操作数据页表项，来改变虚拟地址与物理内存之间的映射关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="对比-1"&gt;对比
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;垃圾回收器&lt;/th&gt;
&lt;th&gt;目标&lt;/th&gt;
&lt;th&gt;实现手段&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ZGC&lt;/td&gt;
&lt;td&gt;极低停顿（10毫秒）&lt;br /&gt;支持大内存（TB）超级大内存支持情况比Shenandoah好&lt;/td&gt;
&lt;td&gt;并发执行&lt;br /&gt;彩色指针&lt;br /&gt;加载屏障&lt;br /&gt;虚拟内存映射&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G1&lt;/td&gt;
&lt;td&gt;均衡的吞吐量与停顿时间&lt;br /&gt;可以通过修改最大停顿时间参数来动态分配区&lt;/td&gt;
&lt;td&gt;利用区来划分堆&lt;br /&gt;按垃圾率决定优先回收的区&lt;br /&gt;采用复制算法减少内存碎片&lt;br /&gt;部分场景STW，但STW时间可预测&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shenandoah&lt;/td&gt;
&lt;td&gt;极低停顿时间（几毫秒内）&lt;br /&gt;支持大堆内存&lt;/td&gt;
&lt;td&gt;与ZGC类似，并发压缩&lt;br /&gt;大部分垃圾回收工作与应用内存并发执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id="优点"&gt;优点
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;极低暂停时间（10毫秒）&lt;/li&gt;
&lt;li&gt;高扩展性：可以适配超大堆，停顿时间与堆大小无关&lt;/li&gt;
&lt;li&gt;并发对象搬迁与透明更新：极大的降低了实时数据迁移产生不一致的风险&lt;/li&gt;
&lt;li&gt;较低的内存复制开销：利用虚拟内存映射减少内存复制&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="缺点-1"&gt;缺点
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;加载屏障需要额外开销：每次对象被访问时，都需要通过加载屏障，会带来额外的开销&lt;/li&gt;
&lt;li&gt;平台支持有限：ZGC主要是为64为Linux操作系统设计，对其他平台支持不成熟&lt;/li&gt;
&lt;li&gt;吞吐量有限：由于设计之初是为了更低的停顿时间，因此在极端吞吐量的场景下，效果不如传统垃圾回收器（Parallel GC）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ZGC为了提高CPU利用率而放弃了部分吞吐量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为什么放弃ZGC？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;个人认为，ZGC的延迟和大堆表现真的很棒。但大部分企业根据没有几十TB的堆。且ZGC需要太多的CPU开销，牺牲了部分的吞吐量（相当于没有高效的利用内存空间）这些部份甚至开了倒车。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结就是有点偏科，且擅长的方向现实生活还没有跟上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="shenandoah非分代"&gt;Shenandoah（非分代）
&lt;/h2&gt;&lt;p&gt;JDK12开始引入（社区可以支持到JDK8），通用采取分区概念，全堆并发标记、并发搬迁、并发更新引用。&lt;/p&gt;
&lt;p&gt;只有几毫秒的STW，不区分新生代、老年代。所有对象都是同一套并发处理流程。&lt;/p&gt;
&lt;h3 id="垃圾回收过程-2"&gt;垃圾回收过程
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-07/1751436527413_1751436527436.png"
loading="lazy"
alt="1751436527413.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始标记（STW）&lt;/p&gt;
&lt;p&gt;扫描GC Roots中直接引用的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发标记&lt;/p&gt;
&lt;p&gt;遍历整个堆，从根对象出发将所有可达对象标记出来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此过程中类似G1，使用了卡表、记忆集技术，来限制每次扫描的范围。避免出现全堆扫描&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新标记（STW）&lt;/p&gt;
&lt;p&gt;几毫秒的STW，重新扫描并发标记中的引用变化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发整理/搬迁&lt;/p&gt;
&lt;p&gt;和ZGC类似，采用“彩色指针”、“加载屏障”、“虚拟内存映射”技术来实现并发的对象整理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终引用更新（STW）&lt;/p&gt;
&lt;p&gt;更新上一步中未更新的引用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="对比-2"&gt;对比
&lt;/h3&gt;&lt;p&gt;非分代Shenandoah和ZGC大部分场景都是相同的，不同点很少&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;阶段&lt;/th&gt;
&lt;th&gt;ZGC&lt;/th&gt;
&lt;th&gt;非分代Shenandoah&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;并发标记&lt;/td&gt;
&lt;td&gt;利用加载屏障，实现标记过程中实时捕获对象状态，在超大堆上支持更好（TB）&lt;/td&gt;
&lt;td&gt;利用卡表、记忆集来并发标记，最后有短暂的暂停（再标记阶段），支持上百G的内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;迁移过程&lt;/td&gt;
&lt;td&gt;利用虚拟内存映射，强调零拷贝，几乎无复制&lt;/td&gt;
&lt;td&gt;虽然同样采用了彩色指针、加载屏障来保证迁移的准确，但还是存在部分的实际对象复制，所以效率不如ZGC&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-07/1751436709608_1751436709649.png"
loading="lazy"
alt="1751436709608.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么选择Shenandoah而不是ZGC？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的比较感觉，好像ZGC要比Shenandoah更好，但这只是部份场景的比较。&lt;/p&gt;
&lt;p&gt;选择Shenandoah主要原因是&lt;strong&gt;CPU开销&lt;/strong&gt;和&lt;strong&gt;成熟的应用&lt;/strong&gt;经验，ZGC强调的零拷贝，但可能带来更大的CPU开销。&lt;/p&gt;
&lt;h2 id="分代shenandoah"&gt;分代Shenandoah
&lt;/h2&gt;&lt;p&gt;JDK21引入，又重新引入了分代思想，利用对象年轻即死的假设，把堆重新分成了新生代和老年代。不同代采用不同的回收策略&lt;/p&gt;
&lt;h3 id="新生代gcminor-gc"&gt;新生代GC(Minor GC)
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;分配&lt;/p&gt;
&lt;p&gt;对象首先在新生代Eden区分配。由于新生代区域小、生命周期短，分配速度块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制收集&lt;/p&gt;
&lt;p&gt;当Eden区达到一定阈值，会触发STW，针对新生代单独回收。&lt;/p&gt;
&lt;p&gt;回收方式采用复制法，把存活的对象复制到幸存者区（Survivor），如果达到一定标准，会直接晋升到老年代。&lt;/p&gt;
&lt;p&gt;复制过程采用加载屏障，保证数据不会在搬迁过程中不可用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;晋升标准&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普通对象晋升到幸存者区。&lt;/p&gt;
&lt;p&gt;如果幸存者区内存不足时，就会直接晋升到老年代。&lt;/p&gt;
&lt;h3 id="老年代gcmajor-gc"&gt;老年代GC（Major GC）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;老年代GC是全堆的GC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;（STW，非常短）：类似非分代模式，标记GC Roots直接可达的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：然后多个线程遍历整个老年代。利用记忆集和卡表来减少扫描范围。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发整理（搬迁）&lt;/strong&gt;：把存活的对象搬迁到连续的区域。利用彩色指针记录搬迁的信息，利用加载屏障并行搬迁。（有可能会用到虚拟内存映射）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终更新&lt;/strong&gt;（STW)：对未完全更新的引用做最后的修正，保证全堆一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="特点"&gt;特点
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;新生代的轻量复制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓的轻量复制，只新生代空间小。GC频繁，且只复制存活的对象。复制过程中有加载屏障。只会在初始标记GC Roots阶段产生短暂的STW。&lt;/p&gt;
&lt;p&gt;这样提高GC频率，从而快速回收大部分垃圾。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过记忆集实现跨代引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于存在分代晋升，当新生代对象进入老年代时，回收规则发生变化。&lt;/p&gt;
&lt;p&gt;通过记忆集来传递这样的引用信息。每次进入老年代更新记忆集。这样就不用每次扫描整个堆来确认老年代新增的对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为什么选择分代 Shenandoah GC&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前看来，分代 Shenandoah GC 是垃圾回收效率，STW时间，吞吐量上保证了平衡。&lt;/p&gt;
&lt;p&gt;新生代采用”G1 PRO“的方式来保证大部分垃圾可以被快速的回收。（吞吐量）&lt;/p&gt;
&lt;p&gt;老年代采用传统Shenandoah来保证大内存（小于等于TB）的STW时间缩短。属于低延迟和高吞吐的融合。&lt;/p&gt;</description></item></channel></rss>