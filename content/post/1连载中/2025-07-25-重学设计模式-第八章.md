---
title:  重学设计模式-第八章-单例模式
date: 2025-07-25
tags:
  - 设计模式
  - book
  - 读后感
---


# 单例模式
> 创建型设计模式
> 
> 避免一个全局使用的类频繁的创建和消费，从而提升整体代码的性能。





七种不同的单例模式



## 0、静态类（非单例模式）

``` java
public class Singleton_00 {

    public static Map<String,String> cache = new ConcurrentHashMap<String, String>();
    
}
```

不需要维持状态，仅让全局访问，静态类的方式更加简单。

但如果需要被继承以及需要维持状态时，就需要使用到单例模式



## 懒汉模式（线程不安全）



``` java
public class Singleton_01 {

    private static Singleton_01 instance;

    private Singleton_01() {
    }

    public static Singleton_01 getInstance(){
        if (null != instance) return instance;
        instance = new Singleton_01();
        return instance;
    }

}
```



> 使构造函数为private，不允许直接创建对象，只能通过getInstance来创建

懒加载，只有在需要使用时才会创建对象。



- 为什么线程不安全？

当多个线程同时调用getInstance时，可能得到多个不同的对象。



## 懒汉模式（线程安全）



``` java
public class Singleton_02 {

    private static Singleton_02 instance;

    private Singleton_02() {
    }

    public static synchronized Singleton_02 getInstance(){
        if (null != instance) return instance;
        instance = new Singleton_02();
        return instance;
    }

}
```

利用synchronized保证同时只能有一个线程来创建对象



- 存在问题

所有线程在获取此单例类时，都会被synchronized锁定，导致资源浪费。



## 饿汉模式（线程安全）

``` java
public class Singleton_03 {

    private static Singleton_03 instance = new Singleton_03();

    private Singleton_03() {
    }

    public static Singleton_03 getInstance() {
        return instance;
    }

}
```



类似于最开始的静态类，当程序启动的时候，就直接运行加载，无论是否使用，直接创建对象。



- 为什么线程安全？

JVM在类加载的过程中
**加载**-->**验证**-->**准备**-->**解析**--><font color='red'>**初始化**</font>-->**使用**-->**卸载**

在初始化阶段就直接执行静态代码块，直接创建对象。后续其他类使用时就是已经创建好的对象。



- 存在的问题

程序启动，所有的单例类全部被创建，如果单例类特别多，会导致大量的资源占用。





## 类的内部类（线程安全）

``` java
public class Singleton_04 {

    private static class SingletonHolder {
        private static Singleton_04 instance = new Singleton_04();
    }

    private Singleton_04() {
    }

    public static Singleton_04 getInstance() {
        return SingletonHolder.instance;
    }

}
```



使用静态内部类，即保证了线程安全，也保证了懒加载，同时也没有锁来消耗性能。



- 如何被创建

初始时，并没有创建instance此内部类。

当有线程调用getInstance方法时，会返回SingletonHolder.instance对象。

有栈（线程）需要加载SingletonHolder.instance对象，JVM第一次把指向class的符号引用改成正常加载到JVM单例池中的直接引用。（此时相当于触发了类的饿汉式单例）



- 为什么线程安全？

> 《深入理解java虚拟机》中的原话：

虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，就可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行()方法后，其他线程唤醒之后不会再次进入()方法。同一个加载器下，一个类型只会初始化一次。)，在实际应用中，这种阻塞往往是很隐蔽的。





- 存在的问题

普通使用是非常推荐的。但是由于使用了静态内部类，无法从外部直接传递参数进去





## 双重锁校验（线程安全）DCL

``` java
public class Singleton_05 {

    private static volatile Singleton_05 instance;

    private Singleton_05() {
    }

    public static Singleton_05 getInstance(){
       if(null != instance) return instance;
       synchronized (Singleton_05.class){
           if (null == instance){
               instance = new Singleton_05();
           }
       }
       return instance;
    }

}
```



满足懒加载，会在初始化阶段上锁，后续操作无锁。



## CAS单例（线程安全）







``` java
public class Singleton_06 {

    private static final AtomicReference<Singleton_06> INSTANCE = new AtomicReference<Singleton_06>();

    private Singleton_06() {
    }

    public static final Singleton_06 getInstance() {
        for (; ; ) {
            Singleton_06 instance = INSTANCE.get();
            if (null != instance) return instance;
            INSTANCE.compareAndSet(null, new Singleton_06());
            return INSTANCE.get();
        }
    }

    public static void main(String[] args) {
        System.out.println(Singleton_06.getInstance()); // org.itstack.demo.design.Singleton_06@2b193f2d
        System.out.println(Singleton_06.getInstance()); // org.itstack.demo.design.Singleton_06@2b193f2d
    }

}
```



通过里用原子类中的CAS操作，实现CAS创建对象



- 存在的问题

CAS是一个忙等操作，会一直循环尝试，直到成功。但如果对象创建一直失败，就会无限重试。





## Effective Java作者推荐的枚举单例(线程安全)

``` java
public enum Singleton_07 {

    INSTANCE;
    public void test(){
        System.out.println("hi~");
    }

}
```



利用枚举类创建的单例对象，即使用过反射业务创建相同的对象。

*偿地提供了串行化机制，绝对防止对此实例化，即使是在面对复杂的串行化或者反射攻击的时候。*
