---
title:  重学设计模式-适配器模式
date: 2025-08-27
tags:
  - 设计模式
  - book
  - 读后感
---

# 适配器模式
> 结构型模式
>
> 把原本不兼容的接口，通过适配器修改做到统一。使得用户方便使用。

![场景模拟；接收多类型MQ消息](https://camo.githubusercontent.com/b83fc564cdb39695fd7527f0642bc8124749b9c8c32b1a093b41d4c0f88e775e/68747470733a2f2f627567737461636b2e636e2f6173736574732f696d616765732f323032302f6974737461636b2d64656d6f2d64657369676e2d362d30332e706e67)

多种差异化类型的接口做统一输出。

![适配器模型结构](https://camo.githubusercontent.com/8f0b35f2d77e5a64ae144303b79b4b519c0bfee796675b836bb558f2750463f3/68747470733a2f2f627567737461636b2e636e2f6173736574732f696d616765732f323032302f6974737461636b2d64656d6f2d64657369676e2d362d30342e706e67)

使用适配器模式就可以让代码，干净整洁易于维护、减少大量的重复判断，让代码更加易于维护和拓展。

> 统一适配器接口

``` java
public interface OrderAdapterService {

    boolean isFirst(String uId);

}
```



> 不同的两种实现

**内部商品接口**

```java
public class InsideOrderService implements OrderAdapterService {

    private OrderService orderService = new OrderService();

    public boolean isFirst(String uId) {
        return orderService.queryUserOrderCount(uId) <= 1;
    }

}
```

**第三方商品接口**

```
public class POPOrderAdapterServiceImpl implements OrderAdapterService {

    private POPOrderService popOrderService = new POPOrderService();

    public boolean isFirst(String uId) {
        return popOrderService.isFirstOrder(uId);
    }

}
```



在这两个接口中都实现了各自的判断方式，尤其像是提供订单数量的接口，需要自己判断当前接到mq时订单数量是否`<= 1`，以此判断是否为首单。

> 测试类

``` java
@Test
public void test_itfAdapter() {
    OrderAdapterService popOrderAdapterService = new POPOrderAdapterServiceImpl();
    System.out.println("判断首单，接口适配(POP)：" + popOrderAdapterService.isFirst("100001"));   

    OrderAdapterService insideOrderService = new InsideOrderService();
    System.out.println("判断首单，接口适配(自营)：" + insideOrderService.isFirst("100001"));
}
```

