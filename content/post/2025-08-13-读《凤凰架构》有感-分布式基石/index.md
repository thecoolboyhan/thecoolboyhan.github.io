---
title:  读《凤凰架构》有感--分布式基石
description: 最近攻读周志明老师的《凤凰架构》，书中介绍了软件领域的架构演进，涉及到众多架构知识，分布式场景的设计原则等，不知能否做到归纳总结。本文主要包含：服务的注册发现、跟踪治理、负载均衡、故障隔离、认证授权、伸缩扩展、传输通讯、事务处理等相关工具
image: 1.png
date: 2025-08-13
slug: icyfenix-Hoeksteen
categories: 
  - 精选
  - 分布式
  - 架构
tags:
  - 分布式
  - 读后感
  - 架构
---

# 分布式的基石



## 分布式共识算法

> 前文书说过，分布式场景中，强一致性是最先被放弃的。但事务的主要目的就是要达到一致性。放弃强一致性，为了达到最终一致性，于是有了分布式共识算法。



少数服从多数，不强求所有节点都同意，少数默认按照多数的结果来统一结果。来达到所谓的最终一致性。

### 状态机

> 并不是共识算法，这也是一种达到一致性的方式，但是需要等消费完所有命令后才可以。依靠这种方式获得状态，有可能不是最终状态。



[状态机](https://en.wikipedia.org/wiki/Finite-state_machine)有一个特性：任何初始状态一样的状态机，如果执行的命令序列一样，则最终达到的状态也一样。如果将此特性应用在多参与者进行协商共识上，可以理解为系统中存在多个具有完全相同的状态机（参与者），这些状态机能最终保持一致的关键就是起始状态完全一致和执行命令序列完全一致。



- 状态复制

根据状态机的特性，要让多台机器的最终状态一致，只要确保它们的初始状态是一致的，并且接收到的操作指令序列也是一致的即可，无论这个操作指令是新增、修改、删除抑或是其他任何可能的程序行为，都可以理解为要将一连串的操作日志正确地广播给各个分布式节点。

广播指令与指令执行期间，允许系统内部状态存在不一致的情况，即并不要求所有节点的每一条指令都是同时开始、同步完成的，只要求在此期间的内部状态不能被外部观察到，且当操作指令序列执行完毕时，所有节点的最终的状态是一致的，这种模型就被称为**状态机复制**。









### Basic Paxos

> 世界上只有一种共识协议，就是Paxos，其他所有共识算法都是Paxos的退化版本。
>
> Paxos没有考虑拜占[拜占庭将军](https://en.wikipedia.org/wiki/Byzantine_fault)问题。
> 假设信息可能丢失也可能延迟，但不会被错误传递。







**角色介绍**：



- 提案节点（Proposer）：提出对某个值设置操作的节点，对值的操作被称提案，一旦设置成功，就不会丢失也不可改变。这里的设置值是一个日志记录操作。

  > Paxos是基于操作转移模型而非状态转移模型来设计的算法。

- 决策节点（Acceptor）：应答提案的节点，决定该节点是否被投票、是否可被接接受。提案一旦有过半数决策节点的接受，即称该提案被批准Accept，被批准的提案意味着该值不能再被更改，也不会丢失，最终所有节点都会接收该操作。

- 记录节点（leaner）：不参与提案，不参与决策，只是单纯的从提案、决策节点中学习已经达成共识的提案，譬如少数派节点从网络分区中恢复时，将进入这种状态。



> 每个节点都可能成为上面三种角色中的一种或多种，但为了明确多数派，决策节点的数量应该被设置成奇数，系统初始化时，每个节点都知道整个网络所有决策节点的数量、地址等信息。







**可能出现的问题**：

1. 系统内部各个节点通信是不可靠的，上面的所有角色，发出或收到信息，都可能延迟送达、也可能丢失，但不会出现信息传递错误的情况。
2. 系统外部各个用户访问可能是并发的。







**并发访问可能产生的问题**：

由于多个用户可能同时操作同一变量，请求到达的先后顺序可能会直接影响到值的结果。因此应当通过上锁，来使对于同一值的操作为串行化的。这样所有用户都能提前预判到自己本次操作会带来的结果。

> 但由于分布式系统中，每个节点都是不可靠的，所以传统的互斥锁很有可能会产生死锁。（如：某个节点取得锁后，与其他节点永久失联，此锁无法自动释放）
>
> 因此，必须提供一个其他节点能抢占锁的机制，避免因通信问题而出现死锁。

**分布式环境中的锁必须是可抢占的**



**Paxos的操作步骤**：



1. 准备（Prepare）：抢占锁的过程，如果某个提案节点准备发起提案，必须先向所有的决策节点广播一个许可申请（Prepare请求）。提案节点会在请求中附带一个全局唯一的数字n作为提案ID，决策节点收到请求后，会给提案节点两个承诺与一个应答：

   1. 承诺1：承诺不再接收提案ID小于或等于n的Prepare请求（抢锁请求）

   2. 承诺2：对于冲突的数据，承诺不再接收提案ID小于n的Accept请求。

   3. 应答：<font color='red'>在两个承诺的基础上，回复已经批准过的提案中ID最大的那个提案所设定的值和提案ID，如果该值没有被任何提案设定过，就返回空值。（对于来抢锁的节点，返回当前节点的最新值。）</font>

      > 如果收到的提案请求的Id值小于当前值最新通过的id，就直接忽略本次抢锁请求。

2. 批准（Accept）：尝试设置值.

   1. 没有冲突的情况，如果提案者发现所有响应的决策节点此前都没有批准过该值（最新值为空），说明本次是第一个设置值的节点，可以随意决定要设置的值，将自己选定的值与提案ID，构成二源数组[id,value]，再次广播给所有决策节点（Accept请求）。

   2. 如果提案者发现收到的影响中，已经有一个或多个节点的应答中含有值了，他就不能随意取值，必须无条件的接受从应答中找出的最大ID的值，构成二元数组，再次广播给所有决策节点（Accept请求）。

      > 提案者虽然发起了抢锁请求，如果抢到锁，尝试按照自己的值来设置值。
      >
      > 如果没有抢到锁，就按照抢锁请求中返回的结果来共同执行广播抢锁返回的结果。

3. 当提案节点收到多数决策节点应答后，协商结束，共识形成，将形成的决策发送给所有记录节点进行学习。



![1755247330909.png](https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-08/1755247330909_1755247330927.png)







**实例**：

