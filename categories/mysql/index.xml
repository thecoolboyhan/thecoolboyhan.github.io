<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mysql on 韩永发的博客</title><link>https://thecoolboyhan.github.io/categories/mysql/</link><description>Recent content in Mysql on 韩永发的博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 20 Jul 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://thecoolboyhan.github.io/categories/mysql/index.xml" rel="self" type="application/rss+xml"/><item><title>mysql的各种锁</title><link>https://thecoolboyhan.github.io/p/mysql-lock/</link><pubDate>Sun, 20 Jul 2025 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/mysql-lock/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/mysql-lock/1.png" alt="Featured image of post mysql的各种锁" /&gt;&lt;h1 id="mysql的各种锁"&gt;mysql的各种锁
&lt;/h1&gt;&lt;h2 id="表锁元数据锁的一种"&gt;表锁（元数据锁的一种）
&lt;/h2&gt;&lt;p&gt;锁整个表，主要由MyISAM、MEMORY等存储引擎使用。由Mysql提供。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上锁方式与表名息息相关，如果上锁时使用别名，那所有的操作都需要通过相同别名才有效。（原名称或其他别名访问上表锁数据，则无锁）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表级锁的优点是实现简单，性能开销小，但并发性较低，因为整个表被锁定，可能会导致其他会话等待。&lt;/p&gt;
&lt;h3 id="读锁read-lock"&gt;读锁（READ LOCK)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;允许当前事务和其他事务读取表，但禁止事务写入操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围：整个表，所有行和操作均受影响&lt;/li&gt;
&lt;li&gt;使用场景：适合保护整表数据一致性的读操作，例如报表生成。&lt;/li&gt;
&lt;li&gt;限制：读锁情况下，其他会话无法insert、update或Delete操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="坑重点"&gt;坑（重点）
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;使用lock指令上读锁后，会话也只能访问被读锁锁定的表，其他表无法访问：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-mysql" data-lang="mysql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kp"&gt;TABLES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;READ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;+----------+&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;+----------+&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;+----------+&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HY000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t2&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;was&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;locked&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kp"&gt;TABLES&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;使用别名上锁时，也只能锁定别名单独的锁&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-mysql" data-lang="mysql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WRITE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;AS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;READ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;was&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;locked&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kp"&gt;TABLES&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;AS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"
&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt; 发生错误，因为有两个 对锁定表的相同名称的引用。第二个 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"
&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt; 成功，因为 对表的引用使用不同的名称。&lt;/p&gt;
&lt;h3 id="写锁write-lock"&gt;写锁(WRITE LOCK)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;允许当前会话独占表，禁止其他会话读取或写入。（&lt;strong&gt;当前会话可以写入数据&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围：整个表，所有操作均被阻塞&lt;/li&gt;
&lt;li&gt;使用场景：适合需独占访问批量操作，如数据导入或表结构修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color='red'&gt;写锁会隐式提交当前事务，不是事务安全的&lt;/font&gt;&lt;/p&gt;
&lt;h2 id="行锁innodb锁"&gt;行锁（InnoDB锁）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;InnoDB的核心特性，支持更高的并发，允许多个事务同时操作不同行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;参考mysql&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener"
&gt;官方说明文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="共享锁shared-locks-lock"&gt;共享锁(Shared Lock，S Lock)
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;允许多个事务同时读取同一行（&lt;font color='red'&gt;与读锁并不是同一个锁，上锁范围根据where语句有关，一般会锁定固定的行&lt;/font&gt;），但禁止任务事务写入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围，特定行，仅影响被锁定的行。&lt;/li&gt;
&lt;li&gt;适用场合：读取操作需要保护数据的一致性，但允许并发读取。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;IN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SHARE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;MODE&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="排他锁exclusive-lockx-lock"&gt;排他锁（Exclusive Lock，X Lock）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;允许一个事务写入特定的行，禁止其他事务读取或写入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围：特定的行，仅影响被锁定的行。&lt;/li&gt;
&lt;li&gt;适用场景：写入操作需要独占访问。分布式开始上锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FOR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;UPDATE或UPDATE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;DELETE语句自动获取&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="意向锁intention-locks"&gt;意向锁（Intention Locks）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;意向共享锁IS ，意向排他锁IX&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表示事务打算在表中的某些行上获取共享锁或排他锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;锁定范围：整个表，但只表示意图，不锁定具体行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所用：用来协调表级锁和行级锁的兼容性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;意向锁与其他锁是否冲突&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="text-align: left"&gt;&lt;/th&gt;
&lt;th style="text-align: left"&gt;&lt;code&gt;X&lt;/code&gt;&lt;/th&gt;
&lt;th style="text-align: left"&gt;&lt;code&gt;IX&lt;/code&gt;&lt;/th&gt;
&lt;th style="text-align: left"&gt;&lt;code&gt;S&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;IS&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;X&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td&gt;冲突&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;IX&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td style="text-align: left"&gt;相容&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td&gt;相容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td style="text-align: left"&gt;相容&lt;/td&gt;
&lt;td&gt;相容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align: left"&gt;&lt;code&gt;IS&lt;/code&gt;&lt;/td&gt;
&lt;td style="text-align: left"&gt;冲突&lt;/td&gt;
&lt;td style="text-align: left"&gt;相容&lt;/td&gt;
&lt;td style="text-align: left"&gt;相容&lt;/td&gt;
&lt;td&gt;相容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;TABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;trx&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;10080&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IX&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="记录锁record-lock"&gt;记录锁（Record Lock）
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;锁定一个特定的索引记录&lt;font color='red'&gt;&lt;strong&gt;注意上锁范围为索引，可能是聚簇索引，也可以是普通索引&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围：特定的索引记录，如：SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;会锁定c1=10的行。&lt;/li&gt;
&lt;li&gt;使用场景：精确锁定特定的行&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;后续会详细详细讲解锁定方式等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="间隙锁gap-lock"&gt;间隙锁（Gap Lock）
&lt;/h3&gt;&lt;p&gt;锁定索引之间的间隙，防止其他事务插入新行，保护数据一致性。&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;&lt;strong&gt;读已提交级别禁用间隙锁，只有在可重复读级别存在&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围：索引记录间的间隙，例如索引值10和11之间的间隙（并不会锁定特定的行）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="next-key-lock"&gt;Next-Key Lock
&lt;/h3&gt;&lt;p&gt;记录锁和间隙锁的组合，及锁定一个索引记录，也锁定该记录前面的间隙。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上锁范围：一个索引及其前面的间隙，&lt;font color='red'&gt;&lt;strong&gt;左开又必，一定是间隙锁在前，记录锁在后。(negative infinity, 10]&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可重复读级别下可以方式幻读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="插入意向锁insert-intention-lock"&gt;插入意向锁（Insert Intention Lock）
&lt;/h3&gt;&lt;p&gt;在插入操作时，表示事务打算插入一个新行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;锁定范围：插入位置的间隙，允许多个事务并发插入非冲突行。&lt;strong&gt;&lt;font color='red'&gt;如果是冲突行，会阻塞后插入的行&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作用：提高插入操作的并发性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="auto-inc锁"&gt;AUTO-INC锁
&lt;/h3&gt;&lt;p&gt;处理表中AUTO_INCREMENT列的自增ID分配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁定范围：整个表&lt;/li&gt;
&lt;li&gt;使用场景：确保自增ID的唯一性和顺序性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="mysql各种锁实战重点"&gt;mysql各种锁实战（重点）
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;教你如何查看各种锁信息，以及一些使用的tips&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-07/1753022340387_1753022340407.png"
loading="lazy"
alt="1753022340387.png"
&gt;&lt;/p&gt;
&lt;h3 id="读锁"&gt;读锁
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用lock指令上读锁后，会话也只能访问被读锁锁定的表，其他表无法访问：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-mysql" data-lang="mysql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kp"&gt;TABLES&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;READ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;+----------+&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;+----------+&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;+----------+&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HY000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t2&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;was&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;locked&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kp"&gt;TABLES&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;使用别名上锁时，也只能锁定别名单独的锁&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-mysql" data-lang="mysql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;WRITE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;AS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;READ&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ERROR&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1100&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;Table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;t&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;was&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;locked&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;LOCK&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kp"&gt;TABLES&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;AS&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;第一个 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"
&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt; 发生错误，因为有两个 对锁定表的相同名称的引用。第二个 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/insert.html" target="_blank" rel="noopener"
&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/a&gt; 成功，因为 对表的引用使用不同的名称。&lt;/p&gt;
&lt;h3 id="行锁间隙锁和next-key锁实战"&gt;行锁、间隙锁和Next-Key锁实战
&lt;/h3&gt;&lt;p&gt;初始表结构z及其数据如下&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-07/1753014382673_1753014382692.png"
loading="lazy"
alt="1753014382673.png"
&gt;&lt;/p&gt;
&lt;p&gt;模拟两个事务进行锁竞争：&lt;/p&gt;
&lt;p&gt;A事务执行如下语句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;利用普通索引B，锁住b=3的排他锁&lt;/p&gt;
&lt;p&gt;B事务尝试测试A事务对此表的锁定范围&lt;/p&gt;
&lt;h4 id="读已提交"&gt;读已提交
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;B事务尝试避开索引b，在锁定数据前插入数据：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;可以正常提交，未上锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;B事务尝试使用相同值b=3，插入数据：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;可以正常提交&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;利用普通索引的等值排他锁，结论&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;就算事务A通过普通索引来对b=3加锁，但读已提交隔离级别下。InnoDB并&lt;font color='red'&gt;&lt;strong&gt;不会对二级索引上锁，而是在第一次上锁时，通过二级索引确定具体会锁聚簇索引的某几行。一旦锁定行数确定，后续就算其他事务以相同条件的二级索引插入数据，也不会有锁冲突。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果上锁时的条件为范围呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A事务执行如下语句，通过普通索引给B&amp;gt;=3的数据上锁：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;B事务尝试插入b=4的数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;可以正常提交，无锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;B事务尝试修改a=7的数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;set&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;数据被锁定，无法提交。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就算是通过二级索引b&amp;gt;=3条件上锁，依然也只会在上锁时确认具体的行，并对具体的行加锁，后续就算有b=3，或b&amp;gt;3的数据插入也不会有影响。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试锁定主键的范围呢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务A修改上锁条件，尝试通过主键a&amp;gt;=5来上锁&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;B事务尝试插入满足a&amp;gt;=5的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;可以正常提交，无锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;结论&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在读已提交隔离级别下，就算尝试通过主键范围上锁，也只能在上锁时锁定具体的行，后续其他事务插入上锁时满足条件的新行，也不会被阻塞。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以读已提交情况下，只会通过主键索引来上锁，不会锁定二级索引，就算上锁时条件是二级索引，也只会被转换成锁定满足条件的主键索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="可重复读"&gt;可重复读
&lt;/h4&gt;&lt;p&gt;还是之前的数据，&lt;strong&gt;测试前一定要清除之前的数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 创建表 z
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;TABLE&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;PRIMARY&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INDEX&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;idx_b&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 插入数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;INSERT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;INTO&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;VALUES&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-07/1753014382673_1753014382692.png"
loading="lazy"
alt="1753014382673.png"
&gt;&lt;/p&gt;
&lt;p&gt;现在尝试在可重复读的情况下，再做一遍上次的操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过二级索引来上锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务A锁定b=3的二级索引&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;事务B尝试在数据之前插入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;无法提交，被锁定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务B修改数据重新插入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;无法提交，被锁定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务B尝试插入数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;无法提交，被锁定&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;事务B尝试插入数据&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;insert&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;into&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;成功，无锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过如下语句获取事务A锁定的具体的行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INDEX_NAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOCK_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOCK_STATUS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOCK_DATA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;performance_schema&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data_locks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出信息如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;INDEX_NAME&lt;/th&gt;
&lt;th&gt;LOCK_MODE&lt;/th&gt;
&lt;th&gt;LOCK_STATUS&lt;/th&gt;
&lt;th&gt;LOCK_DATA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;IX&lt;/td&gt;
&lt;td&gt;GRANTED&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;X,GAP&lt;/td&gt;
&lt;td&gt;GRANTED&lt;/td&gt;
&lt;td&gt;6, 7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;GRANTED&lt;/td&gt;
&lt;td&gt;3, 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;X,REC_NOT_GAP&lt;/td&gt;
&lt;td&gt;GRANTED&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;font color='red'&gt; 首先搞清楚，通过二级索引上锁时，数据是按照二级索引来排序的。（不是按照主键来排序的）。如果二级索引相同的值，则再按照主键排序。&lt;/font&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;意向排他锁，锁定具体表，但并不冲突&lt;/li&gt;
&lt;li&gt;第二行的x,GAP锁：间隙锁，锁定b=6，a=7到上一个数据之前的间隙，&lt;font color='red'&gt;b=6,a=7数据本身没有被锁定，可以修改&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;第三行x：Next-Key锁，锁定范围为：b=3，a=5数据本身，和它前面的一条数据的间隙（不包含前面的数据），也就是（b=1,a=3）之后的间隙。&lt;font color='red'&gt;a=3的数据本身可以被修改，但无法修改b&amp;gt;=2||b&amp;lt;=6的数据，因为都满足Next-Key锁的范围或GAP锁的范围&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;第四行X,REC_NOT_GAP：普通行锁，上锁范围为主键索引a=5，表示5这行数据本身被锁定&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;但是有特殊情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么要在做本次实验前先清楚表中数据重新插入？&lt;/p&gt;
&lt;p&gt;因为如果不删除，第一次实验时：插入的数据及时后续被删除，依然会影响上锁范围。导致锁有问题。&lt;/p&gt;
&lt;p&gt;可见，&lt;font color='red'&gt;在读已提交的隔离级别下，GAP和Next-Key锁并不稳定，被删除的数据可能会影响上锁的范围。&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过主键上锁&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;where&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;update&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过锁分析语句分析&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;INDEX_NAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOCK_MODE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOCK_STATUS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LOCK_DATA&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;performance_schema&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data_locks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;INDEX_NAME&lt;/th&gt;
&lt;th&gt;LOCK_MODE&lt;/th&gt;
&lt;th&gt;LOCK_STATUS&lt;/th&gt;
&lt;th&gt;LOCK_DATA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;td&gt;IX&lt;/td&gt;
&lt;td&gt;GRANTED&lt;/td&gt;
&lt;td&gt;NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;X,REC_NOT_GAP&lt;/td&gt;
&lt;td&gt;GRANTED&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;只会在固定a=5行来上锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color='red'&gt;在可重复读隔离级别下，通过二级索引上锁，数据会按照二级索引+主键索引的情况排序。即使只是通过排他锁锁定固定值的二级索引。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color='red'&gt;InnoDB也会在锁定值前：上一个Next-Key锁，锁定范围为上一条数据（不包含），到本条数据。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color='red'&gt;在锁定值后：上一个GAP间隙锁，锁定范围为指定值到下一条数据（不包含）的间隙。&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;注意，这里提到的上一条数据和下一条数据包括曾经被删除但没有被整理的数据。所以在可重复读下，二级索引上锁并不稳定。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以推荐，可重复读隔离级别下，劲量只通过主键索引来上锁，不要通过二级索引上锁，否则会导致上锁范围收到影响。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="蛇足"&gt;蛇足
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;表级的意向排它锁（IX）：lock mode IX。&lt;/li&gt;
&lt;li&gt;表级的插入意向锁（LOCK_INSERT_INTENTION）: lock_mode X locks gap before rec insert intention&lt;/li&gt;
&lt;li&gt;行级的记录锁（LOCK_REC_NOT_GAP）: lock_mode X locks rec but not gap&lt;/li&gt;
&lt;li&gt;行级的间隙锁（LOCK_GAP）: lock_mode X locks gap before rec&lt;/li&gt;
&lt;li&gt;行级的 Next-key 锁（LOCK_ORNIDARY）: lock_mode X&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在「读未提交」隔离级别下，读写操作可以同时进行，但写写操作无法同时进行。与此同时，该隔离级别下只会使用行级别的记录锁，并不会用间隙锁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在「可重复读」隔离级别下，使用了记录锁、间隙锁、Next-Key 锁三种类型的锁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可重复读存在幻读的问题，但实际上在 MySQL 中，因为其使用了间隙锁，所以在「可重复读」隔离级别下，可以通过加 锁解决幻读问题。因此，MySQL 将「可重复读」作为了其默认的隔离级别。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同版本如何查看各种锁信息&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;MySQL 5.6&lt;/th&gt;
&lt;th&gt;MySQL 5.7&lt;/th&gt;
&lt;th&gt;MySQL 8.0&lt;/th&gt;
&lt;th&gt;MySQL 8.4&lt;/th&gt;
&lt;th&gt;注意事项&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SHOW ENGINE INNODB STATUS&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;需启用 innodb_status_output_locks&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW PROCESSLIST&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;显示线程状态，非锁详情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHOW OPEN TABLES&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;适合 MyISAM 表锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INNODB_LOCKS/WAITS&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;废弃&lt;/td&gt;
&lt;td&gt;废弃&lt;/td&gt;
&lt;td&gt;MySQL 8.0.1 起用 data_locks&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;INNODB_TRX&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;查看活跃事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;performance_schema.data_locks&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;需启用 Performance Schema&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;performance_schema.metadata_locks&lt;/td&gt;
&lt;td&gt;❌&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;适合元数据锁和用户锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IS_USED_LOCK&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;✅&lt;/td&gt;
&lt;td&gt;查看 GET_LOCK 锁&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description></item><item><title>读《mysql是怎样运行的》有感</title><link>https://thecoolboyhan.github.io/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/</link><pubDate>Thu, 17 Apr 2025 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/%E8%AF%BBmysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%89%E6%84%9F/1.png" alt="Featured image of post 读《mysql是怎样运行的》有感" /&gt;&lt;blockquote&gt;
&lt;p&gt;1111&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="读mysql是怎样运行的有感"&gt;读《mysql是怎样运行的》有感
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;粗略了解mysql， 模拟一条查询的过程。&lt;/p&gt;
&lt;p&gt;介绍主流的存储引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第一章重新认识mysql"&gt;第一章、重新认识mysql
&lt;/h2&gt;&lt;h3 id="一条sql会经历的阶段"&gt;一条sql会经历的阶段
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;查询缓存：（8.0后删除）是否可以从缓存中直接得到答案&lt;/li&gt;
&lt;li&gt;语法解析：（编译过程）翻译sql语句&lt;/li&gt;
&lt;li&gt;查询优化：转换sql，生成执行计划（是否走索引等）&lt;/li&gt;
&lt;li&gt;存储引擎：交给存储引擎去真正执行查询&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;查询缓存在什么时候会失效？(mysql 8.0之后删除查询缓存)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果两个查询请求在任何字符上的不同（如：空格、注释、大小写），都会导致缓存不会命中。如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如mysql 、information_schema、performance_schema 数据库中的表，那这个请求就不会被缓存。&lt;/p&gt;
&lt;h3 id="常见的存储引擎"&gt;常见的存储引擎
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;常见的存储引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;存储引擎&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ARCHIVE&lt;/td&gt;
&lt;td&gt;用于数据存档（行被插入后不能再修改）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLACKHOLE&lt;/td&gt;
&lt;td&gt;丢弃写操作，读操作会返回空内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CSV&lt;/td&gt;
&lt;td&gt;在存储数据时，以逗号分隔各个数据项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FEDERATED&lt;/td&gt;
&lt;td&gt;用来访问远程表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;InnoDB&lt;/td&gt;
&lt;td&gt;具备外键支持功能的事务存储引擎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MEMORY&lt;/td&gt;
&lt;td&gt;置于内存的表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MERGE&lt;/td&gt;
&lt;td&gt;用来管理多个MyISAM表构成的表集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MyISAM&lt;/td&gt;
&lt;td&gt;主要的非事务处理存储引擎&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NDB&lt;/td&gt;
&lt;td&gt;MySQL集群专用存储引擎&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;各功能支持情况&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;feature&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;MyISAM&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Memory&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;InnoDB&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Archive&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;NDB&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;B-tree indexes 索引&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Backup/point-in-time recovery 时间镜像备份&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cluster database support 集群&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Clustered indexes 聚簇索引&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compressed data 数据压缩&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data caches 数据缓存&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Encrypted data 数据加密&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Foreign key support 外键&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Full-text search indexes 全文搜索索引&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Geospatial data type support 空间数据类型支持&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Geospatial indexing support 空间索引支持&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hash indexes 哈希索引&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Index caches 索引缓存&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;N/A&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Locking granularity 锁粒度&lt;/td&gt;
&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;Table&lt;/td&gt;
&lt;td&gt;Row&lt;/td&gt;
&lt;td&gt;Row&lt;/td&gt;
&lt;td&gt;Row&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MVCC 多版本并发控制&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Query cache support 查询缓存&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replication support 主从复制&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;Limited&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Storage limits 存储限制&lt;/td&gt;
&lt;td&gt;256TB&lt;/td&gt;
&lt;td&gt;RAM&lt;/td&gt;
&lt;td&gt;64TB&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;td&gt;384EB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;T-tree indexes T-tree索引&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Transactions 事务&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;no&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Update statistics for data dictionary 更新数据字典&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;td&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;可以为不同的表设置不同的存储引擎&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;从InnoDB行记录的角度理解一行数据是如何存储的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第四章innodb记录结构"&gt;第四章、InnoDB记录结构
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;InnoDB的存储方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将数据划分成若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为16KB。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四种行格式&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;行格式&lt;/th&gt;
&lt;th&gt;紧凑的存储特性&lt;/th&gt;
&lt;th&gt;增强的可变长度列存储&lt;/th&gt;
&lt;th&gt;大型索引键前缀支持&lt;/th&gt;
&lt;th&gt;压缩支持&lt;/th&gt;
&lt;th&gt;支持的表空间类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;REDUNDANT&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;系统，每个表的文件，一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMPACT&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;系统，每个表的文件，一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DYNAMIC&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;系统，每个表的文件，一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMPRESSED&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;是的&lt;/td&gt;
&lt;td&gt;文件每表，一般&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="compact行格式"&gt;&lt;strong&gt;COMPACT&lt;/strong&gt;行格式
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855104065_1744855104091.png"
loading="lazy"
alt="1744855104065.png"
&gt;&lt;/p&gt;
&lt;h4 id="记录的额外信息"&gt;记录的额外信息
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;服务器为了描述这条记录而不得不额外添加的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="变长字段长度列表"&gt;变长字段长度列表
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;变长字段的长度不是固定的，所以在存储时，需要占用两部分空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;真正的数据内容&lt;/li&gt;
&lt;li&gt;占用的字节数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;把所有变长字段的真实数据数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段占用的字节数按照列的顺序 &lt;font color='red'&gt;**逆序 **&lt;/font&gt; 存放。&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt; &lt;strong&gt;如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ）超过127字节，则使用2个字节，否则使用1个字节。&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;变长字段长度列表中只存储值为非NULL的列内容占用的长度，值为NULL的列的长度是不需要存储的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="null值列表"&gt;NULL值列表
&lt;/h4&gt;&lt;p&gt;COMPACT行格式会把这些值为NULL的列统一管理起来。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先统计表中允许存储NULL的列有哪些&lt;/li&gt;
&lt;li&gt;如果表中没有允许存储NULL的列，则NULL值列表也不存在了&lt;/li&gt;
&lt;li&gt;mysql规定NUll列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则字节的高位补0.（8bit）&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="记录头信息"&gt;记录头信息
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;用于描述记录的记录头信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;大小（单位：bit）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;预留位1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;没有使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预留位2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;没有使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete_mask&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;标记该记录是否被删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;min_rec_mask&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;B+树的每层非叶子节点中的最小记录都会添加该标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n_owned&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;表示当前记录拥有的记录数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;heap_no&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;表示当前记录在记录堆的位置信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;record_type&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;表示当前记录的类型，0 表示普通记录，1 表示B+树非叶子节点记录，2 表示最小记录，3 表示最大记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;next_record&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;表示下一条记录的相对位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="记录的真实数据"&gt;记录的真实数据
&lt;/h4&gt;&lt;p&gt;真实存储的数据，除了这些数据外，mysql还会默认生成以下列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mysql隐藏列&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;占用空间&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;row_id&lt;/td&gt;
&lt;td&gt;否（InnoDB指定主键时才存在）&lt;/td&gt;
&lt;td&gt;6 字节&lt;/td&gt;
&lt;td&gt;行ID，唯一标识一条记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transaction_id&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;6 字节&lt;/td&gt;
&lt;td&gt;事务ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;roll_pointer&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;7 字节&lt;/td&gt;
&lt;td&gt;回滚指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color='red'&gt;mysql主键的生成策略&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果连Unique键都没有，则InnoDB会为表添加一个名为row_id的隐藏列作为主键。&lt;/p&gt;
&lt;h3 id="行溢出数据"&gt;行溢出数据
&lt;/h3&gt;&lt;p&gt;varchar最多可以占用65535个字节，除了BLOB或者TEXT类型的列之外，其他所有的列占用字节长度加起来不能超过65535个字节。&lt;/p&gt;
&lt;p&gt;mysql一页大小为16kb，也就是16384字节。对于占用空间非常大的也，真实数据区域只会存储该列的一部分数据，把剩余数据分散存储到其他的也中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不只是 &lt;em&gt;&lt;strong&gt;VARCHAR(M)&lt;/strong&gt;&lt;/em&gt; 类型的列，其他的 &lt;em&gt;&lt;strong&gt;TEXT&lt;/strong&gt;&lt;/em&gt;、&lt;em&gt;&lt;strong&gt;BLOB&lt;/strong&gt;&lt;/em&gt; 类型的列在存储数据非常多的时候也会发生 行溢出&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;解释InnoDB一页数据是如何存放的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第五章innodb数据页结构"&gt;第五章、InnoDB数据页结构
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855192735_1744855192753.png"
loading="lazy"
alt="1744855192735.png"
&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;中文名&lt;/th&gt;
&lt;th&gt;占用空间大小&lt;/th&gt;
&lt;th&gt;简单描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;File Header&lt;/td&gt;
&lt;td&gt;文件头部&lt;/td&gt;
&lt;td&gt;38 字节&lt;/td&gt;
&lt;td&gt;页的一些通用信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Page Header&lt;/td&gt;
&lt;td&gt;页面头部&lt;/td&gt;
&lt;td&gt;56 字节&lt;/td&gt;
&lt;td&gt;数据页专有的一些信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Infimum + Supremum&lt;/td&gt;
&lt;td&gt;最小记录和最大记录&lt;/td&gt;
&lt;td&gt;26 字节&lt;/td&gt;
&lt;td&gt;两个虚拟的行记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;User Records&lt;/td&gt;
&lt;td&gt;用户记录&lt;/td&gt;
&lt;td&gt;不确定&lt;/td&gt;
&lt;td&gt;实际存储的行记录内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Free Space&lt;/td&gt;
&lt;td&gt;空闲空间&lt;/td&gt;
&lt;td&gt;不确定&lt;/td&gt;
&lt;td&gt;页中尚未使用的空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Page Directory&lt;/td&gt;
&lt;td&gt;页面目录&lt;/td&gt;
&lt;td&gt;不确定&lt;/td&gt;
&lt;td&gt;页中的某些记录的相对位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;File Trailer&lt;/td&gt;
&lt;td&gt;文件尾部&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;校验页是否完整&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="记录头信息-1"&gt;记录头信息
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;大小 (单位: bit)&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;预留位1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;没有使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;预留位2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;没有使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete_mask&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;标记该记录是否被删除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;min_rec_mask&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;B+树的每层非叶子节点中的最小记录都会添加该标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n_owned&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;表示当前记录拥有的记录数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;heap_no&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;表示当前记录在记录堆的位置信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;record_type&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;表示当前记录的类型：0-普通记录，1-B+树非叶节点记录，2-最小记录，3-最大记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;next_record&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;表示下一条记录的相对位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;delete_mask&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;标记当前记录是否被删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;被删除的数据会被标记，并放入一个&lt;em&gt;垃圾链表&lt;/em&gt; ，链表中的记录占用的空间是可重用空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;next_record&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;从当前记录的真实数据到下一条记录的真实数据地址偏移量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;font color='red'&gt;下一条记录： &lt;/font&gt;&lt;/p&gt;
&lt;p&gt;指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。&lt;/p&gt;
&lt;p&gt;***Infimum***&lt;strong&gt;记录（也就是最小记录）&lt;/strong&gt; 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 *&lt;strong&gt;Supremum*****记录（也就是最大记录）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模拟删除一条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原记录：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855231499_1744855231519.png"
loading="lazy"
alt="1744855231499.png"
&gt;&lt;/p&gt;
&lt;p&gt;删除第二条数据：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855254240_1744855254257.png"
loading="lazy"
alt="1744855254240.png"
&gt;&lt;/p&gt;
&lt;p&gt;不论我们怎样对页中的记录做增删改操作，InnoDB始终维护一条记录的单链表，链表中的各个节点是按照主键值由小到大连接起来的。&lt;/p&gt;
&lt;p&gt;再插入一条记录：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855310294_1744855310312.png"
loading="lazy"
alt="1744855310294.png"
&gt;&lt;/p&gt;
&lt;h3 id="蛇足"&gt;蛇足
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在page Directory中，所以在一页中根据主键去查找记录非常快：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过二分查找确定记录所在的槽&lt;/li&gt;
&lt;li&gt;通过记录的next_rocord属性遍历该槽所在的组中的各个记录。（通过偏移量直接定位地址）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;存储方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个数据页的fileHeader部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何确保数据完整&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了保证数据的完整性，页的首部和尾部都会存储页中数据的校验和，和页面最后修改时的LSN值。如果两个校验不通过，表示数据同步过程中出现了问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB的索引结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第六章b树索引"&gt;第六章B+树索引
&lt;/h2&gt;&lt;h3 id="索引方案"&gt;索引方案
&lt;/h3&gt;&lt;p&gt;复用存储用户记录的数据页来存储目录项。通过record_type来区分。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855340206_1744855340223.png"
loading="lazy"
alt="1744855340206.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;索引页的record_type值为1，用户记录的record_type值为0&lt;/li&gt;
&lt;li&gt;索引页记录只有主键值和页的编号两列，用户记录是用户自己定义的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如何根据主键值查找&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;先到存储索引记录的页，通过二分查找快速定位到对应的目录项。如定位到记录在页9&lt;/li&gt;
&lt;li&gt;通过偏移量找到页9，在通过二分查找找到对应的记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855362514_1744855362530.png"
loading="lazy"
alt="1744855362514.png"
&gt;&lt;/p&gt;
&lt;p&gt;用户的记录都存放在B+树的最底层的节点上，其他的非叶子节点用来存储目录（索引页）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们大概需要多少层数据？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、如果 B+ 树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。&lt;/p&gt;
&lt;p&gt;2、如果 B+ 树有2层，最多能存放 1000×100=100000 条记录。&lt;/p&gt;
&lt;p&gt;3、如果 B+ 树有3层，最多能存放 1000×1000×100=100000000 条记录。&lt;/p&gt;
&lt;p&gt;4、如果 B+ 树有4层，最多能存放 1000×1000×1000×100=100000000000 条记录。&lt;/p&gt;
&lt;h3 id="聚簇索引"&gt;聚簇索引
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;InnoDB的数据默认使用聚簇索引来存储。&lt;font color='red'&gt;索引即数据，数据即索引&lt;/font&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="聚簇索引的特点"&gt;聚簇索引的特点：
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;使用记录主键值的大小进行记录和页的排序
&lt;ul&gt;
&lt;li&gt;页内的记录按照主键的大小顺序排成一个单向链表&lt;/li&gt;
&lt;li&gt;存放用户记录的页是根据也中用户记录的主键大小排成一个双向链表&lt;/li&gt;
&lt;li&gt;存放目录项记录的页分为不同的层次，同一层中的页是根据目录项页中的主键大小顺序排成的一个双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B+树的叶子节点存储完整的用户记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="二级索引"&gt;二级索引
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;用户根据自己的规则给非主键值建立的索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样使用B+树来存储，不过叶子节点用来存储的是主键值，而不是完整的用户记录。&lt;/p&gt;
&lt;p&gt;所以想要通过二级索引来查询一条记录，需要先在二级索引上搜索出主键值。&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;再根据主键值去聚簇索引中再查找一遍完整的用户记录（回表）&lt;/font&gt;&lt;/p&gt;
&lt;h3 id="总结"&gt;总结
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个索引都对应一棵 B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有 用户记录都存储在 B+ 树的叶子节点，所有 目录项记录 都存储在内节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立 聚簇索引 ，聚簇索引的叶子节点包含完整的用户记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们可以为自己感兴趣的列建立 二级索引 ， 二级索引 的叶子节点包含的用户记录由 索引列 + 主键 组成，所以如果想通过 二级索引 来查找完整的用户记录的话，需要通过 回表 操作，也就是在通过 二级索引找到主键值之后再到 聚簇索引 中查找完整的用户记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是 联合索引 的话，则页面和记录先按照 联合索引 前边的列排序，如果该列值相同，再按照 联合索引 后边的列排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过索引查找记录是从 B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color='red'&gt;一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在使用索引时需要注意下边这些事项：
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只为用于搜索、排序或分组的列创建索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为列的基数大的列创建索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引列的类型尽量小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以只对字符串值的前缀建立索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有索引列在比较表达式中单独出现才可以适用索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定位并删除表中的重复和冗余索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量使用 覆盖索引 进行查询，避免 回表 带来的性能损耗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;数据是如何在mysql中存储的，默认的数据库大概有哪些&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第八章mysql的数据目录"&gt;第八章、mysql的数据目录
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数据目录：用来存储mysql在运行过程中产生的数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="数据库在文件系统"&gt;数据库在文件系统
&lt;/h3&gt;&lt;p&gt;每个数据库都对应数据目录下的一个子文件夹，当我们创建数据库时，mysql会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在数据目录下创建一个和数据库同名的子目录&lt;/li&gt;
&lt;li&gt;在与数据库同名的子目录下创建一个名为db.opt的文件，这文件中包含了该数据库的各种属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="表在文件系统中"&gt;表在文件系统中
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;表结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在数据目录下对应的数据库子目录下创建一个专门描述表结构的文件。（表名.frm）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个frm文件是以二进制的形式存储的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="innodb的表数据"&gt;InnoDB的表数据
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;表空间（table space）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;文件系统上一个或多个真实的文件，每个表空间可以被划分为很多个页，表数据就存在表空间下的某些页里。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统表空间&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在数据目录下名为ibdata1，大小为12M的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.5.7到5.6.6(不包括)之间的版本，数据都会默认被存储到系统表空间中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立表空间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.6.6及以后得版本，每一个表都会建立独立表空间（表名.ibd）&lt;/p&gt;
&lt;h4 id="myisam表数据"&gt;MyISAM表数据
&lt;/h4&gt;&lt;p&gt;表数据都存放到对应的数据库子目录下。共三个文件：&lt;/p&gt;
&lt;p&gt;test.frm：表结构&lt;/p&gt;
&lt;p&gt;test.MYD：表的数据文件&lt;/p&gt;
&lt;p&gt;test.MYI：表的索引&lt;/p&gt;
&lt;h3 id="mysql默认的系统数据库"&gt;mysql默认的系统数据库
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;information_schema&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引，这些信息不是用户的真实数据，而是一些描述信息。也被成为元数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;performance_schema&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。&lt;/p&gt;
&lt;p&gt;包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sys&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;详细描述表空间的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第九章innodb表空间"&gt;第九章、InnoDB表空间
&lt;/h2&gt;&lt;h3 id="一个数据页"&gt;一个数据页
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个页通用的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855397911_1744855397927.png"
loading="lazy"
alt="1744855397911.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;file Header：记录一些通用信息&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;占用空间大小&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_SPACE_OR_CHKSUM&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;页的校验和（checksum 值）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_OFFSET&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;页号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_PREV&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;上一个页的页号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_NEXT&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;下一个页的页号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_LSN&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;页面被最后修改时对应的日志序列位置 (Log Sequence Number)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_TYPE&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;该页的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_FILE_FLUSH_LSN&lt;/td&gt;
&lt;td&gt;8 字节&lt;/td&gt;
&lt;td&gt;仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的 LSN 值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;页属于哪个表空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;File Trailer：检查页是否完整，保证从内存到磁盘刷新时内容的一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一个表空间最多支持64TB的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="独立表空间"&gt;独立表空间
&lt;/h3&gt;&lt;h4 id="区extent"&gt;区（extent）
&lt;/h4&gt;&lt;p&gt;表空间中的页实在太多了，为了更好的管理这些页，提出了区的概念。&lt;/p&gt;
&lt;p&gt;对于默认16k的页来说，连续64页就是一个区（1MB左右）。每个256个区就被划分成一组。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855427995_1744855462433.png"
loading="lazy"
alt="1744855427995.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区0到区255是第一组，256~511是第二组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;表空间被划分为许多连续的区 ，每个区默认由64个页组成，每256个区划分为一组。&lt;/p&gt;
&lt;h4 id="段segment"&gt;段（segment）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;为什么要引入区？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color='red'&gt;没有区的情况&lt;/font&gt;：存放数据的多个页其实是双向链表，上一个页和它的下一个页之间，在磁盘上可能不是连续的。这样在不同的页之间扫描，会触发磁盘的&lt;font color='red'&gt;随机IO&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;有区之后&lt;/font&gt;：当引入区之后，一个区内的页是顺序且连续的，每个逻辑相邻的页在物理磁盘上页也是相邻的。这样就可以&lt;font color='red'&gt;触发顺序IO。有效提高性能。&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是段？&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;段是用于区分不同类型区的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;叶子节点有自己独有的区，非叶子节点也有自己独有的区。&lt;/p&gt;
&lt;p&gt;存放叶子节点的多个区就算是一个段。&lt;/p&gt;
&lt;p&gt;存放非叶子节点的多个区也算是一个段。&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;一个索引会产生2个段，一个叶子节点段。一个非叶子节点段。&lt;/font&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不止包含上面提到的两种段，还存在别的段（回滚段等）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态名&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FREE&lt;/td&gt;
&lt;td&gt;空闲的区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FREE_FRAG&lt;/td&gt;
&lt;td&gt;有剩余空间的碎片区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FULL_FRAG&lt;/td&gt;
&lt;td&gt;没有剩余空间的碎片区&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FSEG&lt;/td&gt;
&lt;td&gt;附属于某个段的区&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;以上表格中的区，只有FSEG属于段，其他的区都直接属于mysql，不属于某个段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="模拟插入一条数据"&gt;模拟插入一条数据
&lt;/h4&gt;&lt;pre class="mermaid"&gt;
graph TD
a[插入一条数据]--&amp;gt;b{判断是否有剩余空间的碎片区}
b--&amp;gt;|yes|c[插入到碎片区]
b--&amp;gt;|no|d[到表空间下申请一个状态为空闲的区,把数据插入到新申请区中的碎片页里.\n此区中零碎的页会为多个段服务,如果该区已满,此区就变为没有剩余空间的碎片区]
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;讲解单表查询过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第10章单表查询"&gt;第10章、单表查询
&lt;/h2&gt;&lt;h3 id="const"&gt;const
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;直接通过主键来确认记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;直接通过id查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855506669_1744855506684.png"
loading="lazy"
alt="1744855506669.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过唯一二级索引可以确定到唯一的id，然后同上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855581630_1744855581646.png"
loading="lazy"
alt="1744855581630.png"
&gt;&lt;/p&gt;
&lt;h3 id="ref"&gt;ref
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过非唯一的二级索引&lt;font color='red'&gt;等值&lt;/font&gt;获取到多个id，然后回聚簇索引来查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855603236_1744855603253.png"
loading="lazy"
alt="1744855603236.png"
&gt;&lt;/p&gt;
&lt;h3 id="range"&gt;range
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过索引进行的范围扫描&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如id大于10小于30&lt;/p&gt;
&lt;h3 id="index"&gt;index
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;通过二级索引的全索引扫描可以确认当前值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设二级索引是联合索引（a-b-c），查询的where条件只有b没有a，无法通过二级索引查询策略，但是可以在二级索引上扫描到当前数据。&lt;/p&gt;
&lt;h3 id="all"&gt;all
&lt;/h3&gt;&lt;p&gt;全表扫描，直接扫描聚簇索引。&lt;/p&gt;
&lt;h3 id="回表"&gt;回表
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;步骤1：使用二级索引定位记录的阶段，也就是根据条件 key1 = &amp;lsquo;abc&amp;rsquo; 从 idx_key1 索引代表的 B+ 树中找到对应的二级索引记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行 回表 操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件 key2 &amp;gt; 1000 到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color='red'&gt;为什么要尽量避免出现回表操作？&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在二级索引扫描，之前提到都是顺序IO，扫描速度快。但如果回到局促索引中确定数据，需要进行随机IO，扫描速度慢。（慢很多）&lt;/p&gt;
&lt;h3 id="索引合并"&gt;索引合并
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;查询条件会用到多个不同的二级索引，mysql可以组装两个二级索引查询出的数据的交集，然后在回表去聚簇索引中查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;合并索引是为了尽量避免回表操作，减少随机IO。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;会触发索引合并的条件：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;用到的两个不同索引的查询条件都是等值匹配时。（一个等值，一个范围则无法使用）&lt;/li&gt;
&lt;li&gt;查询条件中有主键，且只有主键是范围查询，其他二级索引都是等值查询时开会生效&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;因为只有上面两个条件下从二级索引查出的数据都是按照主键排序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;各种join查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第11章两表连接与基于成本的优化"&gt;第11章、两表连接与基于成本的优化
&lt;/h2&gt;&lt;h3 id="连接的原理"&gt;连接的原理
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;两表join查询，驱动的表只会访问一遍，被去驱动的表要被访问多次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;步骤1：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的单表查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855639611_1744855639628.png"
loading="lazy"
alt="1744855639611.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="成本"&gt;成本
&lt;/h3&gt;&lt;p&gt;mysql有默认的成本常量，可以通过成本常量来计算出不同方案查询需要的成本。mysql再选择成本最低的方案来执行。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成本常数名称&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;disk_temptable_create_cost&lt;/td&gt;
&lt;td&gt;40.0&lt;/td&gt;
&lt;td&gt;创建基于磁盘的临时表的成本，增大该值可减少磁盘临时表的创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;disk_temptable_row_cost&lt;/td&gt;
&lt;td&gt;1.0&lt;/td&gt;
&lt;td&gt;向磁盘临时表写入或读取一条记录的成本，增大该值可减少磁盘临时表的创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;key_compare_cost&lt;/td&gt;
&lt;td&gt;0.1&lt;/td&gt;
&lt;td&gt;两条记录比较操作的成本，多用于排序，增大该值可提高 filesort 成本，使优化器更倾向于使用索引排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_temptable_create_cost&lt;/td&gt;
&lt;td&gt;2.0&lt;/td&gt;
&lt;td&gt;创建基于内存的临时表的成本，增大该值可减少内存临时表的创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;memory_temptable_row_cost&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;向内存临时表写入或读取一条记录的成本，增大该值可减少内存临时表的创建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;row_evaluate_cost&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;记录是否符合搜索条件的成本，增大该值可能让优化器更倾向于使用索引而非全表扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;InnoDB的表信息是不准确的估值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;内外连接的区别？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;外连接驱动表的记录，无法被找到匹配on自居中的过滤条件的记录，该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段顺手NULL值填充。&lt;/p&gt;
&lt;p&gt;内连接驱动表的记录无法在被驱动表中找到的匹配on语句中过滤条件的记录，该记录会被舍弃。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855661461_1744855661476.png"
loading="lazy"
alt="1744855661461.png"
&gt;&lt;/p&gt;
&lt;h3 id="in查询"&gt;in查询
&lt;/h3&gt;&lt;p&gt;不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;详细介绍Explain&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第15章explain详解"&gt;第15章、Explain详解
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;在一个大的查询语句中每个 SELECT 关键字都对应一个唯一的 id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select_type&lt;/td&gt;
&lt;td&gt;SELECT 关键字对应的那个查询的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;td&gt;表名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partitions&lt;/td&gt;
&lt;td&gt;匹配的分区信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;针对单表的访问方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;possible_keys&lt;/td&gt;
&lt;td&gt;可能用到的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;key&lt;/td&gt;
&lt;td&gt;实际上使用的索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;key_len&lt;/td&gt;
&lt;td&gt;实际使用到的索引长度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ref&lt;/td&gt;
&lt;td&gt;当使用索引列等值查询时，与索引列进行等值匹配的对象信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rows&lt;/td&gt;
&lt;td&gt;预估的需要读取的记录条数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filtered&lt;/td&gt;
&lt;td&gt;某个表经过搜索条件过滤后剩余记录条数的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extra&lt;/td&gt;
&lt;td&gt;一些额外的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="各属性的介绍"&gt;各属性的介绍
&lt;/h3&gt;&lt;h4 id="id"&gt;id
&lt;/h4&gt;&lt;p&gt;每次查询都会生成一个id，如果一条查询需要查询多个表，就会生成多条id相同的记录。&lt;/p&gt;
&lt;p&gt;如果有union子句需要把两个查询的结果合并起来，mysql会使用内部的临时表（临时表id为null）&lt;/p&gt;
&lt;h4 id="select_type"&gt;Select_type
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SIMPLE&lt;/td&gt;
&lt;td&gt;不包含union或者子查询的查询（连接查询也是simple）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;union、union All或者子查询的大查询等，由多个小查询组成的，其中最左面的查询就是primary&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNION&lt;/td&gt;
&lt;td&gt;UNION 中的第二个或更后续的 SELECT 是union&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNION RESULT&lt;/td&gt;
&lt;td&gt;UNION 的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SUBQUERY&lt;/td&gt;
&lt;td&gt;子查询中的第一个 SELECT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DEPENDENT SUBQUERY&lt;/td&gt;
&lt;td&gt;依赖于外部查询的子查询中的第一个 SELECT&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DEPENDENT UNION&lt;/td&gt;
&lt;td&gt;依赖于外部查询的 UNION 中的第二个或更后续的 SELECT 语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DERIVED&lt;/td&gt;
&lt;td&gt;派生表（需要临时表）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MATERIALIZED&lt;/td&gt;
&lt;td&gt;物化子查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNCACHEABLE SUBQUERY&lt;/td&gt;
&lt;td&gt;结果无法缓存并且必须针对外部查询的每一行重新评估的子查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNCACHEABLE UNION&lt;/td&gt;
&lt;td&gt;属于不可缓存子查询的 UNION 中的第二个或更后续的 SELECT 语句 (见 UNCACHEABLE SUBQUERY)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="type"&gt;type
&lt;/h4&gt;&lt;p&gt;前面文章提到的执行计划&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;system&lt;/td&gt;
&lt;td&gt;查询系统表，如myisam的数量（InnoDB的数量是不可靠的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;td&gt;主键等值匹配（通过唯一二级索引确定唯一id到也算）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;eq_ref&lt;/td&gt;
&lt;td&gt;非唯一的二级索引等值获取到多个id，会聚簇索引查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index_merge&lt;/td&gt;
&lt;td&gt;第十章中提到的索引合并&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unique_subquery&lt;/td&gt;
&lt;td&gt;两表连接中的eq_ref等值查询（经常出现在in id关联查询中）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index_subquery&lt;/td&gt;
&lt;td&gt;与上面类似，只是关联条键是普通索引&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;使用索引的范围扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;全索引扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;All&lt;/td&gt;
&lt;td&gt;全表扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="extra扩展信息"&gt;extra（扩展信息）
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;No tables used&lt;/td&gt;
&lt;td&gt;没有from子句，不查表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Impossible WHERE&lt;/td&gt;
&lt;td&gt;where语句无效，永远不成立&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;No matching min/max row&lt;/td&gt;
&lt;td&gt;使用min/max函数，但where条件过滤掉了所有数据（没有数据）时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Using index&lt;/td&gt;
&lt;td&gt;只需要使用索引数据，不需要回表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Using index condition&lt;/td&gt;
&lt;td&gt;where条件中有索引，但不能使用索引（新版本表示使用了索引下推）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Using where&lt;/td&gt;
&lt;td&gt;使用where条件进行了全表扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Using join buffer (Block Nested Loop)&lt;/td&gt;
&lt;td&gt;无法使用索引的关联查询，mysql需要建立临时的buffer块来加快查询&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Using filesort&lt;/td&gt;
&lt;td&gt;需要使用文件重排序，如果数据很多会非常慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Using temporary&lt;/td&gt;
&lt;td&gt;多个查询的过程中，需要临时表，一般在排序、去重等查询中常见 DISTINCT 、 GROUP BY 、 UNION&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="蛇足-1"&gt;蛇足
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;查看成本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果想看某个执行计划的成本，可以在explain后添加FORMAT=JSON&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color='red'&gt;查询优化器的过程&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;解析sql语句：把查询等转换成具体的语句，如select* 转换成查询具体字段&lt;/li&gt;
&lt;li&gt;优化：计算各种成本，如是否可以走索引，直接查聚簇索引，索引合并，先在哪个条件再走哪个，是否可以用缓存，用之前提到的mysql成本概念来计算每种方式的成本，然后选择一个最优。&lt;/li&gt;
&lt;li&gt;执行阶段：通过2中选出的最优方案来执行&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;详细介绍bufferPool&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第18章buffer-pool"&gt;第18章、Buffer Pool
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;缓存页&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;buffer pool中有多个大小为16k的缓存页（与mysql默认一页大小一样），用于缓存从磁盘读取的页数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用来存放缓存页控制信息的内存，&lt;font color='red'&gt;控制块和缓存页是一一对应的，它们都被存储在Buffer Pool中，控制块存储在前面，缓存页在后面。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855692816_1744855692829.png"
loading="lazy"
alt="1744855692816.png"
&gt;&lt;/p&gt;
&lt;h3 id="free链表"&gt;free链表
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855712630_1744855712645.png"
loading="lazy"
alt="1744855712630.png"
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用来存储空闲的缓存页和控制页，当需要读取时，就从free链表中读取缓存页和控制块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mysql把所有空闲的缓存页对应的控制块作为一个节点放到free链表中。&lt;/p&gt;
&lt;h3 id="flush链表"&gt;flush链表
&lt;/h3&gt;&lt;p&gt;&lt;font color='red'&gt; mysql不会立刻把修改的数据页同步到磁盘，而是采用flush链表方式来同步。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;结构与free链表类似，flush链表会缓存一些已经修改过的缓存页，在到达同步的时间点时，mysql会从flush链表中读取缓存页来同步到磁盘。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855734142_1744855734160.png"
loading="lazy"
alt="1744855734142.png"
&gt;&lt;/p&gt;
&lt;h3 id="lru链表"&gt;LRU链表
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;类似于垃圾回收链表，用来判断哪些缓存页可以清除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744855790805_1744855790820.png"
loading="lazy"
alt="1744855790805.png"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;所有首次被加载到Buffer Pool的缓存页，该缓存页会被放到old区域的头部&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;why？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们进行全表扫描，大量数据会被加载到buffer pool为了不使young区缓存的数据直接全部失效，就把新数据放到old区的头部。&lt;/p&gt;
&lt;p&gt;全表扫描不断有数据会插入old区头部，超出的从old区尾部被淘汰，来保证不会由于无效数据的加载而是缓存失效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那么young区的数据是如何被添加的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在LRU缓存中，数据首次进入进入缓存，会在old区的头部，并会在缓存控制块中记录添加的时间。如果又一次访问刚刚添加的缓存，就会计算本次访问的上次添加的间隔时间，如果时间少于mysql系统设定的缓存间隔时间（默认1秒），就把本缓存控制块从old区取出，并添加到young区的头部&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第19章事务"&gt;第19章、事务
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;AICD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原子性、隔离性、一致性、持久性&lt;/p&gt;
&lt;h3 id="事务的几种状态"&gt;事务的几种状态
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;活动的（active）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务对应的数据库正在执行过程中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部分提交（partially committed）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务在内存中的操作已经完成，还没有被写入到磁盘中（在buffer pool中，还没有被写入到磁盘页中）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;失败（failed）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务处于活动或者部分提交状态时，出现了错误，事务就会变成失败状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中止（aborted）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;失败的事务被回滚后，就处于中止状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已提交（committed）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务被修改的数据已经成功同步到磁盘上，就变为已提交状态。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744353227133_1744353227153.png"
loading="lazy"
alt="1744353227133.png"
&gt;&lt;/p&gt;
&lt;h2 id="第20章redo日志"&gt;第20章、redo日志
&lt;/h2&gt;&lt;p&gt;mysql访问数据，需要把磁盘中对应的数据页加载到内存中的bufferpool中。每次加载和修改都是以页为单位，落盘刷新也是以页为单位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color='red'&gt;存在的弊端&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;资源浪费：每次刷新都是一个完整的数据页，太浪费资源，即使只修改数据页中的一个字节，也要刷新16k的数据到磁盘。&lt;/li&gt;
&lt;li&gt;随机IO：由于一条语句可能修改多个数据页的数据，而不同数据页在磁盘中可能不是连续的。会产生随机IO寻址（速度非常慢）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;redo log的做法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在事务提交完成之前，把修改了哪些东西的记录都落在磁盘中。如果系统中间崩溃，也可以从磁盘中恢复刚刚修改的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redo log 的优点&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;redo log占用空间极小，只记录表空间id、页号、偏移量和需要更新的值&lt;/li&gt;
&lt;li&gt;redo log是顺序写入磁盘的，使用顺序IO，速度快&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="redo-log的结构"&gt;redo log的结构
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744357032403_1744357032426.png"
loading="lazy"
alt="1744357032403.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type：该redo log的类型&lt;/li&gt;
&lt;li&gt;space id：表空间id&lt;/li&gt;
&lt;li&gt;page number：页号&lt;/li&gt;
&lt;li&gt;data：具体内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="logbuffer"&gt;logbuffer
&lt;/h3&gt;&lt;p&gt;同样的，想要将redolog落入磁盘，也不是每次直接写到磁盘里。&lt;/p&gt;
&lt;p&gt;InnoDB有一块专门缓存日志的缓存叫logbuffer。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何写入一条redolog&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;先将redolog的内容写入logbuffer中。&lt;/li&gt;
&lt;li&gt;InnoDB每秒/每次事务提交之前都会将logbuffer中的内容写入到磁盘中。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;logbuffer如何垃圾回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;logbuffer几乎没有垃圾回收，固定的内存空间会记录一个脏点，有点类似于直接内存的概念，不会真的去删除内存中的数据，而是在下次写入时直接覆盖已经失效的内存空间。&lt;/p&gt;
&lt;h2 id="第22章undo-log"&gt;第22章、undo log
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用于回滚时的日志&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="事务id"&gt;事务id
&lt;/h3&gt;&lt;p&gt;聚簇索引的记录中，存在名为trx_id(事务id)、roll_pointer的隐藏列。&lt;/p&gt;
&lt;p&gt;当进行增删改操作时，InnoDB会自动生成对应的undo log和对应的事务id。&lt;/p&gt;
&lt;h3 id="insert"&gt;insert
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744361675334_1744361675354.png"
loading="lazy"
alt="1744361675334.png"
&gt;&lt;/p&gt;
&lt;p&gt;类似链表的形式，开头内存指向当前属性结尾的地址，结尾内存指向上一条结尾的地址，方便遍历，增删改。&lt;/p&gt;
&lt;h3 id="roll_pointer"&gt;roll_pointer
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个指针，指向记录对应的undo日志。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744696670326_1744696670345.png"
loading="lazy"
alt="1744696670326.png"
&gt;&lt;/p&gt;
&lt;h3 id="delete"&gt;DELETE
&lt;/h3&gt;&lt;p&gt;之前提过，mysql在删除数据时，并不是直接删除数据，而是把需要删除的数据放入垃圾回收链表，等待系统来删除。&lt;/p&gt;
&lt;p&gt;下面来详细解释删除的过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶段一（delete mark）事务提交前&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744697317539_1744697317578.png"
loading="lazy"
alt="1744697317539.png"
&gt;&lt;/p&gt;
&lt;p&gt;mysql会修改记录的trx_id、roll_pointer这些隐藏列的值）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除操作是为了实现MVCC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;阶段二（purge）事务提交后&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当上面删除语句的事务提交之后，会有专门的垃圾回收线程把记录删除掉。&lt;/p&gt;
&lt;p&gt;删除过程就是把此记录加入垃圾回收链表，修改页面的其他信息（如数量、删除插入记录的位置，页面可重用的大小等）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744697597883_1744697597915.png"
loading="lazy"
alt="1744697597883.png"
&gt;&lt;/p&gt;
&lt;h3 id="update"&gt;UPDATE
&lt;/h3&gt;&lt;h4 id="不更新主键的情况"&gt;不更新主键的情况
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;原地更新（in-place update）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;更新前的列和更新后的列占用空间大小一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;会直接更新原来的数据，不做特殊操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间变化的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;被修改的字段空间减小或者变大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;mysql会先执行删除操作（这里是真正的删除）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有dlelete mark阶段，由用户线程来把此记录从正常记录链表移除，然后添加到垃圾回收链表里。并修改页面相关的信息（统计信息等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后把新的值插入到正常记录链表里&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;font color='red'&gt;上述操作均由用户线程完成，所以一直流传着mysql更新速度会非常慢。&lt;/font&gt;&lt;/p&gt;
&lt;h4 id="更新主键的情况"&gt;更新主键的情况
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在局促索引中，mysql的记录是按照主键值的大小连成一个单向链表的，如果要修改主键的值，则可能要记录的移动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体操作步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将旧记录进行delete mark操作：（主线程进行了delete mark，后续有专门的垃圾回收线程来把它加入到垃圾回收链表并回收）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原因是为了适配MVCC，这样操作后，其他事务查询还是可以查到之前的值）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据更新后的值，再创建一条新的记录，重新定位位置并插入&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="回滚"&gt;回滚
&lt;/h3&gt;&lt;p&gt;回滚过程中，需要从回滚段中找到Undo页面，把对应的记录恢复回来。（恢复过程中，正常表会产生回滚的redo日志，临时表不产生redo日志）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从事务和undo 日志的角度详细介绍MVCC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第24章mvcc"&gt;第24章、MVCC
&lt;/h2&gt;&lt;h3 id="事务的隔离级别"&gt;事务的隔离级别
&lt;/h3&gt;&lt;h4 id="事务并发执行遇到的问题重点"&gt;&lt;font color='red'&gt;事务并发执行遇到的问题（重点）&lt;/font&gt;
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;脏写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务修改了另一个未提交事务修改过的数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;脏读&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务读到了另一个未提交事务修改过的数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可重复读&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;幻读&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。&lt;/p&gt;
&lt;h4 id="四种隔离级别"&gt;四种隔离级别
&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;脏读&lt;/th&gt;
&lt;th&gt;不可重复读&lt;/th&gt;
&lt;th&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读未提交 (READ UNCOMMITTED)&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;读已提交 (READ COMMITTED)&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;td&gt;可能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读 (REPEATABLE READ)（默认）&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;td&gt;可能（有特殊方法，避免出现幻读）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可串行化 (SERIALIZABLE)&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;td&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;无论哪种事务隔离级别，都不允许出现脏写情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="mvcc"&gt;MVCC
&lt;/h3&gt;&lt;h4 id="版本链"&gt;版本链
&lt;/h4&gt;&lt;p&gt;mysql记录中有两个必要的隐藏列（row_id不是不要的，只有在没有主见的情况下才有）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;trx_id：每次事务对某条聚簇索引记录进行了修改，就把事务id赋值到trx_id列&lt;/li&gt;
&lt;li&gt;roll_pointer：每次对聚簇索引记录进行修改时，都会把旧的版本写入到undo日志中，然后roll_pointer列就相当于一个指针，可以通过它找到修改前的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744784304336_1744784304388.png"
loading="lazy"
alt="1744784304336.png"
&gt;&lt;/p&gt;
&lt;p&gt;每次对记录进行修改，都会记录一条undo日志，每条undo日志都有一个roll_pointer属性，可以将这些undo连接起来，串成一个链表&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744784566914_1744784566950.png"
loading="lazy"
alt="1744784566914.png"
&gt;&lt;/p&gt;
&lt;p&gt;每次记录被更新后，都会将旧值放到一条undo日志中，所有版本的roll_pointer连接成一个链表。&lt;font color='red'&gt;版本链的头节点就是当前记录最新的值。&lt;/font&gt;（每条版本的undo日志都有一个事务id trx_id）&lt;/p&gt;
&lt;h4 id="readview"&gt;ReadView
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;判断版本链中哪个版本是当前事务可见的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ReadView的主要内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;m_ids：生成ReadView时当前系统活跃的读写事务的事务id列表&lt;/li&gt;
&lt;li&gt;min_trx_id：活跃事务列表中的最小事务id&lt;/li&gt;
&lt;li&gt;max_trx_id：生成ReadView时下一条事务id（不是只事务列表中的最大id，因为有可能较大的事务id在生成ReadView之前就已经被提交了）&lt;/li&gt;
&lt;li&gt;creator_trx_id：生成该ReadView的事务id。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何判断某个版本记录是否可见？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;被访问版本的trx_id和ReadView中的creator_trx_id相同，（该事务在访问自己修改过的版本）当前版本可见。&lt;/li&gt;
&lt;li&gt;如果被访问的版本trx_id小于ReadView的最小事务id，（生成该版本事务在ReadView生成前就已经提交了），当前版本可见。&lt;/li&gt;
&lt;li&gt;如果访问版本的trx_id大于ReadView中max_trx_id下一条事务的id，（访问版本的事务在当前事务生成ReadView之后才开始），当前版本不可见。&lt;/li&gt;
&lt;li&gt;访问版本的trx_id在ReadView的min_trx_id和max_trx_id之间，则判断访问版本的trx_id是否在ReadView活跃事务id列表中。如果在则不可见（生成ReadView时，事务还没有提交，还在修改数据），不在则可见(生成ReadView时，该事务已经被提交了)。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;不同的事务隔离级别，生成ReadView的时机不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;隔离级别&lt;/th&gt;
&lt;th&gt;生成ReadView的时机&lt;/th&gt;
&lt;th&gt;影响&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;读已提交&lt;/td&gt;
&lt;td&gt;每次读取数据前都生成一个ReadView&lt;/td&gt;
&lt;td&gt;每次查询时都独立生成一个ReadView，这样每次查询都会读到本次ReadView之前已经提交的版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可重复读&lt;/td&gt;
&lt;td&gt;第一次读取数据时生成ReadView&lt;/td&gt;
&lt;td&gt;第一次查询时才生成ReadView，这样即使ReadView事务列表中的其他事务后面提交了，当前事务也无法读到它的版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;串行化&lt;/td&gt;
&lt;td&gt;用锁实现&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;详细介绍mysql的各种锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="第25章锁"&gt;第25章、锁
&lt;/h2&gt;&lt;h3 id="上锁"&gt;上锁
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;mysql聚簇索引记录上本身是没有锁的，但为什么常常说mysql是根据索引来上锁的呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mysql在查询或者增、删改时，都先会去锁结构中来获取当前记录的上锁状态。（锁结构只有在上锁时才有，且结构与聚簇索引类似）&lt;/p&gt;
&lt;p&gt;由于需要通过聚簇索引去索结构中获取对应记录的上锁情况，所以常说mysql上锁是根据索引来上的。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744792329148_1744792329181.png"
loading="lazy"
alt="1744792329148.png"
&gt;&lt;/p&gt;
&lt;p&gt;之前说过mysql在可重复读隔离级别就已经解决了幻读问题：具体的借据方案如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读操作利用多版本并发控制（MVCC），写操作进行加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读：&lt;/p&gt;
&lt;p&gt;由于可重复读只会在第一查询时来生成对应的ReadView，而此时之前提交的事务已经被快照了，本事务也只能查到历史的版本数据，就算有最新的事务修改并提交了新的版本。本事务也无法读到。&lt;/p&gt;
&lt;p&gt;写：&lt;/p&gt;
&lt;p&gt;所有的写操作都是修改最新的版本，修改时会上锁，多个事务不会冲突。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读、写操作都加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有业务读取记录时不允许读取旧版本，每次查询都只能获取最新版本的记录，则需在要读写的时候都加锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MVCC方式读写操作不冲突，性能更高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="读锁"&gt;读锁
&lt;/h3&gt;&lt;h4 id="共享锁和独占锁"&gt;共享锁和独占锁
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;共享锁：S锁，事务读取记录时，需要先获取该记录的S锁。&lt;/li&gt;
&lt;li&gt;独占锁：排它锁，x锁，事务修改记录时，需要先获取该记录的X锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="写锁"&gt;写锁
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;delete&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;先在B+树中获取该记录的位置&lt;/li&gt;
&lt;li&gt;获取这条记录的X锁&lt;/li&gt;
&lt;li&gt;再执行delete mark操作&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;update&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改后空间没有变化的：
&lt;ol&gt;
&lt;li&gt;先在B+树中定位位置&lt;/li&gt;
&lt;li&gt;获取X锁&lt;/li&gt;
&lt;li&gt;原地修改&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;空间发生变化的
&lt;ol&gt;
&lt;li&gt;在B+树中定位位置&lt;/li&gt;
&lt;li&gt;获取X锁&lt;/li&gt;
&lt;li&gt;将该记录彻底删除掉（把此记录添加到垃圾链表）&lt;/li&gt;
&lt;li&gt;插入一条新记录（新插入的记录被隐式锁保护）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;修改了主键
&lt;ol&gt;
&lt;li&gt;在原记录上执行Delete操作&lt;/li&gt;
&lt;li&gt;在执行一条insert操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insert&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般情况插入不加锁，插入后InnoDB会添加隐式锁，来保护此记录不被别的事务访问&lt;/p&gt;
&lt;h3 id="不同锁的粒度对齐颗粒度-"&gt;不同锁的粒度（对齐颗粒度:-)）
&lt;/h3&gt;&lt;h4 id="表锁"&gt;表锁
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在执行DDL语句时会上表锁，上锁方式时通过元数据锁来实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="行锁重点"&gt;行锁（重点）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Record Locks（记录锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按记录的维度来上锁，一条记录一个锁&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gap Locks（间隙锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;用来解决幻读问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上锁范围为要锁的记录（可能有多条记录）的上一条记录结尾，和下一条记录的开始。&lt;/p&gt;
&lt;p&gt;&lt;font color='red'&gt;保证锁定范围与上一条和下一条之间都不能插入数据&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744792054712_1744792054748.png"
loading="lazy"
alt="1744792054712.png"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Next-Key Locks：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与Gap锁类似，只不过只是不允许在锁定记录与上一条之间插入数据。&lt;/p&gt;
&lt;p&gt;锁定记录的后面允许插入数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐式锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前说ReadView时，会判断事务id，相当于上了隐式锁。&lt;/p&gt;
&lt;h3 id="innodb锁的内存结构"&gt;InnoDB锁的内存结构
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-04/1744792681344_1744792681377.png"
loading="lazy"
alt="1744792681344.png"
&gt;&lt;/p&gt;</description></item><item><title>关于Online DDL</title><link>https://thecoolboyhan.github.io/p/online-ddl/</link><pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate><guid>https://thecoolboyhan.github.io/p/online-ddl/</guid><description>&lt;img src="https://thecoolboyhan.github.io/p/online-ddl/onlineddl.png" alt="Featured image of post 关于Online DDL" /&gt;&lt;h2 id="online-ddl的发展史"&gt;Online DDL的发展史
&lt;/h2&gt;&lt;p&gt;在早期的MySQL版本中,DDL操作通常需要对数据表加锁，操作过程中DML操作都会被阻塞，影响正常业务。MySQL5.6和MariaDB 10.0开始支持Online DDL，可以在支持DDL操作的同时，不影响DML的正常执行，线上直接执行DDL操作对用户基本无感知（部分操作会对性能有影响）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL 5.6之前
MySQL的DDL操作会按照原来的表复制一份，并做相应的修改：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;按照表A的定义新建一个表B&lt;/li&gt;
&lt;li&gt;对表A加锁&lt;/li&gt;
&lt;li&gt;在表B上执行DDL指定的操作&lt;/li&gt;
&lt;li&gt;将表A的数据拷贝到B&lt;/li&gt;
&lt;li&gt;释放A的写锁&lt;/li&gt;
&lt;li&gt;删除表A&lt;/li&gt;
&lt;li&gt;将表B重命名为A&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MySQL 5.6
官方开始支持更多的ALTER TABLE类型操作来避免数据拷贝，同时支持了在线上DDL的过程中不阻塞DML操作，真正意义上实现了Online DDL。然而并不是所有的DDL操作都支持在线操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 5.7
在5.6的基础上又增加了新的特性，比如：增加了重命名索引支持，支持数值类型长度的增大和减少，支持了VARCHAR类型的在线增大等。基本逻辑和限制条件相比5.6并没有大的变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 8.0对DDL的实现重新进行了设计
DDL操作支持了原子特性。另外，Online DDL的ALGORITHM参数增加了一个新的选项：INSTANT，只需要修改数据字典中的元数据，无需拷贝数据也无需重建表，同样也无需加排他MDL锁，原表数据也不受影响。整个DDL过程几乎瞬间完成的，也不会阻塞DML。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="online-ddl的算法"&gt;Online DDL的算法
&lt;/h2&gt;&lt;h3 id="copy算法之前ddl的算法"&gt;Copy算法（之前DDL的算法）
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;按照原表定义创建一个新的临时表&lt;/li&gt;
&lt;li&gt;对原表加写锁（禁止DML，允许select）&lt;/li&gt;
&lt;li&gt;对临时表进行DDL&lt;/li&gt;
&lt;li&gt;将原表数据copy到临时表&lt;/li&gt;
&lt;li&gt;释放原表的写锁&lt;/li&gt;
&lt;li&gt;将原表删除，并将临时表重命名为原表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-5-1111_11_39-1715397098637_1747037696873.png"
loading="lazy"
alt="2024-5-1111_11_39-1715397098637.png"
&gt;&lt;/p&gt;
&lt;h3 id="inplace算法"&gt;Inplace算法
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-5-1111_12_50-1715397170155_1747037762761.png"
loading="lazy"
alt="2024-5-1111_12_50-1715397170155.png"
&gt;&lt;/p&gt;
&lt;p&gt;在原表上进行更改，不需要生成临时表，不需要进行数据copy的过程。根据是否变更行记录格式，分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;rebuild：需要重建表（重新组织聚簇索引）。比如optimize table、添加索引、添加/删除列、修改列NULL/NOT NULL属性等；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start="2"&gt;
&lt;li&gt;no-rebuild：不需要重建表，只需要修改表的元数据，比如删除索引、修改列名、修改列默认值、修改列自增值等。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;对于rebuild方式实现Online 是通过缓存DDL期间的DML，待DDL完成之后，将DML应用到表上来实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="说明"&gt;说明
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在copy数据到新表期间，在原表上是加的MDL读锁（允许DML，禁止DDL）&lt;/li&gt;
&lt;li&gt;在应用增量期间对原表加MDL写锁（禁止DML和DDL）&lt;/li&gt;
&lt;li&gt;根据表A重建出来的数据是放在tmp_file里的，这个临时文件是InnoDB在内部创建出来的，整个DDL过程都在InnoDB内部完成。对于server层来说，没有把数据挪动到临时表，是一个原地操作，这就是&amp;rsquo;inplace&amp;rsquo;名称的来源。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="mysql中表级别的锁有2种"&gt;MySQL中，表级别的锁有2种
&lt;/h4&gt;&lt;p&gt;一种是我们通常说的表锁，由InnoDB引擎实现，如lock tables&amp;hellip;
read/write,表锁影响较大，不常用。另一种表级别的锁是MDL（metadata lock），由server层实现，MDL我们不显示使用，是在访问数据库时由数据库自动加的，对表记录增删改查时，加MDL读锁；对表结构进行变更时，加MDL写锁。MDL锁，读读不互斥，读写、写写互斥。&lt;/p&gt;
&lt;h4 id="哪些常用操作锁表"&gt;哪些常用操作“锁表”
&lt;/h4&gt;&lt;p&gt;创建二级索引、删除索引、重命名索引、改变索引类型&amp;ndash;不“锁表”。
添加字段、删除字段、重命名字段、调整字段顺序、设置字段默认值、删除字段默认值、修改auto-increment值、调整字段允许NULL、调整字段不允许Null &amp;mdash;不“锁表”。
扩展Varchar字段大小&amp;mdash;不锁表。
更改字段数据类型，如varchar改成text&amp;mdash;锁表。&lt;/p&gt;
&lt;h2 id="online-ddl过程中的锁"&gt;Online DDL过程中的锁
&lt;/h2&gt;&lt;p&gt;默认情况下，MySQL就是支持Online的DDL操作的，在online DDL语句执行过程中，MySQL会尽量少使用锁的限制，我们不需要特殊的操作来启用它。
MySQL在选择的时候，尽量少使用锁，但不排除它会使用锁。而如果我们担心它使用了锁而导致我们不能读也不能写，显然这不是我们想要的结果，我们希望：如果选择锁，就不要执行，直接退出执行；如果没有选择锁就执行。&lt;/p&gt;
&lt;p&gt;可以在执行我们的Online DDL语句时，使用Algorithm和lock关键字，这两个关键字在我们DDL语句的最后面，用逗号隔开即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;alter&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;table&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tabl_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;add&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;column&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;col_name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;col_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;algorithm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;inplace&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;none&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="algorithm的选项"&gt;algorithm的选项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;inplace：替换：直接在原表上面执行DDL的操作。&lt;/li&gt;
&lt;li&gt;copy：复制：使用一种临时表的方式，克隆出一个临时表，在临时表上执行DDL，然后再把数据导入到临时表中，在重命名等。这期间需要多出一倍的磁盘空间来支撑这样的操作。执行期间，表不允许DML的操作。&lt;/li&gt;
&lt;li&gt;default：默认方式，由MySQL自己选择，优先使用inplace的方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lock选项"&gt;lock选项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;share：共享锁，执行DDL的表可以读，但是不可以写。&lt;/li&gt;
&lt;li&gt;None：没有任何限制，执行DDL的表可读可写。&lt;/li&gt;
&lt;li&gt;exclusive：排它锁，执行DDL的表不可以读也不可以写。&lt;/li&gt;
&lt;li&gt;default：默认值，由MySQL来决定是否锁表。不建议使用，如果你确定你的DDL语句不会锁表，你可以不指定lock或者指定它的值为default，否则建议指定它的锁类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;执行DDL操作时，algorithm选项可以不指定，这时候MySQL按照instant、inplace、copy的顺序自动选择合适的模式。也可以指定algorithm=default，也是同样的效果。如果指定algorithm选项，但不支持的话，会直接报错。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在执行OnlineDDL之前，要在非业务高峰期去执行，并要确认待执行的表上面没有未提交的事务、锁等信息。可以通过如下的SQL语句查看是否有事务和锁等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-sql" data-lang="sql"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;information_schema&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innodb_locks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;查询是否有锁&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;information_schema&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innodb_trx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;查询事务信息&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;information_schema&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;innodb_lock_waits&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;查询锁等待信息&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;select&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;from&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;information_schema&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;processlist&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;数据库连接信息&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="mysql-57的在线ddl功能特点"&gt;MySQL 5.7的在线DDL功能特点
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;支持添加辅助索引：可以在运行中的表上添加辅助索引，而不会对整个表进行锁定。&lt;/li&gt;
&lt;li&gt;支持修改列定义：可以在线修改列的数据类型、长度等定义。&lt;/li&gt;
&lt;li&gt;修改字符集合排序规则：可以在线修改表的字符集和排序规则设置。&lt;/li&gt;
&lt;li&gt;支持重命名列：可以在不影响正在进行的读写操作的情况下，对表中的列进行重命名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="实现原理和优化"&gt;实现原理和优化
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建临时表：通过创建临时表来存储将要进行的DDL操作所需要的新结构。这样旧表仍可用于读写操作。&lt;/li&gt;
&lt;li&gt;数据复制和同步：将旧表的数据逐步复制到临时表中，并保持旧表数据和临时表数据的同步，这一过程保证了数据在DDL操作期间的完整性和一致性。&lt;/li&gt;
&lt;li&gt;变更捕获和重放：通过使用日志和重做日志等机制，捕获在执行DDL操作期间发生的数据变更，并将其重放到临时表中。这确保了DDL操作完成后数据的一致性。&lt;/li&gt;
&lt;li&gt;最终切换：当DDL操作完成时，数据库引擎将在适当的时机切换到临时表，使其成为新的表结构，并且对新表进行后续的读写操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="使用限制和注意事项"&gt;使用限制和注意事项
&lt;/h2&gt;&lt;p&gt;= 并非所有DDL操作都支持在线执行，某些操作仍然需要锁定整个表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在进行DDL操作期间，可能会占用较多的系统资源，因此在高负载时应谨慎使用。&lt;/li&gt;
&lt;li&gt;进行在线DDL操作时，需要对操作进行充分的评估和测试，以确保数据的完整性和一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="online-ddl的执行过程"&gt;Online DDL的执行过程
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-5-1113_15_50-1715404549579_1747037825251.png"
loading="lazy"
alt="2024-5-1113_15_50-1715404549579.png"
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务器会根据存储引擎的能力，操作的语句和用户指定的algorithm和lock选项来决定允许多大程度的并发。在这个阶段会创建一个可升级元素的共享锁（SU）来保护表定义。&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;执行&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个阶段会准备并执行DDL语句，根据阶段1评估的结果来决定是否将元数据锁升级为排它锁（X），如果需要升级为排它锁，则只在DDL的准备阶段短暂的添加排它锁。&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;提交表定义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;元数据锁会升级为排它锁来更新表的定义。独占排他锁的时间非常短。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;元数据锁（MDL，metadata lock）主要用于DDL和DML操作之间的并发访问控制，保护表结构（表定义）的一致，保证读写的正确性。MDL不需要显式的使用，在访问时会自动加上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Online DDL过程必须等待已经持有元数据锁的并发事务提交或者回滚才能继续执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当Online DDL操作正在等待元数据锁时，该元数据锁会处于挂起状态，后续的所有事务都会被阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="评估online-ddl操作的性能"&gt;评估Online DDL操作的性能
&lt;/h2&gt;&lt;p&gt;Online DDL操作的性能取决于是否发生了表的重建。在对大表执行DDL操作之前，为了避免影响正常的业务操作，最好是先评估一下DDL语句的性能再选择如何操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复制表结构，创建一个新的表&lt;/li&gt;
&lt;li&gt;在新创建的表中插入少量数据。&lt;/li&gt;
&lt;li&gt;在新表上执行DDL操作&lt;/li&gt;
&lt;li&gt;检查执行操作后返回的rows affected 是否为0。 如果该值非0，则意味着需要拷贝表数据，此时对DDL的线上操作需要慎重考虑，周密计划。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="online-ddl原理"&gt;Online DDL原理
&lt;/h3&gt;&lt;p&gt;主要原理是将数据分为基线和增量两部分，开启一个单独线程变更基线数据，同时增量实时记录到row-log里。基线变更结束后，通过回放row-log，实现增量同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个过程有几个关键点：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;还是变更时获取快照，这个阶段需要禁写，确保获取snapshot对应的基线，后续增量（row-log）是一份完整的数据。&lt;/li&gt;
&lt;li&gt;在基线变更完成后，开始回放row-log，由于row-log随着业务的写入在不断地追加，因此需要基于一个前提：row-log的回放速度高于业务写入的速度，否则可能一直追不上，schema变更就无法完成。&lt;/li&gt;
&lt;li&gt;schema生效阶段同样需要禁写，确保不会有新的写进来，新的schema开始生效。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;instant ddl&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有点类似于X-DBFast DDL。其余和Online DDL的基本原理保持不变。对于MySQL的Online DDL方案，需要说明的是：MySQL主备副本之间通过binlog同步， 主的schema变更完成后，才会写binlog同步给备库，然后备库才开始做DDL。假设一个ddl变更需要1小时，那么备库最多可能会延迟2倍的变更时间。若变更期间，主库发生故障，备库数据还未追平，则无法提供服务的。&lt;/p&gt;
&lt;h3 id="f1-spanner架构的online-ddl"&gt;F1-Spanner架构的Online DDL
&lt;/h3&gt;&lt;p&gt;每个server都是无状态的，多副本复制靠存储层Spanner保证。对于Spanner而言，F1-Server相当于一个客户端。数据库的schema通过Spanner持久化存储，每个F1-Server在本地维护一份schema的缓存，并通过lease机制保证缓存的时效性。任何一个F1-Server都可以接收读取请求，如果schema缓存不正确，就无法保证存取数据正确性。&lt;/p&gt;
&lt;p&gt;如为表Realation（PK，C1）新加索引index（C1）。首先选举一个F1-Server作为owner，记为F1-Server1，执行DDL后拥有了new-schema，同时假设F1-Server2仍然使用old-schema。&lt;/p&gt;
&lt;p&gt;对于某个记录，F1-Server1会同时写入主表和索引数据；如果该记录后续被F1-Server2删除，那么只会删除主表记录，索引数据就会残留在系统中，这就产生了不一致。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S1（absent）：变更前的状态&lt;/li&gt;
&lt;li&gt;s2（delete-only）：只允许删除新二级索引，忽略新二级索引写入，不允许读新二级索引&lt;/li&gt;
&lt;li&gt;s3（write-only）：当所有F1-Server都达到S2状态后，开始进入这一阶段，允许删除/写入新二级索引进kv层，不允许读新二级索引，并开始扫描基线数据，构造新的二级索引&amp;lt;key,value&amp;gt;到kv层。&lt;/li&gt;
&lt;li&gt;s4（public):新二级索引对外可见（可读）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;F1论文详细论述了经过这4个状态的转变，如何保证一致性，过程较为复杂。
&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-5-1317_29_15-1715592555187_1747037878748.png"
loading="lazy"
alt="2024-5-1317_29_15-1715592555187.png"
&gt;&lt;/p&gt;
&lt;h3 id="copy算法"&gt;copy算法
&lt;/h3&gt;&lt;p&gt;较简单的实现方法，MySQL 会建立一个新的临时表，把源表的所有数据写入到临时表，在此期间无法对源表进行数据写入。MySQL 在完成临时表的写入之后，用临时表替换掉源表。这个算法主要被早期（&amp;lt;=5.5）版本所使用。&lt;/p&gt;
&lt;h3 id="inplance算法"&gt;inplance算法
&lt;/h3&gt;&lt;p&gt;从5.6开始，常用的DDL都默认使用这个算法。inplace算法包含两类：inplace-no-rebuild和inplace-rebuild，两者的主要差异在于是否需要重建源表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prepare阶段：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;创建新的临时frm文件（与InnoDB无关）。&lt;/li&gt;
&lt;li&gt;持有exclusive-MDL锁，禁止读写。&lt;/li&gt;
&lt;li&gt;根据alter类型，确定执行方式（copy，Online-rebuild，Online-not-rebuild）。更新数据字典的内存对象。&lt;/li&gt;
&lt;li&gt;分配row_log对象记录数据变更的增量（仅rebuild类型需要）。&lt;/li&gt;
&lt;li&gt;生产新的临时ibd文件new_table（仅rebuild类型需要）。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;execute阶段：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;降级MDL锁，允许读写。&lt;/li&gt;
&lt;li&gt;扫描old_table聚簇索引（主键）中的每条记录rec。&lt;/li&gt;
&lt;li&gt;遍历new_table的聚簇索引和二级索引，逐一处理。根据rec构造对应的索引项。&lt;/li&gt;
&lt;li&gt;将构造索引项插入sort_buffer块排序。将sort_buffer块更新到new_table的索引上。&lt;/li&gt;
&lt;li&gt;记录Online-ddl执行过程中产生的增量（仅rebuild类型需要）。&lt;/li&gt;
&lt;li&gt;重放row_log中的操作到new_table的索引上（not-rebuild数据是在原表上更新）。&lt;/li&gt;
&lt;li&gt;重放row_log中的DML操作到new_table的数据行上。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;commit阶段：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;当前block为row_log最后一个时，禁止读写，升级到exclusive-MDL锁。&lt;/li&gt;
&lt;li&gt;重做row_log中最后一部分增量。更新InnoDB的数据字典。&lt;/li&gt;
&lt;li&gt;提交事务（刷事务的redo日志）。修改统计信息。&lt;/li&gt;
&lt;li&gt;rename临时Ibd文件，frm文件。&lt;/li&gt;
&lt;li&gt;变更完成后，是否exclusive-MDL锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="instant-算法"&gt;instant 算法
&lt;/h3&gt;&lt;p&gt;MySQL 8.0.12 才提出的新算法，目前只支持添加列等少量操作，利用 8.0 新的表结构设计，可以直接修改表的 metadata 数据，省掉了 rebuild 的过程，极大的缩短了 DDL 语句的执行时间。&lt;/p&gt;
&lt;h3 id="pt-online-schema-change"&gt;pt-online-schema-change
&lt;/h3&gt;&lt;p&gt;借鉴了 copy 算法的思路，由外部工具来完成临时表的建立，数据同步，用临时表替换源表这三个步骤。其中数据同步是利用 MySQL 的触发器来实现的，会少量影响到线上业务的 QPS 及 SQL 响应时间。&lt;/p&gt;
&lt;h3 id="mysql-80特性-instant-add-column快速加列"&gt;MySQL 8.0特性 instant add column(快速加列）
&lt;/h3&gt;&lt;p&gt;快速加列采用的算法是instant算法，使得添加列时不再需要rebuild整个表，只需要在表的metadata中记录新增列的基本信息即可。&lt;/p&gt;
&lt;p&gt;mysql8.0对表metadata结构做出了变更。8.0除了在表的metadata信息中新增了instant列的默认值以及非instant列的数量之外，还在数据的物理记录中加入了info_bit，包括一个flag来标记这条记录是否为添加instant列之外才更新、插入的，以及column_num，用来记录行数据总共有多少列。&lt;/p&gt;
&lt;p&gt;当使用instant算法来添加列的时候，无需rebuild表，直接把列的信息记录到metadata中即可，对这些行进行操作时，可以读取metadata的信息来组合出完整的行数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;select：读取一行数据的物理记录时，会根据flag来判断是否需要去metadata中获取instant列的信息；如果需要，则根据colu-mn_num来读取实际的物理数据，再从metadata中补全缺少的instant列数据。&lt;/li&gt;
&lt;li&gt;insert：额外记录语句执行时的flag和column_num&lt;/li&gt;
&lt;li&gt;delete：与以前的版本保持一致&lt;/li&gt;
&lt;li&gt;Update：如果表的instant column数量发生了变化，对旧数据的update会在内部转换成delete和insert操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当对包含instant列的表进行rebuild时，所有数据在rebuild的过程中重新以旧的数据格式（包含所有列的内容）写入到表中，所以rebuild表之后，information_schema中有关这个表的instant的信息会被重置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="默认使用instant算法的操作"&gt;默认使用instant算法的操作：
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;添加列&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;不支持删除普通列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="2"&gt;
&lt;li&gt;添加或删除一个虚拟列&lt;/li&gt;
&lt;li&gt;添加或者删除一个列的默认值&lt;/li&gt;
&lt;li&gt;修改enum或者set列的定义&lt;/li&gt;
&lt;li&gt;变更索引的类型（B树、哈希）&lt;/li&gt;
&lt;li&gt;使用alter语法重命名表&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="使用限制"&gt;使用限制
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;如果alter语句包含了add column和其他操作，其中有操作不支持instant算法的，那么alter语句会报错，所有的操作都不会执行。&lt;/li&gt;
&lt;li&gt;添加列时，不能使用after关键字控制列的位置，只能添加在表的末尾（最后一列）。&lt;/li&gt;
&lt;li&gt;开启压缩的InnoDB表无法使用instant算法。&lt;/li&gt;
&lt;li&gt;不支持包含全文索引的表。&lt;/li&gt;
&lt;li&gt;仅支持使用mysql8.0新表空间格式的表。&lt;/li&gt;
&lt;li&gt;不支持临时表。&lt;/li&gt;
&lt;li&gt;包含instant列的表无法再旧版本的mysql上使用（即物理备份无法恢复）。&lt;/li&gt;
&lt;li&gt;在旧版本上，如果表或者表的索引已经corrupt，除非已经执行fix或者rebuild，否则升级到新版本后无法添加instant列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="各版本支持的-online-ddl语句"&gt;各版本支持的 Online DDL语句
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-5-1113_49_16-1715406556009_1747037918250.png"
loading="lazy"
alt="2024-5-1113_49_16-1715406556009.png"
&gt;&lt;/p&gt;
&lt;h3 id="各版本online-ddl支持情况"&gt;各版本Online DDL支持情况
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://fastly.jsdelivr.net/gh/thecoolboyhan/th_blogs@main/image/2025-05/2024-5-1113_57_36-1715407056279_1747037944367.png"
loading="lazy"
alt="2024-5-1113_57_36-1715407056279.png"
&gt;&lt;/p&gt;
&lt;h2 id="ddl的执行模式"&gt;DDL的执行模式
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;instant DDL 是MySQL8.0 引入的新功能，当前支持的范围较小，包括：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;修改二级索引类型&lt;/li&gt;
&lt;li&gt;新增列&lt;/li&gt;
&lt;li&gt;修改列默认值&lt;/li&gt;
&lt;li&gt;修改列ENUM值&lt;/li&gt;
&lt;li&gt;重命名表&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;在执行DDL操作时，MySQL内部对algorithm的选择策略：
如果用户显示指定了algorithm，那么使用用户指定的选项。
如果用户未指定，那么如果该操作支持inplace在优先选择inplace，否则选择copy。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;目前不支持inplace的操作主要有：
删除主键
修改列数据类型
修改表字符集&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;我们常说的Online DDL，其实是从DML操作的角度描述的，如果DDL操作不阻塞DML操作，那个这个DDL就是Online的。目前8.0默认非Online的DDL有：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;新增全文索引&lt;/li&gt;
&lt;li&gt;新增空间索引&lt;/li&gt;
&lt;li&gt;删除主键&lt;/li&gt;
&lt;li&gt;修改列数据类型&lt;/li&gt;
&lt;li&gt;指定表字符集&lt;/li&gt;
&lt;li&gt;修改表字符集&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="qa"&gt;Q&amp;amp;A
&lt;/h2&gt;&lt;h3 id="online-ddl会不会锁表"&gt;Online DDL会不会锁表？
&lt;/h3&gt;&lt;p&gt;很多MySQL用户经常在表无法正常的进行DML时就觉得是表锁了，这种说法其实是过于宽泛，实际上能够影响DML操作的锁至少包括以下几种（InnoDB）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MDL锁&lt;/li&gt;
&lt;li&gt;表锁&lt;/li&gt;
&lt;li&gt;行锁&lt;/li&gt;
&lt;li&gt;GAP锁
其中除了MDL锁是在Server层加的之外，其他三种都是在InnoDB层加的。所有操作都是需要先拿Server层的MDL锁，然后再去拿InnoDB层的某个需要的锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个DDL的基本过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在开始进行DDL时，需要拿到对应表的MDL X锁，然后进行一系列的准备工作；&lt;/li&gt;
&lt;li&gt;将MDL X锁降级为MDL S锁，进行真正的DDL操作。&lt;/li&gt;
&lt;li&gt;再次将MDL S锁升级为MDL X锁，完成DDL操作，释放DML锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;真正执行DDL操作期间，确实是不会“锁表”的，但如果在第一阶段拿MDL X锁时无法正常获取，那就可能真的会“锁表”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;select sleep(500) from mytest.t1;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;## session 2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;optimize table mytest.t1;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;## session 3
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;select * from mytest.t1;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;session 1模拟了一个慢查询，然后session 2 可是进行DDL操作，无法拿到MDL X锁，处于等待中。此时session 3 需要执行一个查询，发现无法执行。实际上，在session 1 结束前，表t1的所有操作都无法进行了，也可以说表t1“锁表”了。MySQL 5.7/8.0可以在开启performance_schema的情况下直接查询metadata_locks表。阿里云RDS新增了L_S.MDL_INFO表，提供DML的查询。&lt;/p&gt;
&lt;p&gt;现在回答问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Online DDL并不是绝对安全，更不是可以随意执行的。线上操作还是需要在业务低峰期谨慎操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="支持inplace算法的ddl一定是online的"&gt;支持inplace算法的DDL一定是Online的？
&lt;/h3&gt;&lt;p&gt;inplace和Online是两个不同维度的事情。copy和inplace指的是DDL内部的执行逻辑。
copy是在server层的操作，inplace是在InnoDB层的操作。
而用户更加关心Online与否，通常只和一个问题有关：是否允许并发DML。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;copy算法执行的DDL肯定不是Online的。&lt;/li&gt;
&lt;li&gt;inplace算法执行的DDL不一定是Online的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="inplace-ddl需不需要额外的数据空间"&gt;inplace DDL需不需要额外的数据空间
&lt;/h3&gt;&lt;p&gt;MySQL内部对于DDL的algorithm有两种选择：inplace和copy（8.0新增了instant，但使用范围较小）。
copy：创建一张临时表，然后将原表的数据拷贝到临时表中，最后再用临时表替换原表。对于上面的步骤，由于需要将原表的数据拷贝到临时表中，所以肯定需要消耗额外的数据空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于支持inplace算法的DDL，是不是不需要额外的数据空间？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要。inplace描述的是表，而不是数据文件。只要不创建临时表，那么就都是inplace的。
实际上，很多inplace DDL都会重建表（会创建临时数据文件），所以都会需要额外的数据空间。&lt;/p&gt;
&lt;p&gt;需要重建表的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加主键&lt;/li&gt;
&lt;li&gt;重建主键&lt;/li&gt;
&lt;li&gt;新增列（8.0支持instant DDL，不需要）&lt;/li&gt;
&lt;li&gt;删除列&lt;/li&gt;
&lt;li&gt;调整列顺序&lt;/li&gt;
&lt;li&gt;删除列默认值&lt;/li&gt;
&lt;li&gt;增加列默认值&lt;/li&gt;
&lt;li&gt;修改表的row_format&lt;/li&gt;
&lt;li&gt;optimize表&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>